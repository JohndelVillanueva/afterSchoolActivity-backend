
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model activitysession
 * 
 */
export type activitysession = $Result.DefaultSelection<Prisma.$activitysessionPayload>
/**
 * Model afterschoolactivity
 * 
 */
export type afterschoolactivity = $Result.DefaultSelection<Prisma.$afterschoolactivityPayload>
/**
 * Model attendance
 * 
 */
export type attendance = $Result.DefaultSelection<Prisma.$attendancePayload>
/**
 * Model attendance_library
 * 
 */
export type attendance_library = $Result.DefaultSelection<Prisma.$attendance_libraryPayload>
/**
 * Model borrowers
 * 
 */
export type borrowers = $Result.DefaultSelection<Prisma.$borrowersPayload>
/**
 * Model buyers
 * 
 */
export type buyers = $Result.DefaultSelection<Prisma.$buyersPayload>
/**
 * Model clinic_history
 * 
 */
export type clinic_history = $Result.DefaultSelection<Prisma.$clinic_historyPayload>
/**
 * Model countries
 * 
 */
export type countries = $Result.DefaultSelection<Prisma.$countriesPayload>
/**
 * Model enrolledactivity
 * 
 */
export type enrolledactivity = $Result.DefaultSelection<Prisma.$enrolledactivityPayload>
/**
 * Model inventory
 * 
 */
export type inventory = $Result.DefaultSelection<Prisma.$inventoryPayload>
/**
 * Model inventory__suppliers
 * 
 */
export type inventory__suppliers = $Result.DefaultSelection<Prisma.$inventory__suppliersPayload>
/**
 * Model inventory_bookstore
 * 
 */
export type inventory_bookstore = $Result.DefaultSelection<Prisma.$inventory_bookstorePayload>
/**
 * Model library_login
 * 
 */
export type library_login = $Result.DefaultSelection<Prisma.$library_loginPayload>
/**
 * Model logs_enroll
 * 
 */
export type logs_enroll = $Result.DefaultSelection<Prisma.$logs_enrollPayload>
/**
 * Model nationalities
 * 
 */
export type nationalities = $Result.DefaultSelection<Prisma.$nationalitiesPayload>
/**
 * Model products
 * 
 */
export type products = $Result.DefaultSelection<Prisma.$productsPayload>
/**
 * Model requests
 * 
 */
export type requests = $Result.DefaultSelection<Prisma.$requestsPayload>
/**
 * Model s_activities
 * 
 */
export type s_activities = $Result.DefaultSelection<Prisma.$s_activitiesPayload>
/**
 * Model s_classattendance
 * 
 */
export type s_classattendance = $Result.DefaultSelection<Prisma.$s_classattendancePayload>
/**
 * Model s_coretable
 * 
 */
export type s_coretable = $Result.DefaultSelection<Prisma.$s_coretablePayload>
/**
 * Model s_corevalues
 * 
 */
export type s_corevalues = $Result.DefaultSelection<Prisma.$s_corevaluesPayload>
/**
 * Model s_payables
 * 
 */
export type s_payables = $Result.DefaultSelection<Prisma.$s_payablesPayload>
/**
 * Model s_recommendations
 * 
 */
export type s_recommendations = $Result.DefaultSelection<Prisma.$s_recommendationsPayload>
/**
 * Model s_scores
 * 
 */
export type s_scores = $Result.DefaultSelection<Prisma.$s_scoresPayload>
/**
 * Model s_studentcv
 * 
 */
export type s_studentcv = $Result.DefaultSelection<Prisma.$s_studentcvPayload>
/**
 * Model s_subjects
 * 
 */
export type s_subjects = $Result.DefaultSelection<Prisma.$s_subjectsPayload>
/**
 * Model s_transmute
 * 
 */
export type s_transmute = $Result.DefaultSelection<Prisma.$s_transmutePayload>
/**
 * Model s_verifications
 * 
 */
export type s_verifications = $Result.DefaultSelection<Prisma.$s_verificationsPayload>
/**
 * Model sales_history
 * 
 */
export type sales_history = $Result.DefaultSelection<Prisma.$sales_historyPayload>
/**
 * Model schedule
 * 
 */
export type schedule = $Result.DefaultSelection<Prisma.$schedulePayload>
/**
 * Model studentdetails
 * 
 */
export type studentdetails = $Result.DefaultSelection<Prisma.$studentdetailsPayload>
/**
 * Model timeoff
 * 
 */
export type timeoff = $Result.DefaultSelection<Prisma.$timeoffPayload>
/**
 * Model type_of_products
 * 
 */
export type type_of_products = $Result.DefaultSelection<Prisma.$type_of_productsPayload>
/**
 * Model uniform
 * 
 */
export type uniform = $Result.DefaultSelection<Prisma.$uniformPayload>
/**
 * Model uniform_inventory
 * 
 */
export type uniform_inventory = $Result.DefaultSelection<Prisma.$uniform_inventoryPayload>
/**
 * Model uniform_issued
 * 
 */
export type uniform_issued = $Result.DefaultSelection<Prisma.$uniform_issuedPayload>
/**
 * Model uniform_sizes
 * 
 */
export type uniform_sizes = $Result.DefaultSelection<Prisma.$uniform_sizesPayload>
/**
 * Model uniform_types
 * 
 */
export type uniform_types = $Result.DefaultSelection<Prisma.$uniform_typesPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model user22
 * 
 */
export type user22 = $Result.DefaultSelection<Prisma.$user22Payload>
/**
 * Model users24
 * 
 */
export type users24 = $Result.DefaultSelection<Prisma.$users24Payload>
/**
 * Model visitorlog
 * 
 */
export type visitorlog = $Result.DefaultSelection<Prisma.$visitorlogPayload>
/**
 * Model wispay
 * 
 */
export type wispay = $Result.DefaultSelection<Prisma.$wispayPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Activitysessions
 * const activitysessions = await prisma.activitysession.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Activitysessions
   * const activitysessions = await prisma.activitysession.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.activitysession`: Exposes CRUD operations for the **activitysession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activitysessions
    * const activitysessions = await prisma.activitysession.findMany()
    * ```
    */
  get activitysession(): Prisma.activitysessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.afterschoolactivity`: Exposes CRUD operations for the **afterschoolactivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Afterschoolactivities
    * const afterschoolactivities = await prisma.afterschoolactivity.findMany()
    * ```
    */
  get afterschoolactivity(): Prisma.afterschoolactivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.attendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance_library`: Exposes CRUD operations for the **attendance_library** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendance_libraries
    * const attendance_libraries = await prisma.attendance_library.findMany()
    * ```
    */
  get attendance_library(): Prisma.attendance_libraryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.borrowers`: Exposes CRUD operations for the **borrowers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Borrowers
    * const borrowers = await prisma.borrowers.findMany()
    * ```
    */
  get borrowers(): Prisma.borrowersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.buyers`: Exposes CRUD operations for the **buyers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buyers
    * const buyers = await prisma.buyers.findMany()
    * ```
    */
  get buyers(): Prisma.buyersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinic_history`: Exposes CRUD operations for the **clinic_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinic_histories
    * const clinic_histories = await prisma.clinic_history.findMany()
    * ```
    */
  get clinic_history(): Prisma.clinic_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.countries`: Exposes CRUD operations for the **countries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.countries.findMany()
    * ```
    */
  get countries(): Prisma.countriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrolledactivity`: Exposes CRUD operations for the **enrolledactivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrolledactivities
    * const enrolledactivities = await prisma.enrolledactivity.findMany()
    * ```
    */
  get enrolledactivity(): Prisma.enrolledactivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.inventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory__suppliers`: Exposes CRUD operations for the **inventory__suppliers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventory__suppliers
    * const inventory__suppliers = await prisma.inventory__suppliers.findMany()
    * ```
    */
  get inventory__suppliers(): Prisma.inventory__suppliersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory_bookstore`: Exposes CRUD operations for the **inventory_bookstore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventory_bookstores
    * const inventory_bookstores = await prisma.inventory_bookstore.findMany()
    * ```
    */
  get inventory_bookstore(): Prisma.inventory_bookstoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.library_login`: Exposes CRUD operations for the **library_login** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Library_logins
    * const library_logins = await prisma.library_login.findMany()
    * ```
    */
  get library_login(): Prisma.library_loginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.logs_enroll`: Exposes CRUD operations for the **logs_enroll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs_enrolls
    * const logs_enrolls = await prisma.logs_enroll.findMany()
    * ```
    */
  get logs_enroll(): Prisma.logs_enrollDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nationalities`: Exposes CRUD operations for the **nationalities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nationalities
    * const nationalities = await prisma.nationalities.findMany()
    * ```
    */
  get nationalities(): Prisma.nationalitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.productsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requests`: Exposes CRUD operations for the **requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requests
    * const requests = await prisma.requests.findMany()
    * ```
    */
  get requests(): Prisma.requestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s_activities`: Exposes CRUD operations for the **s_activities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S_activities
    * const s_activities = await prisma.s_activities.findMany()
    * ```
    */
  get s_activities(): Prisma.s_activitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s_classattendance`: Exposes CRUD operations for the **s_classattendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S_classattendances
    * const s_classattendances = await prisma.s_classattendance.findMany()
    * ```
    */
  get s_classattendance(): Prisma.s_classattendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s_coretable`: Exposes CRUD operations for the **s_coretable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S_coretables
    * const s_coretables = await prisma.s_coretable.findMany()
    * ```
    */
  get s_coretable(): Prisma.s_coretableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s_corevalues`: Exposes CRUD operations for the **s_corevalues** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S_corevalues
    * const s_corevalues = await prisma.s_corevalues.findMany()
    * ```
    */
  get s_corevalues(): Prisma.s_corevaluesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s_payables`: Exposes CRUD operations for the **s_payables** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S_payables
    * const s_payables = await prisma.s_payables.findMany()
    * ```
    */
  get s_payables(): Prisma.s_payablesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s_recommendations`: Exposes CRUD operations for the **s_recommendations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S_recommendations
    * const s_recommendations = await prisma.s_recommendations.findMany()
    * ```
    */
  get s_recommendations(): Prisma.s_recommendationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s_scores`: Exposes CRUD operations for the **s_scores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S_scores
    * const s_scores = await prisma.s_scores.findMany()
    * ```
    */
  get s_scores(): Prisma.s_scoresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s_studentcv`: Exposes CRUD operations for the **s_studentcv** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S_studentcvs
    * const s_studentcvs = await prisma.s_studentcv.findMany()
    * ```
    */
  get s_studentcv(): Prisma.s_studentcvDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s_subjects`: Exposes CRUD operations for the **s_subjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S_subjects
    * const s_subjects = await prisma.s_subjects.findMany()
    * ```
    */
  get s_subjects(): Prisma.s_subjectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s_transmute`: Exposes CRUD operations for the **s_transmute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S_transmutes
    * const s_transmutes = await prisma.s_transmute.findMany()
    * ```
    */
  get s_transmute(): Prisma.s_transmuteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s_verifications`: Exposes CRUD operations for the **s_verifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S_verifications
    * const s_verifications = await prisma.s_verifications.findMany()
    * ```
    */
  get s_verifications(): Prisma.s_verificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sales_history`: Exposes CRUD operations for the **sales_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales_histories
    * const sales_histories = await prisma.sales_history.findMany()
    * ```
    */
  get sales_history(): Prisma.sales_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.scheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentdetails`: Exposes CRUD operations for the **studentdetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Studentdetails
    * const studentdetails = await prisma.studentdetails.findMany()
    * ```
    */
  get studentdetails(): Prisma.studentdetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeoff`: Exposes CRUD operations for the **timeoff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Timeoffs
    * const timeoffs = await prisma.timeoff.findMany()
    * ```
    */
  get timeoff(): Prisma.timeoffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.type_of_products`: Exposes CRUD operations for the **type_of_products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Type_of_products
    * const type_of_products = await prisma.type_of_products.findMany()
    * ```
    */
  get type_of_products(): Prisma.type_of_productsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.uniform`: Exposes CRUD operations for the **uniform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Uniforms
    * const uniforms = await prisma.uniform.findMany()
    * ```
    */
  get uniform(): Prisma.uniformDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.uniform_inventory`: Exposes CRUD operations for the **uniform_inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Uniform_inventories
    * const uniform_inventories = await prisma.uniform_inventory.findMany()
    * ```
    */
  get uniform_inventory(): Prisma.uniform_inventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.uniform_issued`: Exposes CRUD operations for the **uniform_issued** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Uniform_issueds
    * const uniform_issueds = await prisma.uniform_issued.findMany()
    * ```
    */
  get uniform_issued(): Prisma.uniform_issuedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.uniform_sizes`: Exposes CRUD operations for the **uniform_sizes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Uniform_sizes
    * const uniform_sizes = await prisma.uniform_sizes.findMany()
    * ```
    */
  get uniform_sizes(): Prisma.uniform_sizesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.uniform_types`: Exposes CRUD operations for the **uniform_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Uniform_types
    * const uniform_types = await prisma.uniform_types.findMany()
    * ```
    */
  get uniform_types(): Prisma.uniform_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user22`: Exposes CRUD operations for the **user22** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User22s
    * const user22s = await prisma.user22.findMany()
    * ```
    */
  get user22(): Prisma.user22Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users24`: Exposes CRUD operations for the **users24** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users24s
    * const users24s = await prisma.users24.findMany()
    * ```
    */
  get users24(): Prisma.users24Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitorlog`: Exposes CRUD operations for the **visitorlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visitorlogs
    * const visitorlogs = await prisma.visitorlog.findMany()
    * ```
    */
  get visitorlog(): Prisma.visitorlogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wispay`: Exposes CRUD operations for the **wispay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wispays
    * const wispays = await prisma.wispay.findMany()
    * ```
    */
  get wispay(): Prisma.wispayDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.1
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    activitysession: 'activitysession',
    afterschoolactivity: 'afterschoolactivity',
    attendance: 'attendance',
    attendance_library: 'attendance_library',
    borrowers: 'borrowers',
    buyers: 'buyers',
    clinic_history: 'clinic_history',
    countries: 'countries',
    enrolledactivity: 'enrolledactivity',
    inventory: 'inventory',
    inventory__suppliers: 'inventory__suppliers',
    inventory_bookstore: 'inventory_bookstore',
    library_login: 'library_login',
    logs_enroll: 'logs_enroll',
    nationalities: 'nationalities',
    products: 'products',
    requests: 'requests',
    s_activities: 's_activities',
    s_classattendance: 's_classattendance',
    s_coretable: 's_coretable',
    s_corevalues: 's_corevalues',
    s_payables: 's_payables',
    s_recommendations: 's_recommendations',
    s_scores: 's_scores',
    s_studentcv: 's_studentcv',
    s_subjects: 's_subjects',
    s_transmute: 's_transmute',
    s_verifications: 's_verifications',
    sales_history: 'sales_history',
    schedule: 'schedule',
    studentdetails: 'studentdetails',
    timeoff: 'timeoff',
    type_of_products: 'type_of_products',
    uniform: 'uniform',
    uniform_inventory: 'uniform_inventory',
    uniform_issued: 'uniform_issued',
    uniform_sizes: 'uniform_sizes',
    uniform_types: 'uniform_types',
    user: 'user',
    user22: 'user22',
    users24: 'users24',
    visitorlog: 'visitorlog',
    wispay: 'wispay'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "activitysession" | "afterschoolactivity" | "attendance" | "attendance_library" | "borrowers" | "buyers" | "clinic_history" | "countries" | "enrolledactivity" | "inventory" | "inventory__suppliers" | "inventory_bookstore" | "library_login" | "logs_enroll" | "nationalities" | "products" | "requests" | "s_activities" | "s_classattendance" | "s_coretable" | "s_corevalues" | "s_payables" | "s_recommendations" | "s_scores" | "s_studentcv" | "s_subjects" | "s_transmute" | "s_verifications" | "sales_history" | "schedule" | "studentdetails" | "timeoff" | "type_of_products" | "uniform" | "uniform_inventory" | "uniform_issued" | "uniform_sizes" | "uniform_types" | "user" | "user22" | "users24" | "visitorlog" | "wispay"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      activitysession: {
        payload: Prisma.$activitysessionPayload<ExtArgs>
        fields: Prisma.activitysessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.activitysessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitysessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.activitysessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitysessionPayload>
          }
          findFirst: {
            args: Prisma.activitysessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitysessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.activitysessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitysessionPayload>
          }
          findMany: {
            args: Prisma.activitysessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitysessionPayload>[]
          }
          create: {
            args: Prisma.activitysessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitysessionPayload>
          }
          createMany: {
            args: Prisma.activitysessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.activitysessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitysessionPayload>
          }
          update: {
            args: Prisma.activitysessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitysessionPayload>
          }
          deleteMany: {
            args: Prisma.activitysessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.activitysessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.activitysessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitysessionPayload>
          }
          aggregate: {
            args: Prisma.ActivitysessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivitysession>
          }
          groupBy: {
            args: Prisma.activitysessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivitysessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.activitysessionCountArgs<ExtArgs>
            result: $Utils.Optional<ActivitysessionCountAggregateOutputType> | number
          }
        }
      }
      afterschoolactivity: {
        payload: Prisma.$afterschoolactivityPayload<ExtArgs>
        fields: Prisma.afterschoolactivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.afterschoolactivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$afterschoolactivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.afterschoolactivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$afterschoolactivityPayload>
          }
          findFirst: {
            args: Prisma.afterschoolactivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$afterschoolactivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.afterschoolactivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$afterschoolactivityPayload>
          }
          findMany: {
            args: Prisma.afterschoolactivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$afterschoolactivityPayload>[]
          }
          create: {
            args: Prisma.afterschoolactivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$afterschoolactivityPayload>
          }
          createMany: {
            args: Prisma.afterschoolactivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.afterschoolactivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$afterschoolactivityPayload>
          }
          update: {
            args: Prisma.afterschoolactivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$afterschoolactivityPayload>
          }
          deleteMany: {
            args: Prisma.afterschoolactivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.afterschoolactivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.afterschoolactivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$afterschoolactivityPayload>
          }
          aggregate: {
            args: Prisma.AfterschoolactivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAfterschoolactivity>
          }
          groupBy: {
            args: Prisma.afterschoolactivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AfterschoolactivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.afterschoolactivityCountArgs<ExtArgs>
            result: $Utils.Optional<AfterschoolactivityCountAggregateOutputType> | number
          }
        }
      }
      attendance: {
        payload: Prisma.$attendancePayload<ExtArgs>
        fields: Prisma.attendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>
          }
          findFirst: {
            args: Prisma.attendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>
          }
          findMany: {
            args: Prisma.attendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>[]
          }
          create: {
            args: Prisma.attendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>
          }
          createMany: {
            args: Prisma.attendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.attendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>
          }
          update: {
            args: Prisma.attendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>
          }
          deleteMany: {
            args: Prisma.attendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.attendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.attendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.attendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      attendance_library: {
        payload: Prisma.$attendance_libraryPayload<ExtArgs>
        fields: Prisma.attendance_libraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attendance_libraryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendance_libraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attendance_libraryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendance_libraryPayload>
          }
          findFirst: {
            args: Prisma.attendance_libraryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendance_libraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attendance_libraryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendance_libraryPayload>
          }
          findMany: {
            args: Prisma.attendance_libraryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendance_libraryPayload>[]
          }
          create: {
            args: Prisma.attendance_libraryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendance_libraryPayload>
          }
          createMany: {
            args: Prisma.attendance_libraryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.attendance_libraryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendance_libraryPayload>
          }
          update: {
            args: Prisma.attendance_libraryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendance_libraryPayload>
          }
          deleteMany: {
            args: Prisma.attendance_libraryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attendance_libraryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.attendance_libraryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendance_libraryPayload>
          }
          aggregate: {
            args: Prisma.Attendance_libraryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance_library>
          }
          groupBy: {
            args: Prisma.attendance_libraryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Attendance_libraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.attendance_libraryCountArgs<ExtArgs>
            result: $Utils.Optional<Attendance_libraryCountAggregateOutputType> | number
          }
        }
      }
      borrowers: {
        payload: Prisma.$borrowersPayload<ExtArgs>
        fields: Prisma.borrowersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.borrowersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$borrowersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.borrowersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$borrowersPayload>
          }
          findFirst: {
            args: Prisma.borrowersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$borrowersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.borrowersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$borrowersPayload>
          }
          findMany: {
            args: Prisma.borrowersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$borrowersPayload>[]
          }
          create: {
            args: Prisma.borrowersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$borrowersPayload>
          }
          createMany: {
            args: Prisma.borrowersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.borrowersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$borrowersPayload>
          }
          update: {
            args: Prisma.borrowersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$borrowersPayload>
          }
          deleteMany: {
            args: Prisma.borrowersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.borrowersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.borrowersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$borrowersPayload>
          }
          aggregate: {
            args: Prisma.BorrowersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBorrowers>
          }
          groupBy: {
            args: Prisma.borrowersGroupByArgs<ExtArgs>
            result: $Utils.Optional<BorrowersGroupByOutputType>[]
          }
          count: {
            args: Prisma.borrowersCountArgs<ExtArgs>
            result: $Utils.Optional<BorrowersCountAggregateOutputType> | number
          }
        }
      }
      buyers: {
        payload: Prisma.$buyersPayload<ExtArgs>
        fields: Prisma.buyersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.buyersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buyersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.buyersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buyersPayload>
          }
          findFirst: {
            args: Prisma.buyersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buyersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.buyersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buyersPayload>
          }
          findMany: {
            args: Prisma.buyersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buyersPayload>[]
          }
          create: {
            args: Prisma.buyersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buyersPayload>
          }
          createMany: {
            args: Prisma.buyersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.buyersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buyersPayload>
          }
          update: {
            args: Prisma.buyersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buyersPayload>
          }
          deleteMany: {
            args: Prisma.buyersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.buyersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.buyersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buyersPayload>
          }
          aggregate: {
            args: Prisma.BuyersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuyers>
          }
          groupBy: {
            args: Prisma.buyersGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuyersGroupByOutputType>[]
          }
          count: {
            args: Prisma.buyersCountArgs<ExtArgs>
            result: $Utils.Optional<BuyersCountAggregateOutputType> | number
          }
        }
      }
      clinic_history: {
        payload: Prisma.$clinic_historyPayload<ExtArgs>
        fields: Prisma.clinic_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clinic_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clinic_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_historyPayload>
          }
          findFirst: {
            args: Prisma.clinic_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clinic_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_historyPayload>
          }
          findMany: {
            args: Prisma.clinic_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_historyPayload>[]
          }
          create: {
            args: Prisma.clinic_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_historyPayload>
          }
          createMany: {
            args: Prisma.clinic_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clinic_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_historyPayload>
          }
          update: {
            args: Prisma.clinic_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_historyPayload>
          }
          deleteMany: {
            args: Prisma.clinic_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clinic_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clinic_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_historyPayload>
          }
          aggregate: {
            args: Prisma.Clinic_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinic_history>
          }
          groupBy: {
            args: Prisma.clinic_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Clinic_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.clinic_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Clinic_historyCountAggregateOutputType> | number
          }
        }
      }
      countries: {
        payload: Prisma.$countriesPayload<ExtArgs>
        fields: Prisma.countriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.countriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.countriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          findFirst: {
            args: Prisma.countriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.countriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          findMany: {
            args: Prisma.countriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>[]
          }
          create: {
            args: Prisma.countriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          createMany: {
            args: Prisma.countriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.countriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          update: {
            args: Prisma.countriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          deleteMany: {
            args: Prisma.countriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.countriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.countriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          aggregate: {
            args: Prisma.CountriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountries>
          }
          groupBy: {
            args: Prisma.countriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.countriesCountArgs<ExtArgs>
            result: $Utils.Optional<CountriesCountAggregateOutputType> | number
          }
        }
      }
      enrolledactivity: {
        payload: Prisma.$enrolledactivityPayload<ExtArgs>
        fields: Prisma.enrolledactivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.enrolledactivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrolledactivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.enrolledactivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrolledactivityPayload>
          }
          findFirst: {
            args: Prisma.enrolledactivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrolledactivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.enrolledactivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrolledactivityPayload>
          }
          findMany: {
            args: Prisma.enrolledactivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrolledactivityPayload>[]
          }
          create: {
            args: Prisma.enrolledactivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrolledactivityPayload>
          }
          createMany: {
            args: Prisma.enrolledactivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.enrolledactivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrolledactivityPayload>
          }
          update: {
            args: Prisma.enrolledactivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrolledactivityPayload>
          }
          deleteMany: {
            args: Prisma.enrolledactivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.enrolledactivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.enrolledactivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrolledactivityPayload>
          }
          aggregate: {
            args: Prisma.EnrolledactivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrolledactivity>
          }
          groupBy: {
            args: Prisma.enrolledactivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrolledactivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.enrolledactivityCountArgs<ExtArgs>
            result: $Utils.Optional<EnrolledactivityCountAggregateOutputType> | number
          }
        }
      }
      inventory: {
        payload: Prisma.$inventoryPayload<ExtArgs>
        fields: Prisma.inventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          findFirst: {
            args: Prisma.inventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          findMany: {
            args: Prisma.inventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>[]
          }
          create: {
            args: Prisma.inventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          createMany: {
            args: Prisma.inventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.inventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          update: {
            args: Prisma.inventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          deleteMany: {
            args: Prisma.inventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.inventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.inventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.inventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      inventory__suppliers: {
        payload: Prisma.$inventory__suppliersPayload<ExtArgs>
        fields: Prisma.inventory__suppliersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inventory__suppliersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory__suppliersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inventory__suppliersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory__suppliersPayload>
          }
          findFirst: {
            args: Prisma.inventory__suppliersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory__suppliersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inventory__suppliersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory__suppliersPayload>
          }
          findMany: {
            args: Prisma.inventory__suppliersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory__suppliersPayload>[]
          }
          create: {
            args: Prisma.inventory__suppliersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory__suppliersPayload>
          }
          createMany: {
            args: Prisma.inventory__suppliersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.inventory__suppliersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory__suppliersPayload>
          }
          update: {
            args: Prisma.inventory__suppliersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory__suppliersPayload>
          }
          deleteMany: {
            args: Prisma.inventory__suppliersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inventory__suppliersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.inventory__suppliersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory__suppliersPayload>
          }
          aggregate: {
            args: Prisma.Inventory__suppliersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory__suppliers>
          }
          groupBy: {
            args: Prisma.inventory__suppliersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Inventory__suppliersGroupByOutputType>[]
          }
          count: {
            args: Prisma.inventory__suppliersCountArgs<ExtArgs>
            result: $Utils.Optional<Inventory__suppliersCountAggregateOutputType> | number
          }
        }
      }
      inventory_bookstore: {
        payload: Prisma.$inventory_bookstorePayload<ExtArgs>
        fields: Prisma.inventory_bookstoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inventory_bookstoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_bookstorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inventory_bookstoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_bookstorePayload>
          }
          findFirst: {
            args: Prisma.inventory_bookstoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_bookstorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inventory_bookstoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_bookstorePayload>
          }
          findMany: {
            args: Prisma.inventory_bookstoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_bookstorePayload>[]
          }
          create: {
            args: Prisma.inventory_bookstoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_bookstorePayload>
          }
          createMany: {
            args: Prisma.inventory_bookstoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.inventory_bookstoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_bookstorePayload>
          }
          update: {
            args: Prisma.inventory_bookstoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_bookstorePayload>
          }
          deleteMany: {
            args: Prisma.inventory_bookstoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inventory_bookstoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.inventory_bookstoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_bookstorePayload>
          }
          aggregate: {
            args: Prisma.Inventory_bookstoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory_bookstore>
          }
          groupBy: {
            args: Prisma.inventory_bookstoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<Inventory_bookstoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.inventory_bookstoreCountArgs<ExtArgs>
            result: $Utils.Optional<Inventory_bookstoreCountAggregateOutputType> | number
          }
        }
      }
      library_login: {
        payload: Prisma.$library_loginPayload<ExtArgs>
        fields: Prisma.library_loginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.library_loginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$library_loginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.library_loginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$library_loginPayload>
          }
          findFirst: {
            args: Prisma.library_loginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$library_loginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.library_loginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$library_loginPayload>
          }
          findMany: {
            args: Prisma.library_loginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$library_loginPayload>[]
          }
          create: {
            args: Prisma.library_loginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$library_loginPayload>
          }
          createMany: {
            args: Prisma.library_loginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.library_loginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$library_loginPayload>
          }
          update: {
            args: Prisma.library_loginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$library_loginPayload>
          }
          deleteMany: {
            args: Prisma.library_loginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.library_loginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.library_loginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$library_loginPayload>
          }
          aggregate: {
            args: Prisma.Library_loginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLibrary_login>
          }
          groupBy: {
            args: Prisma.library_loginGroupByArgs<ExtArgs>
            result: $Utils.Optional<Library_loginGroupByOutputType>[]
          }
          count: {
            args: Prisma.library_loginCountArgs<ExtArgs>
            result: $Utils.Optional<Library_loginCountAggregateOutputType> | number
          }
        }
      }
      logs_enroll: {
        payload: Prisma.$logs_enrollPayload<ExtArgs>
        fields: Prisma.logs_enrollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.logs_enrollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_enrollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.logs_enrollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_enrollPayload>
          }
          findFirst: {
            args: Prisma.logs_enrollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_enrollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.logs_enrollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_enrollPayload>
          }
          findMany: {
            args: Prisma.logs_enrollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_enrollPayload>[]
          }
          create: {
            args: Prisma.logs_enrollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_enrollPayload>
          }
          createMany: {
            args: Prisma.logs_enrollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.logs_enrollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_enrollPayload>
          }
          update: {
            args: Prisma.logs_enrollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_enrollPayload>
          }
          deleteMany: {
            args: Prisma.logs_enrollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.logs_enrollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.logs_enrollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_enrollPayload>
          }
          aggregate: {
            args: Prisma.Logs_enrollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogs_enroll>
          }
          groupBy: {
            args: Prisma.logs_enrollGroupByArgs<ExtArgs>
            result: $Utils.Optional<Logs_enrollGroupByOutputType>[]
          }
          count: {
            args: Prisma.logs_enrollCountArgs<ExtArgs>
            result: $Utils.Optional<Logs_enrollCountAggregateOutputType> | number
          }
        }
      }
      nationalities: {
        payload: Prisma.$nationalitiesPayload<ExtArgs>
        fields: Prisma.nationalitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.nationalitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nationalitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.nationalitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nationalitiesPayload>
          }
          findFirst: {
            args: Prisma.nationalitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nationalitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.nationalitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nationalitiesPayload>
          }
          findMany: {
            args: Prisma.nationalitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nationalitiesPayload>[]
          }
          create: {
            args: Prisma.nationalitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nationalitiesPayload>
          }
          createMany: {
            args: Prisma.nationalitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.nationalitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nationalitiesPayload>
          }
          update: {
            args: Prisma.nationalitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nationalitiesPayload>
          }
          deleteMany: {
            args: Prisma.nationalitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.nationalitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.nationalitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$nationalitiesPayload>
          }
          aggregate: {
            args: Prisma.NationalitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNationalities>
          }
          groupBy: {
            args: Prisma.nationalitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NationalitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.nationalitiesCountArgs<ExtArgs>
            result: $Utils.Optional<NationalitiesCountAggregateOutputType> | number
          }
        }
      }
      products: {
        payload: Prisma.$productsPayload<ExtArgs>
        fields: Prisma.productsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findFirst: {
            args: Prisma.productsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findMany: {
            args: Prisma.productsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          create: {
            args: Prisma.productsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          createMany: {
            args: Prisma.productsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.productsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          update: {
            args: Prisma.productsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          deleteMany: {
            args: Prisma.productsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.productsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.productsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.productsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      requests: {
        payload: Prisma.$requestsPayload<ExtArgs>
        fields: Prisma.requestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.requestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.requestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>
          }
          findFirst: {
            args: Prisma.requestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.requestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>
          }
          findMany: {
            args: Prisma.requestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>[]
          }
          create: {
            args: Prisma.requestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>
          }
          createMany: {
            args: Prisma.requestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.requestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>
          }
          update: {
            args: Prisma.requestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>
          }
          deleteMany: {
            args: Prisma.requestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.requestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.requestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requestsPayload>
          }
          aggregate: {
            args: Prisma.RequestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequests>
          }
          groupBy: {
            args: Prisma.requestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.requestsCountArgs<ExtArgs>
            result: $Utils.Optional<RequestsCountAggregateOutputType> | number
          }
        }
      }
      s_activities: {
        payload: Prisma.$s_activitiesPayload<ExtArgs>
        fields: Prisma.s_activitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.s_activitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_activitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.s_activitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_activitiesPayload>
          }
          findFirst: {
            args: Prisma.s_activitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_activitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.s_activitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_activitiesPayload>
          }
          findMany: {
            args: Prisma.s_activitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_activitiesPayload>[]
          }
          create: {
            args: Prisma.s_activitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_activitiesPayload>
          }
          createMany: {
            args: Prisma.s_activitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.s_activitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_activitiesPayload>
          }
          update: {
            args: Prisma.s_activitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_activitiesPayload>
          }
          deleteMany: {
            args: Prisma.s_activitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.s_activitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.s_activitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_activitiesPayload>
          }
          aggregate: {
            args: Prisma.S_activitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS_activities>
          }
          groupBy: {
            args: Prisma.s_activitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<S_activitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.s_activitiesCountArgs<ExtArgs>
            result: $Utils.Optional<S_activitiesCountAggregateOutputType> | number
          }
        }
      }
      s_classattendance: {
        payload: Prisma.$s_classattendancePayload<ExtArgs>
        fields: Prisma.s_classattendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.s_classattendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_classattendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.s_classattendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_classattendancePayload>
          }
          findFirst: {
            args: Prisma.s_classattendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_classattendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.s_classattendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_classattendancePayload>
          }
          findMany: {
            args: Prisma.s_classattendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_classattendancePayload>[]
          }
          create: {
            args: Prisma.s_classattendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_classattendancePayload>
          }
          createMany: {
            args: Prisma.s_classattendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.s_classattendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_classattendancePayload>
          }
          update: {
            args: Prisma.s_classattendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_classattendancePayload>
          }
          deleteMany: {
            args: Prisma.s_classattendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.s_classattendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.s_classattendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_classattendancePayload>
          }
          aggregate: {
            args: Prisma.S_classattendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS_classattendance>
          }
          groupBy: {
            args: Prisma.s_classattendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<S_classattendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.s_classattendanceCountArgs<ExtArgs>
            result: $Utils.Optional<S_classattendanceCountAggregateOutputType> | number
          }
        }
      }
      s_coretable: {
        payload: Prisma.$s_coretablePayload<ExtArgs>
        fields: Prisma.s_coretableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.s_coretableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_coretablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.s_coretableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_coretablePayload>
          }
          findFirst: {
            args: Prisma.s_coretableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_coretablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.s_coretableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_coretablePayload>
          }
          findMany: {
            args: Prisma.s_coretableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_coretablePayload>[]
          }
          create: {
            args: Prisma.s_coretableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_coretablePayload>
          }
          createMany: {
            args: Prisma.s_coretableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.s_coretableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_coretablePayload>
          }
          update: {
            args: Prisma.s_coretableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_coretablePayload>
          }
          deleteMany: {
            args: Prisma.s_coretableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.s_coretableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.s_coretableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_coretablePayload>
          }
          aggregate: {
            args: Prisma.S_coretableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS_coretable>
          }
          groupBy: {
            args: Prisma.s_coretableGroupByArgs<ExtArgs>
            result: $Utils.Optional<S_coretableGroupByOutputType>[]
          }
          count: {
            args: Prisma.s_coretableCountArgs<ExtArgs>
            result: $Utils.Optional<S_coretableCountAggregateOutputType> | number
          }
        }
      }
      s_corevalues: {
        payload: Prisma.$s_corevaluesPayload<ExtArgs>
        fields: Prisma.s_corevaluesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.s_corevaluesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_corevaluesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.s_corevaluesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_corevaluesPayload>
          }
          findFirst: {
            args: Prisma.s_corevaluesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_corevaluesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.s_corevaluesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_corevaluesPayload>
          }
          findMany: {
            args: Prisma.s_corevaluesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_corevaluesPayload>[]
          }
          create: {
            args: Prisma.s_corevaluesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_corevaluesPayload>
          }
          createMany: {
            args: Prisma.s_corevaluesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.s_corevaluesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_corevaluesPayload>
          }
          update: {
            args: Prisma.s_corevaluesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_corevaluesPayload>
          }
          deleteMany: {
            args: Prisma.s_corevaluesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.s_corevaluesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.s_corevaluesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_corevaluesPayload>
          }
          aggregate: {
            args: Prisma.S_corevaluesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS_corevalues>
          }
          groupBy: {
            args: Prisma.s_corevaluesGroupByArgs<ExtArgs>
            result: $Utils.Optional<S_corevaluesGroupByOutputType>[]
          }
          count: {
            args: Prisma.s_corevaluesCountArgs<ExtArgs>
            result: $Utils.Optional<S_corevaluesCountAggregateOutputType> | number
          }
        }
      }
      s_payables: {
        payload: Prisma.$s_payablesPayload<ExtArgs>
        fields: Prisma.s_payablesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.s_payablesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_payablesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.s_payablesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_payablesPayload>
          }
          findFirst: {
            args: Prisma.s_payablesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_payablesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.s_payablesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_payablesPayload>
          }
          findMany: {
            args: Prisma.s_payablesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_payablesPayload>[]
          }
          create: {
            args: Prisma.s_payablesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_payablesPayload>
          }
          createMany: {
            args: Prisma.s_payablesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.s_payablesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_payablesPayload>
          }
          update: {
            args: Prisma.s_payablesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_payablesPayload>
          }
          deleteMany: {
            args: Prisma.s_payablesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.s_payablesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.s_payablesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_payablesPayload>
          }
          aggregate: {
            args: Prisma.S_payablesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS_payables>
          }
          groupBy: {
            args: Prisma.s_payablesGroupByArgs<ExtArgs>
            result: $Utils.Optional<S_payablesGroupByOutputType>[]
          }
          count: {
            args: Prisma.s_payablesCountArgs<ExtArgs>
            result: $Utils.Optional<S_payablesCountAggregateOutputType> | number
          }
        }
      }
      s_recommendations: {
        payload: Prisma.$s_recommendationsPayload<ExtArgs>
        fields: Prisma.s_recommendationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.s_recommendationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_recommendationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.s_recommendationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_recommendationsPayload>
          }
          findFirst: {
            args: Prisma.s_recommendationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_recommendationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.s_recommendationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_recommendationsPayload>
          }
          findMany: {
            args: Prisma.s_recommendationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_recommendationsPayload>[]
          }
          create: {
            args: Prisma.s_recommendationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_recommendationsPayload>
          }
          createMany: {
            args: Prisma.s_recommendationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.s_recommendationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_recommendationsPayload>
          }
          update: {
            args: Prisma.s_recommendationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_recommendationsPayload>
          }
          deleteMany: {
            args: Prisma.s_recommendationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.s_recommendationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.s_recommendationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_recommendationsPayload>
          }
          aggregate: {
            args: Prisma.S_recommendationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS_recommendations>
          }
          groupBy: {
            args: Prisma.s_recommendationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<S_recommendationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.s_recommendationsCountArgs<ExtArgs>
            result: $Utils.Optional<S_recommendationsCountAggregateOutputType> | number
          }
        }
      }
      s_scores: {
        payload: Prisma.$s_scoresPayload<ExtArgs>
        fields: Prisma.s_scoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.s_scoresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_scoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.s_scoresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_scoresPayload>
          }
          findFirst: {
            args: Prisma.s_scoresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_scoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.s_scoresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_scoresPayload>
          }
          findMany: {
            args: Prisma.s_scoresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_scoresPayload>[]
          }
          create: {
            args: Prisma.s_scoresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_scoresPayload>
          }
          createMany: {
            args: Prisma.s_scoresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.s_scoresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_scoresPayload>
          }
          update: {
            args: Prisma.s_scoresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_scoresPayload>
          }
          deleteMany: {
            args: Prisma.s_scoresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.s_scoresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.s_scoresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_scoresPayload>
          }
          aggregate: {
            args: Prisma.S_scoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS_scores>
          }
          groupBy: {
            args: Prisma.s_scoresGroupByArgs<ExtArgs>
            result: $Utils.Optional<S_scoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.s_scoresCountArgs<ExtArgs>
            result: $Utils.Optional<S_scoresCountAggregateOutputType> | number
          }
        }
      }
      s_studentcv: {
        payload: Prisma.$s_studentcvPayload<ExtArgs>
        fields: Prisma.s_studentcvFieldRefs
        operations: {
          findUnique: {
            args: Prisma.s_studentcvFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_studentcvPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.s_studentcvFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_studentcvPayload>
          }
          findFirst: {
            args: Prisma.s_studentcvFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_studentcvPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.s_studentcvFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_studentcvPayload>
          }
          findMany: {
            args: Prisma.s_studentcvFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_studentcvPayload>[]
          }
          create: {
            args: Prisma.s_studentcvCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_studentcvPayload>
          }
          createMany: {
            args: Prisma.s_studentcvCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.s_studentcvDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_studentcvPayload>
          }
          update: {
            args: Prisma.s_studentcvUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_studentcvPayload>
          }
          deleteMany: {
            args: Prisma.s_studentcvDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.s_studentcvUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.s_studentcvUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_studentcvPayload>
          }
          aggregate: {
            args: Prisma.S_studentcvAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS_studentcv>
          }
          groupBy: {
            args: Prisma.s_studentcvGroupByArgs<ExtArgs>
            result: $Utils.Optional<S_studentcvGroupByOutputType>[]
          }
          count: {
            args: Prisma.s_studentcvCountArgs<ExtArgs>
            result: $Utils.Optional<S_studentcvCountAggregateOutputType> | number
          }
        }
      }
      s_subjects: {
        payload: Prisma.$s_subjectsPayload<ExtArgs>
        fields: Prisma.s_subjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.s_subjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_subjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.s_subjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_subjectsPayload>
          }
          findFirst: {
            args: Prisma.s_subjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_subjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.s_subjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_subjectsPayload>
          }
          findMany: {
            args: Prisma.s_subjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_subjectsPayload>[]
          }
          create: {
            args: Prisma.s_subjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_subjectsPayload>
          }
          createMany: {
            args: Prisma.s_subjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.s_subjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_subjectsPayload>
          }
          update: {
            args: Prisma.s_subjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_subjectsPayload>
          }
          deleteMany: {
            args: Prisma.s_subjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.s_subjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.s_subjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_subjectsPayload>
          }
          aggregate: {
            args: Prisma.S_subjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS_subjects>
          }
          groupBy: {
            args: Prisma.s_subjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<S_subjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.s_subjectsCountArgs<ExtArgs>
            result: $Utils.Optional<S_subjectsCountAggregateOutputType> | number
          }
        }
      }
      s_transmute: {
        payload: Prisma.$s_transmutePayload<ExtArgs>
        fields: Prisma.s_transmuteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.s_transmuteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_transmutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.s_transmuteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_transmutePayload>
          }
          findFirst: {
            args: Prisma.s_transmuteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_transmutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.s_transmuteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_transmutePayload>
          }
          findMany: {
            args: Prisma.s_transmuteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_transmutePayload>[]
          }
          create: {
            args: Prisma.s_transmuteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_transmutePayload>
          }
          createMany: {
            args: Prisma.s_transmuteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.s_transmuteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_transmutePayload>
          }
          update: {
            args: Prisma.s_transmuteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_transmutePayload>
          }
          deleteMany: {
            args: Prisma.s_transmuteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.s_transmuteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.s_transmuteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_transmutePayload>
          }
          aggregate: {
            args: Prisma.S_transmuteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS_transmute>
          }
          groupBy: {
            args: Prisma.s_transmuteGroupByArgs<ExtArgs>
            result: $Utils.Optional<S_transmuteGroupByOutputType>[]
          }
          count: {
            args: Prisma.s_transmuteCountArgs<ExtArgs>
            result: $Utils.Optional<S_transmuteCountAggregateOutputType> | number
          }
        }
      }
      s_verifications: {
        payload: Prisma.$s_verificationsPayload<ExtArgs>
        fields: Prisma.s_verificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.s_verificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_verificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.s_verificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_verificationsPayload>
          }
          findFirst: {
            args: Prisma.s_verificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_verificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.s_verificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_verificationsPayload>
          }
          findMany: {
            args: Prisma.s_verificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_verificationsPayload>[]
          }
          create: {
            args: Prisma.s_verificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_verificationsPayload>
          }
          createMany: {
            args: Prisma.s_verificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.s_verificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_verificationsPayload>
          }
          update: {
            args: Prisma.s_verificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_verificationsPayload>
          }
          deleteMany: {
            args: Prisma.s_verificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.s_verificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.s_verificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$s_verificationsPayload>
          }
          aggregate: {
            args: Prisma.S_verificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS_verifications>
          }
          groupBy: {
            args: Prisma.s_verificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<S_verificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.s_verificationsCountArgs<ExtArgs>
            result: $Utils.Optional<S_verificationsCountAggregateOutputType> | number
          }
        }
      }
      sales_history: {
        payload: Prisma.$sales_historyPayload<ExtArgs>
        fields: Prisma.sales_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sales_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sales_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>
          }
          findFirst: {
            args: Prisma.sales_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sales_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>
          }
          findMany: {
            args: Prisma.sales_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>[]
          }
          create: {
            args: Prisma.sales_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>
          }
          createMany: {
            args: Prisma.sales_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sales_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>
          }
          update: {
            args: Prisma.sales_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>
          }
          deleteMany: {
            args: Prisma.sales_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sales_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sales_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sales_historyPayload>
          }
          aggregate: {
            args: Prisma.Sales_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSales_history>
          }
          groupBy: {
            args: Prisma.sales_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sales_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.sales_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Sales_historyCountAggregateOutputType> | number
          }
        }
      }
      schedule: {
        payload: Prisma.$schedulePayload<ExtArgs>
        fields: Prisma.scheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.scheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.scheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schedulePayload>
          }
          findFirst: {
            args: Prisma.scheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.scheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schedulePayload>
          }
          findMany: {
            args: Prisma.scheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schedulePayload>[]
          }
          create: {
            args: Prisma.scheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schedulePayload>
          }
          createMany: {
            args: Prisma.scheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.scheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schedulePayload>
          }
          update: {
            args: Prisma.scheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schedulePayload>
          }
          deleteMany: {
            args: Prisma.scheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.scheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.scheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.scheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.scheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      studentdetails: {
        payload: Prisma.$studentdetailsPayload<ExtArgs>
        fields: Prisma.studentdetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentdetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentdetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentdetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentdetailsPayload>
          }
          findFirst: {
            args: Prisma.studentdetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentdetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentdetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentdetailsPayload>
          }
          findMany: {
            args: Prisma.studentdetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentdetailsPayload>[]
          }
          create: {
            args: Prisma.studentdetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentdetailsPayload>
          }
          createMany: {
            args: Prisma.studentdetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.studentdetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentdetailsPayload>
          }
          update: {
            args: Prisma.studentdetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentdetailsPayload>
          }
          deleteMany: {
            args: Prisma.studentdetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentdetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.studentdetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentdetailsPayload>
          }
          aggregate: {
            args: Prisma.StudentdetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentdetails>
          }
          groupBy: {
            args: Prisma.studentdetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentdetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentdetailsCountArgs<ExtArgs>
            result: $Utils.Optional<StudentdetailsCountAggregateOutputType> | number
          }
        }
      }
      timeoff: {
        payload: Prisma.$timeoffPayload<ExtArgs>
        fields: Prisma.timeoffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.timeoffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeoffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.timeoffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeoffPayload>
          }
          findFirst: {
            args: Prisma.timeoffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeoffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.timeoffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeoffPayload>
          }
          findMany: {
            args: Prisma.timeoffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeoffPayload>[]
          }
          create: {
            args: Prisma.timeoffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeoffPayload>
          }
          createMany: {
            args: Prisma.timeoffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.timeoffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeoffPayload>
          }
          update: {
            args: Prisma.timeoffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeoffPayload>
          }
          deleteMany: {
            args: Prisma.timeoffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.timeoffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.timeoffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeoffPayload>
          }
          aggregate: {
            args: Prisma.TimeoffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeoff>
          }
          groupBy: {
            args: Prisma.timeoffGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeoffGroupByOutputType>[]
          }
          count: {
            args: Prisma.timeoffCountArgs<ExtArgs>
            result: $Utils.Optional<TimeoffCountAggregateOutputType> | number
          }
        }
      }
      type_of_products: {
        payload: Prisma.$type_of_productsPayload<ExtArgs>
        fields: Prisma.type_of_productsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.type_of_productsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_productsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.type_of_productsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_productsPayload>
          }
          findFirst: {
            args: Prisma.type_of_productsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_productsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.type_of_productsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_productsPayload>
          }
          findMany: {
            args: Prisma.type_of_productsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_productsPayload>[]
          }
          create: {
            args: Prisma.type_of_productsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_productsPayload>
          }
          createMany: {
            args: Prisma.type_of_productsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.type_of_productsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_productsPayload>
          }
          update: {
            args: Prisma.type_of_productsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_productsPayload>
          }
          deleteMany: {
            args: Prisma.type_of_productsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.type_of_productsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.type_of_productsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_productsPayload>
          }
          aggregate: {
            args: Prisma.Type_of_productsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateType_of_products>
          }
          groupBy: {
            args: Prisma.type_of_productsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Type_of_productsGroupByOutputType>[]
          }
          count: {
            args: Prisma.type_of_productsCountArgs<ExtArgs>
            result: $Utils.Optional<Type_of_productsCountAggregateOutputType> | number
          }
        }
      }
      uniform: {
        payload: Prisma.$uniformPayload<ExtArgs>
        fields: Prisma.uniformFieldRefs
        operations: {
          findUnique: {
            args: Prisma.uniformFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniformPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.uniformFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniformPayload>
          }
          findFirst: {
            args: Prisma.uniformFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniformPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.uniformFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniformPayload>
          }
          findMany: {
            args: Prisma.uniformFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniformPayload>[]
          }
          create: {
            args: Prisma.uniformCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniformPayload>
          }
          createMany: {
            args: Prisma.uniformCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.uniformDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniformPayload>
          }
          update: {
            args: Prisma.uniformUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniformPayload>
          }
          deleteMany: {
            args: Prisma.uniformDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.uniformUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.uniformUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniformPayload>
          }
          aggregate: {
            args: Prisma.UniformAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUniform>
          }
          groupBy: {
            args: Prisma.uniformGroupByArgs<ExtArgs>
            result: $Utils.Optional<UniformGroupByOutputType>[]
          }
          count: {
            args: Prisma.uniformCountArgs<ExtArgs>
            result: $Utils.Optional<UniformCountAggregateOutputType> | number
          }
        }
      }
      uniform_inventory: {
        payload: Prisma.$uniform_inventoryPayload<ExtArgs>
        fields: Prisma.uniform_inventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.uniform_inventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_inventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.uniform_inventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_inventoryPayload>
          }
          findFirst: {
            args: Prisma.uniform_inventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_inventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.uniform_inventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_inventoryPayload>
          }
          findMany: {
            args: Prisma.uniform_inventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_inventoryPayload>[]
          }
          create: {
            args: Prisma.uniform_inventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_inventoryPayload>
          }
          createMany: {
            args: Prisma.uniform_inventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.uniform_inventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_inventoryPayload>
          }
          update: {
            args: Prisma.uniform_inventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_inventoryPayload>
          }
          deleteMany: {
            args: Prisma.uniform_inventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.uniform_inventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.uniform_inventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_inventoryPayload>
          }
          aggregate: {
            args: Prisma.Uniform_inventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUniform_inventory>
          }
          groupBy: {
            args: Prisma.uniform_inventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Uniform_inventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.uniform_inventoryCountArgs<ExtArgs>
            result: $Utils.Optional<Uniform_inventoryCountAggregateOutputType> | number
          }
        }
      }
      uniform_issued: {
        payload: Prisma.$uniform_issuedPayload<ExtArgs>
        fields: Prisma.uniform_issuedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.uniform_issuedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_issuedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.uniform_issuedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_issuedPayload>
          }
          findFirst: {
            args: Prisma.uniform_issuedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_issuedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.uniform_issuedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_issuedPayload>
          }
          findMany: {
            args: Prisma.uniform_issuedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_issuedPayload>[]
          }
          create: {
            args: Prisma.uniform_issuedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_issuedPayload>
          }
          createMany: {
            args: Prisma.uniform_issuedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.uniform_issuedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_issuedPayload>
          }
          update: {
            args: Prisma.uniform_issuedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_issuedPayload>
          }
          deleteMany: {
            args: Prisma.uniform_issuedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.uniform_issuedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.uniform_issuedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_issuedPayload>
          }
          aggregate: {
            args: Prisma.Uniform_issuedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUniform_issued>
          }
          groupBy: {
            args: Prisma.uniform_issuedGroupByArgs<ExtArgs>
            result: $Utils.Optional<Uniform_issuedGroupByOutputType>[]
          }
          count: {
            args: Prisma.uniform_issuedCountArgs<ExtArgs>
            result: $Utils.Optional<Uniform_issuedCountAggregateOutputType> | number
          }
        }
      }
      uniform_sizes: {
        payload: Prisma.$uniform_sizesPayload<ExtArgs>
        fields: Prisma.uniform_sizesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.uniform_sizesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_sizesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.uniform_sizesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_sizesPayload>
          }
          findFirst: {
            args: Prisma.uniform_sizesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_sizesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.uniform_sizesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_sizesPayload>
          }
          findMany: {
            args: Prisma.uniform_sizesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_sizesPayload>[]
          }
          create: {
            args: Prisma.uniform_sizesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_sizesPayload>
          }
          createMany: {
            args: Prisma.uniform_sizesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.uniform_sizesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_sizesPayload>
          }
          update: {
            args: Prisma.uniform_sizesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_sizesPayload>
          }
          deleteMany: {
            args: Prisma.uniform_sizesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.uniform_sizesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.uniform_sizesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_sizesPayload>
          }
          aggregate: {
            args: Prisma.Uniform_sizesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUniform_sizes>
          }
          groupBy: {
            args: Prisma.uniform_sizesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Uniform_sizesGroupByOutputType>[]
          }
          count: {
            args: Prisma.uniform_sizesCountArgs<ExtArgs>
            result: $Utils.Optional<Uniform_sizesCountAggregateOutputType> | number
          }
        }
      }
      uniform_types: {
        payload: Prisma.$uniform_typesPayload<ExtArgs>
        fields: Prisma.uniform_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.uniform_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.uniform_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_typesPayload>
          }
          findFirst: {
            args: Prisma.uniform_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.uniform_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_typesPayload>
          }
          findMany: {
            args: Prisma.uniform_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_typesPayload>[]
          }
          create: {
            args: Prisma.uniform_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_typesPayload>
          }
          createMany: {
            args: Prisma.uniform_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.uniform_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_typesPayload>
          }
          update: {
            args: Prisma.uniform_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_typesPayload>
          }
          deleteMany: {
            args: Prisma.uniform_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.uniform_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.uniform_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$uniform_typesPayload>
          }
          aggregate: {
            args: Prisma.Uniform_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUniform_types>
          }
          groupBy: {
            args: Prisma.uniform_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Uniform_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.uniform_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Uniform_typesCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      user22: {
        payload: Prisma.$user22Payload<ExtArgs>
        fields: Prisma.user22FieldRefs
        operations: {
          findUnique: {
            args: Prisma.user22FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user22Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user22FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user22Payload>
          }
          findFirst: {
            args: Prisma.user22FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user22Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user22FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user22Payload>
          }
          findMany: {
            args: Prisma.user22FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user22Payload>[]
          }
          create: {
            args: Prisma.user22CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user22Payload>
          }
          createMany: {
            args: Prisma.user22CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.user22DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user22Payload>
          }
          update: {
            args: Prisma.user22UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user22Payload>
          }
          deleteMany: {
            args: Prisma.user22DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user22UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user22UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user22Payload>
          }
          aggregate: {
            args: Prisma.User22AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser22>
          }
          groupBy: {
            args: Prisma.user22GroupByArgs<ExtArgs>
            result: $Utils.Optional<User22GroupByOutputType>[]
          }
          count: {
            args: Prisma.user22CountArgs<ExtArgs>
            result: $Utils.Optional<User22CountAggregateOutputType> | number
          }
        }
      }
      users24: {
        payload: Prisma.$users24Payload<ExtArgs>
        fields: Prisma.users24FieldRefs
        operations: {
          findUnique: {
            args: Prisma.users24FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users24Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.users24FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users24Payload>
          }
          findFirst: {
            args: Prisma.users24FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users24Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.users24FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users24Payload>
          }
          findMany: {
            args: Prisma.users24FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users24Payload>[]
          }
          create: {
            args: Prisma.users24CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users24Payload>
          }
          createMany: {
            args: Prisma.users24CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.users24DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users24Payload>
          }
          update: {
            args: Prisma.users24UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users24Payload>
          }
          deleteMany: {
            args: Prisma.users24DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.users24UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.users24UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users24Payload>
          }
          aggregate: {
            args: Prisma.Users24AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers24>
          }
          groupBy: {
            args: Prisma.users24GroupByArgs<ExtArgs>
            result: $Utils.Optional<Users24GroupByOutputType>[]
          }
          count: {
            args: Prisma.users24CountArgs<ExtArgs>
            result: $Utils.Optional<Users24CountAggregateOutputType> | number
          }
        }
      }
      visitorlog: {
        payload: Prisma.$visitorlogPayload<ExtArgs>
        fields: Prisma.visitorlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.visitorlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visitorlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.visitorlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visitorlogPayload>
          }
          findFirst: {
            args: Prisma.visitorlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visitorlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.visitorlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visitorlogPayload>
          }
          findMany: {
            args: Prisma.visitorlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visitorlogPayload>[]
          }
          create: {
            args: Prisma.visitorlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visitorlogPayload>
          }
          createMany: {
            args: Prisma.visitorlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.visitorlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visitorlogPayload>
          }
          update: {
            args: Prisma.visitorlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visitorlogPayload>
          }
          deleteMany: {
            args: Prisma.visitorlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.visitorlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.visitorlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$visitorlogPayload>
          }
          aggregate: {
            args: Prisma.VisitorlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitorlog>
          }
          groupBy: {
            args: Prisma.visitorlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitorlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.visitorlogCountArgs<ExtArgs>
            result: $Utils.Optional<VisitorlogCountAggregateOutputType> | number
          }
        }
      }
      wispay: {
        payload: Prisma.$wispayPayload<ExtArgs>
        fields: Prisma.wispayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wispayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wispayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wispayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wispayPayload>
          }
          findFirst: {
            args: Prisma.wispayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wispayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wispayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wispayPayload>
          }
          findMany: {
            args: Prisma.wispayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wispayPayload>[]
          }
          create: {
            args: Prisma.wispayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wispayPayload>
          }
          createMany: {
            args: Prisma.wispayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.wispayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wispayPayload>
          }
          update: {
            args: Prisma.wispayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wispayPayload>
          }
          deleteMany: {
            args: Prisma.wispayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wispayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.wispayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wispayPayload>
          }
          aggregate: {
            args: Prisma.WispayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWispay>
          }
          groupBy: {
            args: Prisma.wispayGroupByArgs<ExtArgs>
            result: $Utils.Optional<WispayGroupByOutputType>[]
          }
          count: {
            args: Prisma.wispayCountArgs<ExtArgs>
            result: $Utils.Optional<WispayCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    activitysession?: activitysessionOmit
    afterschoolactivity?: afterschoolactivityOmit
    attendance?: attendanceOmit
    attendance_library?: attendance_libraryOmit
    borrowers?: borrowersOmit
    buyers?: buyersOmit
    clinic_history?: clinic_historyOmit
    countries?: countriesOmit
    enrolledactivity?: enrolledactivityOmit
    inventory?: inventoryOmit
    inventory__suppliers?: inventory__suppliersOmit
    inventory_bookstore?: inventory_bookstoreOmit
    library_login?: library_loginOmit
    logs_enroll?: logs_enrollOmit
    nationalities?: nationalitiesOmit
    products?: productsOmit
    requests?: requestsOmit
    s_activities?: s_activitiesOmit
    s_classattendance?: s_classattendanceOmit
    s_coretable?: s_coretableOmit
    s_corevalues?: s_corevaluesOmit
    s_payables?: s_payablesOmit
    s_recommendations?: s_recommendationsOmit
    s_scores?: s_scoresOmit
    s_studentcv?: s_studentcvOmit
    s_subjects?: s_subjectsOmit
    s_transmute?: s_transmuteOmit
    s_verifications?: s_verificationsOmit
    sales_history?: sales_historyOmit
    schedule?: scheduleOmit
    studentdetails?: studentdetailsOmit
    timeoff?: timeoffOmit
    type_of_products?: type_of_productsOmit
    uniform?: uniformOmit
    uniform_inventory?: uniform_inventoryOmit
    uniform_issued?: uniform_issuedOmit
    uniform_sizes?: uniform_sizesOmit
    uniform_types?: uniform_typesOmit
    user?: userOmit
    user22?: user22Omit
    users24?: users24Omit
    visitorlog?: visitorlogOmit
    wispay?: wispayOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ActivitysessionCountOutputType
   */

  export type ActivitysessionCountOutputType = {
    attendance: number
  }

  export type ActivitysessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | ActivitysessionCountOutputTypeCountAttendanceArgs
  }

  // Custom InputTypes
  /**
   * ActivitysessionCountOutputType without action
   */
  export type ActivitysessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivitysessionCountOutputType
     */
    select?: ActivitysessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivitysessionCountOutputType without action
   */
  export type ActivitysessionCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendanceWhereInput
  }


  /**
   * Count Type AfterschoolactivityCountOutputType
   */

  export type AfterschoolactivityCountOutputType = {
    activitysession: number
    enrolledactivity: number
  }

  export type AfterschoolactivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activitysession?: boolean | AfterschoolactivityCountOutputTypeCountActivitysessionArgs
    enrolledactivity?: boolean | AfterschoolactivityCountOutputTypeCountEnrolledactivityArgs
  }

  // Custom InputTypes
  /**
   * AfterschoolactivityCountOutputType without action
   */
  export type AfterschoolactivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterschoolactivityCountOutputType
     */
    select?: AfterschoolactivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AfterschoolactivityCountOutputType without action
   */
  export type AfterschoolactivityCountOutputTypeCountActivitysessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activitysessionWhereInput
  }

  /**
   * AfterschoolactivityCountOutputType without action
   */
  export type AfterschoolactivityCountOutputTypeCountEnrolledactivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrolledactivityWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    attendance: number
    enrolledactivity: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | UserCountOutputTypeCountAttendanceArgs
    enrolledactivity?: boolean | UserCountOutputTypeCountEnrolledactivityArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrolledactivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrolledactivityWhereInput
  }


  /**
   * Models
   */

  /**
   * Model activitysession
   */

  export type AggregateActivitysession = {
    _count: ActivitysessionCountAggregateOutputType | null
    _avg: ActivitysessionAvgAggregateOutputType | null
    _sum: ActivitysessionSumAggregateOutputType | null
    _min: ActivitysessionMinAggregateOutputType | null
    _max: ActivitysessionMaxAggregateOutputType | null
  }

  export type ActivitysessionAvgAggregateOutputType = {
    id: number | null
    activityId: number | null
  }

  export type ActivitysessionSumAggregateOutputType = {
    id: number | null
    activityId: number | null
  }

  export type ActivitysessionMinAggregateOutputType = {
    id: number | null
    activityId: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivitysessionMaxAggregateOutputType = {
    id: number | null
    activityId: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivitysessionCountAggregateOutputType = {
    id: number
    activityId: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivitysessionAvgAggregateInputType = {
    id?: true
    activityId?: true
  }

  export type ActivitysessionSumAggregateInputType = {
    id?: true
    activityId?: true
  }

  export type ActivitysessionMinAggregateInputType = {
    id?: true
    activityId?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivitysessionMaxAggregateInputType = {
    id?: true
    activityId?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivitysessionCountAggregateInputType = {
    id?: true
    activityId?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivitysessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activitysession to aggregate.
     */
    where?: activitysessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activitysessions to fetch.
     */
    orderBy?: activitysessionOrderByWithRelationInput | activitysessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activitysessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activitysessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activitysessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activitysessions
    **/
    _count?: true | ActivitysessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivitysessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitysessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivitysessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivitysessionMaxAggregateInputType
  }

  export type GetActivitysessionAggregateType<T extends ActivitysessionAggregateArgs> = {
        [P in keyof T & keyof AggregateActivitysession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivitysession[P]>
      : GetScalarType<T[P], AggregateActivitysession[P]>
  }




  export type activitysessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activitysessionWhereInput
    orderBy?: activitysessionOrderByWithAggregationInput | activitysessionOrderByWithAggregationInput[]
    by: ActivitysessionScalarFieldEnum[] | ActivitysessionScalarFieldEnum
    having?: activitysessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivitysessionCountAggregateInputType | true
    _avg?: ActivitysessionAvgAggregateInputType
    _sum?: ActivitysessionSumAggregateInputType
    _min?: ActivitysessionMinAggregateInputType
    _max?: ActivitysessionMaxAggregateInputType
  }

  export type ActivitysessionGroupByOutputType = {
    id: number
    activityId: number
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: ActivitysessionCountAggregateOutputType | null
    _avg: ActivitysessionAvgAggregateOutputType | null
    _sum: ActivitysessionSumAggregateOutputType | null
    _min: ActivitysessionMinAggregateOutputType | null
    _max: ActivitysessionMaxAggregateOutputType | null
  }

  type GetActivitysessionGroupByPayload<T extends activitysessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivitysessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivitysessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivitysessionGroupByOutputType[P]>
            : GetScalarType<T[P], ActivitysessionGroupByOutputType[P]>
        }
      >
    >


  export type activitysessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    afterschoolactivity?: boolean | afterschoolactivityDefaultArgs<ExtArgs>
    attendance?: boolean | activitysession$attendanceArgs<ExtArgs>
    _count?: boolean | ActivitysessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activitysession"]>



  export type activitysessionSelectScalar = {
    id?: boolean
    activityId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type activitysessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "activityId" | "date" | "createdAt" | "updatedAt", ExtArgs["result"]["activitysession"]>
  export type activitysessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    afterschoolactivity?: boolean | afterschoolactivityDefaultArgs<ExtArgs>
    attendance?: boolean | activitysession$attendanceArgs<ExtArgs>
    _count?: boolean | ActivitysessionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $activitysessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "activitysession"
    objects: {
      afterschoolactivity: Prisma.$afterschoolactivityPayload<ExtArgs>
      attendance: Prisma.$attendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      activityId: number
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["activitysession"]>
    composites: {}
  }

  type activitysessionGetPayload<S extends boolean | null | undefined | activitysessionDefaultArgs> = $Result.GetResult<Prisma.$activitysessionPayload, S>

  type activitysessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<activitysessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivitysessionCountAggregateInputType | true
    }

  export interface activitysessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['activitysession'], meta: { name: 'activitysession' } }
    /**
     * Find zero or one Activitysession that matches the filter.
     * @param {activitysessionFindUniqueArgs} args - Arguments to find a Activitysession
     * @example
     * // Get one Activitysession
     * const activitysession = await prisma.activitysession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends activitysessionFindUniqueArgs>(args: SelectSubset<T, activitysessionFindUniqueArgs<ExtArgs>>): Prisma__activitysessionClient<$Result.GetResult<Prisma.$activitysessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activitysession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {activitysessionFindUniqueOrThrowArgs} args - Arguments to find a Activitysession
     * @example
     * // Get one Activitysession
     * const activitysession = await prisma.activitysession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends activitysessionFindUniqueOrThrowArgs>(args: SelectSubset<T, activitysessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__activitysessionClient<$Result.GetResult<Prisma.$activitysessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activitysession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitysessionFindFirstArgs} args - Arguments to find a Activitysession
     * @example
     * // Get one Activitysession
     * const activitysession = await prisma.activitysession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends activitysessionFindFirstArgs>(args?: SelectSubset<T, activitysessionFindFirstArgs<ExtArgs>>): Prisma__activitysessionClient<$Result.GetResult<Prisma.$activitysessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activitysession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitysessionFindFirstOrThrowArgs} args - Arguments to find a Activitysession
     * @example
     * // Get one Activitysession
     * const activitysession = await prisma.activitysession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends activitysessionFindFirstOrThrowArgs>(args?: SelectSubset<T, activitysessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__activitysessionClient<$Result.GetResult<Prisma.$activitysessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activitysessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitysessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activitysessions
     * const activitysessions = await prisma.activitysession.findMany()
     * 
     * // Get first 10 Activitysessions
     * const activitysessions = await prisma.activitysession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activitysessionWithIdOnly = await prisma.activitysession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends activitysessionFindManyArgs>(args?: SelectSubset<T, activitysessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitysessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activitysession.
     * @param {activitysessionCreateArgs} args - Arguments to create a Activitysession.
     * @example
     * // Create one Activitysession
     * const Activitysession = await prisma.activitysession.create({
     *   data: {
     *     // ... data to create a Activitysession
     *   }
     * })
     * 
     */
    create<T extends activitysessionCreateArgs>(args: SelectSubset<T, activitysessionCreateArgs<ExtArgs>>): Prisma__activitysessionClient<$Result.GetResult<Prisma.$activitysessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activitysessions.
     * @param {activitysessionCreateManyArgs} args - Arguments to create many Activitysessions.
     * @example
     * // Create many Activitysessions
     * const activitysession = await prisma.activitysession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends activitysessionCreateManyArgs>(args?: SelectSubset<T, activitysessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Activitysession.
     * @param {activitysessionDeleteArgs} args - Arguments to delete one Activitysession.
     * @example
     * // Delete one Activitysession
     * const Activitysession = await prisma.activitysession.delete({
     *   where: {
     *     // ... filter to delete one Activitysession
     *   }
     * })
     * 
     */
    delete<T extends activitysessionDeleteArgs>(args: SelectSubset<T, activitysessionDeleteArgs<ExtArgs>>): Prisma__activitysessionClient<$Result.GetResult<Prisma.$activitysessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activitysession.
     * @param {activitysessionUpdateArgs} args - Arguments to update one Activitysession.
     * @example
     * // Update one Activitysession
     * const activitysession = await prisma.activitysession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends activitysessionUpdateArgs>(args: SelectSubset<T, activitysessionUpdateArgs<ExtArgs>>): Prisma__activitysessionClient<$Result.GetResult<Prisma.$activitysessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activitysessions.
     * @param {activitysessionDeleteManyArgs} args - Arguments to filter Activitysessions to delete.
     * @example
     * // Delete a few Activitysessions
     * const { count } = await prisma.activitysession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends activitysessionDeleteManyArgs>(args?: SelectSubset<T, activitysessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activitysessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitysessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activitysessions
     * const activitysession = await prisma.activitysession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends activitysessionUpdateManyArgs>(args: SelectSubset<T, activitysessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activitysession.
     * @param {activitysessionUpsertArgs} args - Arguments to update or create a Activitysession.
     * @example
     * // Update or create a Activitysession
     * const activitysession = await prisma.activitysession.upsert({
     *   create: {
     *     // ... data to create a Activitysession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activitysession we want to update
     *   }
     * })
     */
    upsert<T extends activitysessionUpsertArgs>(args: SelectSubset<T, activitysessionUpsertArgs<ExtArgs>>): Prisma__activitysessionClient<$Result.GetResult<Prisma.$activitysessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activitysessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitysessionCountArgs} args - Arguments to filter Activitysessions to count.
     * @example
     * // Count the number of Activitysessions
     * const count = await prisma.activitysession.count({
     *   where: {
     *     // ... the filter for the Activitysessions we want to count
     *   }
     * })
    **/
    count<T extends activitysessionCountArgs>(
      args?: Subset<T, activitysessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivitysessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activitysession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitysessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivitysessionAggregateArgs>(args: Subset<T, ActivitysessionAggregateArgs>): Prisma.PrismaPromise<GetActivitysessionAggregateType<T>>

    /**
     * Group by Activitysession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitysessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends activitysessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: activitysessionGroupByArgs['orderBy'] }
        : { orderBy?: activitysessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, activitysessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivitysessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the activitysession model
   */
  readonly fields: activitysessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for activitysession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__activitysessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    afterschoolactivity<T extends afterschoolactivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, afterschoolactivityDefaultArgs<ExtArgs>>): Prisma__afterschoolactivityClient<$Result.GetResult<Prisma.$afterschoolactivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendance<T extends activitysession$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, activitysession$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the activitysession model
   */
  interface activitysessionFieldRefs {
    readonly id: FieldRef<"activitysession", 'Int'>
    readonly activityId: FieldRef<"activitysession", 'Int'>
    readonly date: FieldRef<"activitysession", 'DateTime'>
    readonly createdAt: FieldRef<"activitysession", 'DateTime'>
    readonly updatedAt: FieldRef<"activitysession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * activitysession findUnique
   */
  export type activitysessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitysession
     */
    select?: activitysessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitysession
     */
    omit?: activitysessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitysessionInclude<ExtArgs> | null
    /**
     * Filter, which activitysession to fetch.
     */
    where: activitysessionWhereUniqueInput
  }

  /**
   * activitysession findUniqueOrThrow
   */
  export type activitysessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitysession
     */
    select?: activitysessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitysession
     */
    omit?: activitysessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitysessionInclude<ExtArgs> | null
    /**
     * Filter, which activitysession to fetch.
     */
    where: activitysessionWhereUniqueInput
  }

  /**
   * activitysession findFirst
   */
  export type activitysessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitysession
     */
    select?: activitysessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitysession
     */
    omit?: activitysessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitysessionInclude<ExtArgs> | null
    /**
     * Filter, which activitysession to fetch.
     */
    where?: activitysessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activitysessions to fetch.
     */
    orderBy?: activitysessionOrderByWithRelationInput | activitysessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activitysessions.
     */
    cursor?: activitysessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activitysessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activitysessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activitysessions.
     */
    distinct?: ActivitysessionScalarFieldEnum | ActivitysessionScalarFieldEnum[]
  }

  /**
   * activitysession findFirstOrThrow
   */
  export type activitysessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitysession
     */
    select?: activitysessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitysession
     */
    omit?: activitysessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitysessionInclude<ExtArgs> | null
    /**
     * Filter, which activitysession to fetch.
     */
    where?: activitysessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activitysessions to fetch.
     */
    orderBy?: activitysessionOrderByWithRelationInput | activitysessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activitysessions.
     */
    cursor?: activitysessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activitysessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activitysessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activitysessions.
     */
    distinct?: ActivitysessionScalarFieldEnum | ActivitysessionScalarFieldEnum[]
  }

  /**
   * activitysession findMany
   */
  export type activitysessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitysession
     */
    select?: activitysessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitysession
     */
    omit?: activitysessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitysessionInclude<ExtArgs> | null
    /**
     * Filter, which activitysessions to fetch.
     */
    where?: activitysessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activitysessions to fetch.
     */
    orderBy?: activitysessionOrderByWithRelationInput | activitysessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activitysessions.
     */
    cursor?: activitysessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activitysessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activitysessions.
     */
    skip?: number
    distinct?: ActivitysessionScalarFieldEnum | ActivitysessionScalarFieldEnum[]
  }

  /**
   * activitysession create
   */
  export type activitysessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitysession
     */
    select?: activitysessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitysession
     */
    omit?: activitysessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitysessionInclude<ExtArgs> | null
    /**
     * The data needed to create a activitysession.
     */
    data: XOR<activitysessionCreateInput, activitysessionUncheckedCreateInput>
  }

  /**
   * activitysession createMany
   */
  export type activitysessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many activitysessions.
     */
    data: activitysessionCreateManyInput | activitysessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * activitysession update
   */
  export type activitysessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitysession
     */
    select?: activitysessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitysession
     */
    omit?: activitysessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitysessionInclude<ExtArgs> | null
    /**
     * The data needed to update a activitysession.
     */
    data: XOR<activitysessionUpdateInput, activitysessionUncheckedUpdateInput>
    /**
     * Choose, which activitysession to update.
     */
    where: activitysessionWhereUniqueInput
  }

  /**
   * activitysession updateMany
   */
  export type activitysessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update activitysessions.
     */
    data: XOR<activitysessionUpdateManyMutationInput, activitysessionUncheckedUpdateManyInput>
    /**
     * Filter which activitysessions to update
     */
    where?: activitysessionWhereInput
    /**
     * Limit how many activitysessions to update.
     */
    limit?: number
  }

  /**
   * activitysession upsert
   */
  export type activitysessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitysession
     */
    select?: activitysessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitysession
     */
    omit?: activitysessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitysessionInclude<ExtArgs> | null
    /**
     * The filter to search for the activitysession to update in case it exists.
     */
    where: activitysessionWhereUniqueInput
    /**
     * In case the activitysession found by the `where` argument doesn't exist, create a new activitysession with this data.
     */
    create: XOR<activitysessionCreateInput, activitysessionUncheckedCreateInput>
    /**
     * In case the activitysession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activitysessionUpdateInput, activitysessionUncheckedUpdateInput>
  }

  /**
   * activitysession delete
   */
  export type activitysessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitysession
     */
    select?: activitysessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitysession
     */
    omit?: activitysessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitysessionInclude<ExtArgs> | null
    /**
     * Filter which activitysession to delete.
     */
    where: activitysessionWhereUniqueInput
  }

  /**
   * activitysession deleteMany
   */
  export type activitysessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activitysessions to delete
     */
    where?: activitysessionWhereInput
    /**
     * Limit how many activitysessions to delete.
     */
    limit?: number
  }

  /**
   * activitysession.attendance
   */
  export type activitysession$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    where?: attendanceWhereInput
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    cursor?: attendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * activitysession without action
   */
  export type activitysessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitysession
     */
    select?: activitysessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitysession
     */
    omit?: activitysessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitysessionInclude<ExtArgs> | null
  }


  /**
   * Model afterschoolactivity
   */

  export type AggregateAfterschoolactivity = {
    _count: AfterschoolactivityCountAggregateOutputType | null
    _avg: AfterschoolactivityAvgAggregateOutputType | null
    _sum: AfterschoolactivitySumAggregateOutputType | null
    _min: AfterschoolactivityMinAggregateOutputType | null
    _max: AfterschoolactivityMaxAggregateOutputType | null
  }

  export type AfterschoolactivityAvgAggregateOutputType = {
    id: number | null
  }

  export type AfterschoolactivitySumAggregateOutputType = {
    id: number | null
  }

  export type AfterschoolactivityMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    dayOfWeek: string | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    coachName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    photo: string | null
  }

  export type AfterschoolactivityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    dayOfWeek: string | null
    startTime: Date | null
    endTime: Date | null
    location: string | null
    coachName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    photo: string | null
  }

  export type AfterschoolactivityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    dayOfWeek: number
    startTime: number
    endTime: number
    location: number
    coachName: number
    createdAt: number
    updatedAt: number
    photo: number
    _all: number
  }


  export type AfterschoolactivityAvgAggregateInputType = {
    id?: true
  }

  export type AfterschoolactivitySumAggregateInputType = {
    id?: true
  }

  export type AfterschoolactivityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    location?: true
    coachName?: true
    createdAt?: true
    updatedAt?: true
    photo?: true
  }

  export type AfterschoolactivityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    location?: true
    coachName?: true
    createdAt?: true
    updatedAt?: true
    photo?: true
  }

  export type AfterschoolactivityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    location?: true
    coachName?: true
    createdAt?: true
    updatedAt?: true
    photo?: true
    _all?: true
  }

  export type AfterschoolactivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which afterschoolactivity to aggregate.
     */
    where?: afterschoolactivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of afterschoolactivities to fetch.
     */
    orderBy?: afterschoolactivityOrderByWithRelationInput | afterschoolactivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: afterschoolactivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` afterschoolactivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` afterschoolactivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned afterschoolactivities
    **/
    _count?: true | AfterschoolactivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AfterschoolactivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AfterschoolactivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AfterschoolactivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AfterschoolactivityMaxAggregateInputType
  }

  export type GetAfterschoolactivityAggregateType<T extends AfterschoolactivityAggregateArgs> = {
        [P in keyof T & keyof AggregateAfterschoolactivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAfterschoolactivity[P]>
      : GetScalarType<T[P], AggregateAfterschoolactivity[P]>
  }




  export type afterschoolactivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: afterschoolactivityWhereInput
    orderBy?: afterschoolactivityOrderByWithAggregationInput | afterschoolactivityOrderByWithAggregationInput[]
    by: AfterschoolactivityScalarFieldEnum[] | AfterschoolactivityScalarFieldEnum
    having?: afterschoolactivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AfterschoolactivityCountAggregateInputType | true
    _avg?: AfterschoolactivityAvgAggregateInputType
    _sum?: AfterschoolactivitySumAggregateInputType
    _min?: AfterschoolactivityMinAggregateInputType
    _max?: AfterschoolactivityMaxAggregateInputType
  }

  export type AfterschoolactivityGroupByOutputType = {
    id: number
    name: string
    description: string | null
    dayOfWeek: string
    startTime: Date
    endTime: Date
    location: string | null
    coachName: string | null
    createdAt: Date
    updatedAt: Date
    photo: string | null
    _count: AfterschoolactivityCountAggregateOutputType | null
    _avg: AfterschoolactivityAvgAggregateOutputType | null
    _sum: AfterschoolactivitySumAggregateOutputType | null
    _min: AfterschoolactivityMinAggregateOutputType | null
    _max: AfterschoolactivityMaxAggregateOutputType | null
  }

  type GetAfterschoolactivityGroupByPayload<T extends afterschoolactivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AfterschoolactivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AfterschoolactivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AfterschoolactivityGroupByOutputType[P]>
            : GetScalarType<T[P], AfterschoolactivityGroupByOutputType[P]>
        }
      >
    >


  export type afterschoolactivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    coachName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    photo?: boolean
    activitysession?: boolean | afterschoolactivity$activitysessionArgs<ExtArgs>
    enrolledactivity?: boolean | afterschoolactivity$enrolledactivityArgs<ExtArgs>
    _count?: boolean | AfterschoolactivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["afterschoolactivity"]>



  export type afterschoolactivitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    location?: boolean
    coachName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    photo?: boolean
  }

  export type afterschoolactivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "dayOfWeek" | "startTime" | "endTime" | "location" | "coachName" | "createdAt" | "updatedAt" | "photo", ExtArgs["result"]["afterschoolactivity"]>
  export type afterschoolactivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activitysession?: boolean | afterschoolactivity$activitysessionArgs<ExtArgs>
    enrolledactivity?: boolean | afterschoolactivity$enrolledactivityArgs<ExtArgs>
    _count?: boolean | AfterschoolactivityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $afterschoolactivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "afterschoolactivity"
    objects: {
      activitysession: Prisma.$activitysessionPayload<ExtArgs>[]
      enrolledactivity: Prisma.$enrolledactivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      dayOfWeek: string
      startTime: Date
      endTime: Date
      location: string | null
      coachName: string | null
      createdAt: Date
      updatedAt: Date
      photo: string | null
    }, ExtArgs["result"]["afterschoolactivity"]>
    composites: {}
  }

  type afterschoolactivityGetPayload<S extends boolean | null | undefined | afterschoolactivityDefaultArgs> = $Result.GetResult<Prisma.$afterschoolactivityPayload, S>

  type afterschoolactivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<afterschoolactivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AfterschoolactivityCountAggregateInputType | true
    }

  export interface afterschoolactivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['afterschoolactivity'], meta: { name: 'afterschoolactivity' } }
    /**
     * Find zero or one Afterschoolactivity that matches the filter.
     * @param {afterschoolactivityFindUniqueArgs} args - Arguments to find a Afterschoolactivity
     * @example
     * // Get one Afterschoolactivity
     * const afterschoolactivity = await prisma.afterschoolactivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends afterschoolactivityFindUniqueArgs>(args: SelectSubset<T, afterschoolactivityFindUniqueArgs<ExtArgs>>): Prisma__afterschoolactivityClient<$Result.GetResult<Prisma.$afterschoolactivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Afterschoolactivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {afterschoolactivityFindUniqueOrThrowArgs} args - Arguments to find a Afterschoolactivity
     * @example
     * // Get one Afterschoolactivity
     * const afterschoolactivity = await prisma.afterschoolactivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends afterschoolactivityFindUniqueOrThrowArgs>(args: SelectSubset<T, afterschoolactivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__afterschoolactivityClient<$Result.GetResult<Prisma.$afterschoolactivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Afterschoolactivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {afterschoolactivityFindFirstArgs} args - Arguments to find a Afterschoolactivity
     * @example
     * // Get one Afterschoolactivity
     * const afterschoolactivity = await prisma.afterschoolactivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends afterschoolactivityFindFirstArgs>(args?: SelectSubset<T, afterschoolactivityFindFirstArgs<ExtArgs>>): Prisma__afterschoolactivityClient<$Result.GetResult<Prisma.$afterschoolactivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Afterschoolactivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {afterschoolactivityFindFirstOrThrowArgs} args - Arguments to find a Afterschoolactivity
     * @example
     * // Get one Afterschoolactivity
     * const afterschoolactivity = await prisma.afterschoolactivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends afterschoolactivityFindFirstOrThrowArgs>(args?: SelectSubset<T, afterschoolactivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__afterschoolactivityClient<$Result.GetResult<Prisma.$afterschoolactivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Afterschoolactivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {afterschoolactivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Afterschoolactivities
     * const afterschoolactivities = await prisma.afterschoolactivity.findMany()
     * 
     * // Get first 10 Afterschoolactivities
     * const afterschoolactivities = await prisma.afterschoolactivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const afterschoolactivityWithIdOnly = await prisma.afterschoolactivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends afterschoolactivityFindManyArgs>(args?: SelectSubset<T, afterschoolactivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$afterschoolactivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Afterschoolactivity.
     * @param {afterschoolactivityCreateArgs} args - Arguments to create a Afterschoolactivity.
     * @example
     * // Create one Afterschoolactivity
     * const Afterschoolactivity = await prisma.afterschoolactivity.create({
     *   data: {
     *     // ... data to create a Afterschoolactivity
     *   }
     * })
     * 
     */
    create<T extends afterschoolactivityCreateArgs>(args: SelectSubset<T, afterschoolactivityCreateArgs<ExtArgs>>): Prisma__afterschoolactivityClient<$Result.GetResult<Prisma.$afterschoolactivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Afterschoolactivities.
     * @param {afterschoolactivityCreateManyArgs} args - Arguments to create many Afterschoolactivities.
     * @example
     * // Create many Afterschoolactivities
     * const afterschoolactivity = await prisma.afterschoolactivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends afterschoolactivityCreateManyArgs>(args?: SelectSubset<T, afterschoolactivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Afterschoolactivity.
     * @param {afterschoolactivityDeleteArgs} args - Arguments to delete one Afterschoolactivity.
     * @example
     * // Delete one Afterschoolactivity
     * const Afterschoolactivity = await prisma.afterschoolactivity.delete({
     *   where: {
     *     // ... filter to delete one Afterschoolactivity
     *   }
     * })
     * 
     */
    delete<T extends afterschoolactivityDeleteArgs>(args: SelectSubset<T, afterschoolactivityDeleteArgs<ExtArgs>>): Prisma__afterschoolactivityClient<$Result.GetResult<Prisma.$afterschoolactivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Afterschoolactivity.
     * @param {afterschoolactivityUpdateArgs} args - Arguments to update one Afterschoolactivity.
     * @example
     * // Update one Afterschoolactivity
     * const afterschoolactivity = await prisma.afterschoolactivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends afterschoolactivityUpdateArgs>(args: SelectSubset<T, afterschoolactivityUpdateArgs<ExtArgs>>): Prisma__afterschoolactivityClient<$Result.GetResult<Prisma.$afterschoolactivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Afterschoolactivities.
     * @param {afterschoolactivityDeleteManyArgs} args - Arguments to filter Afterschoolactivities to delete.
     * @example
     * // Delete a few Afterschoolactivities
     * const { count } = await prisma.afterschoolactivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends afterschoolactivityDeleteManyArgs>(args?: SelectSubset<T, afterschoolactivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Afterschoolactivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {afterschoolactivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Afterschoolactivities
     * const afterschoolactivity = await prisma.afterschoolactivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends afterschoolactivityUpdateManyArgs>(args: SelectSubset<T, afterschoolactivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Afterschoolactivity.
     * @param {afterschoolactivityUpsertArgs} args - Arguments to update or create a Afterschoolactivity.
     * @example
     * // Update or create a Afterschoolactivity
     * const afterschoolactivity = await prisma.afterschoolactivity.upsert({
     *   create: {
     *     // ... data to create a Afterschoolactivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Afterschoolactivity we want to update
     *   }
     * })
     */
    upsert<T extends afterschoolactivityUpsertArgs>(args: SelectSubset<T, afterschoolactivityUpsertArgs<ExtArgs>>): Prisma__afterschoolactivityClient<$Result.GetResult<Prisma.$afterschoolactivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Afterschoolactivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {afterschoolactivityCountArgs} args - Arguments to filter Afterschoolactivities to count.
     * @example
     * // Count the number of Afterschoolactivities
     * const count = await prisma.afterschoolactivity.count({
     *   where: {
     *     // ... the filter for the Afterschoolactivities we want to count
     *   }
     * })
    **/
    count<T extends afterschoolactivityCountArgs>(
      args?: Subset<T, afterschoolactivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AfterschoolactivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Afterschoolactivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfterschoolactivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AfterschoolactivityAggregateArgs>(args: Subset<T, AfterschoolactivityAggregateArgs>): Prisma.PrismaPromise<GetAfterschoolactivityAggregateType<T>>

    /**
     * Group by Afterschoolactivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {afterschoolactivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends afterschoolactivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: afterschoolactivityGroupByArgs['orderBy'] }
        : { orderBy?: afterschoolactivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, afterschoolactivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAfterschoolactivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the afterschoolactivity model
   */
  readonly fields: afterschoolactivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for afterschoolactivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__afterschoolactivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activitysession<T extends afterschoolactivity$activitysessionArgs<ExtArgs> = {}>(args?: Subset<T, afterschoolactivity$activitysessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitysessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrolledactivity<T extends afterschoolactivity$enrolledactivityArgs<ExtArgs> = {}>(args?: Subset<T, afterschoolactivity$enrolledactivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrolledactivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the afterschoolactivity model
   */
  interface afterschoolactivityFieldRefs {
    readonly id: FieldRef<"afterschoolactivity", 'Int'>
    readonly name: FieldRef<"afterschoolactivity", 'String'>
    readonly description: FieldRef<"afterschoolactivity", 'String'>
    readonly dayOfWeek: FieldRef<"afterschoolactivity", 'String'>
    readonly startTime: FieldRef<"afterschoolactivity", 'DateTime'>
    readonly endTime: FieldRef<"afterschoolactivity", 'DateTime'>
    readonly location: FieldRef<"afterschoolactivity", 'String'>
    readonly coachName: FieldRef<"afterschoolactivity", 'String'>
    readonly createdAt: FieldRef<"afterschoolactivity", 'DateTime'>
    readonly updatedAt: FieldRef<"afterschoolactivity", 'DateTime'>
    readonly photo: FieldRef<"afterschoolactivity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * afterschoolactivity findUnique
   */
  export type afterschoolactivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the afterschoolactivity
     */
    select?: afterschoolactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the afterschoolactivity
     */
    omit?: afterschoolactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: afterschoolactivityInclude<ExtArgs> | null
    /**
     * Filter, which afterschoolactivity to fetch.
     */
    where: afterschoolactivityWhereUniqueInput
  }

  /**
   * afterschoolactivity findUniqueOrThrow
   */
  export type afterschoolactivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the afterschoolactivity
     */
    select?: afterschoolactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the afterschoolactivity
     */
    omit?: afterschoolactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: afterschoolactivityInclude<ExtArgs> | null
    /**
     * Filter, which afterschoolactivity to fetch.
     */
    where: afterschoolactivityWhereUniqueInput
  }

  /**
   * afterschoolactivity findFirst
   */
  export type afterschoolactivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the afterschoolactivity
     */
    select?: afterschoolactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the afterschoolactivity
     */
    omit?: afterschoolactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: afterschoolactivityInclude<ExtArgs> | null
    /**
     * Filter, which afterschoolactivity to fetch.
     */
    where?: afterschoolactivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of afterschoolactivities to fetch.
     */
    orderBy?: afterschoolactivityOrderByWithRelationInput | afterschoolactivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for afterschoolactivities.
     */
    cursor?: afterschoolactivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` afterschoolactivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` afterschoolactivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of afterschoolactivities.
     */
    distinct?: AfterschoolactivityScalarFieldEnum | AfterschoolactivityScalarFieldEnum[]
  }

  /**
   * afterschoolactivity findFirstOrThrow
   */
  export type afterschoolactivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the afterschoolactivity
     */
    select?: afterschoolactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the afterschoolactivity
     */
    omit?: afterschoolactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: afterschoolactivityInclude<ExtArgs> | null
    /**
     * Filter, which afterschoolactivity to fetch.
     */
    where?: afterschoolactivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of afterschoolactivities to fetch.
     */
    orderBy?: afterschoolactivityOrderByWithRelationInput | afterschoolactivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for afterschoolactivities.
     */
    cursor?: afterschoolactivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` afterschoolactivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` afterschoolactivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of afterschoolactivities.
     */
    distinct?: AfterschoolactivityScalarFieldEnum | AfterschoolactivityScalarFieldEnum[]
  }

  /**
   * afterschoolactivity findMany
   */
  export type afterschoolactivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the afterschoolactivity
     */
    select?: afterschoolactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the afterschoolactivity
     */
    omit?: afterschoolactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: afterschoolactivityInclude<ExtArgs> | null
    /**
     * Filter, which afterschoolactivities to fetch.
     */
    where?: afterschoolactivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of afterschoolactivities to fetch.
     */
    orderBy?: afterschoolactivityOrderByWithRelationInput | afterschoolactivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing afterschoolactivities.
     */
    cursor?: afterschoolactivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` afterschoolactivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` afterschoolactivities.
     */
    skip?: number
    distinct?: AfterschoolactivityScalarFieldEnum | AfterschoolactivityScalarFieldEnum[]
  }

  /**
   * afterschoolactivity create
   */
  export type afterschoolactivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the afterschoolactivity
     */
    select?: afterschoolactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the afterschoolactivity
     */
    omit?: afterschoolactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: afterschoolactivityInclude<ExtArgs> | null
    /**
     * The data needed to create a afterschoolactivity.
     */
    data: XOR<afterschoolactivityCreateInput, afterschoolactivityUncheckedCreateInput>
  }

  /**
   * afterschoolactivity createMany
   */
  export type afterschoolactivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many afterschoolactivities.
     */
    data: afterschoolactivityCreateManyInput | afterschoolactivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * afterschoolactivity update
   */
  export type afterschoolactivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the afterschoolactivity
     */
    select?: afterschoolactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the afterschoolactivity
     */
    omit?: afterschoolactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: afterschoolactivityInclude<ExtArgs> | null
    /**
     * The data needed to update a afterschoolactivity.
     */
    data: XOR<afterschoolactivityUpdateInput, afterschoolactivityUncheckedUpdateInput>
    /**
     * Choose, which afterschoolactivity to update.
     */
    where: afterschoolactivityWhereUniqueInput
  }

  /**
   * afterschoolactivity updateMany
   */
  export type afterschoolactivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update afterschoolactivities.
     */
    data: XOR<afterschoolactivityUpdateManyMutationInput, afterschoolactivityUncheckedUpdateManyInput>
    /**
     * Filter which afterschoolactivities to update
     */
    where?: afterschoolactivityWhereInput
    /**
     * Limit how many afterschoolactivities to update.
     */
    limit?: number
  }

  /**
   * afterschoolactivity upsert
   */
  export type afterschoolactivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the afterschoolactivity
     */
    select?: afterschoolactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the afterschoolactivity
     */
    omit?: afterschoolactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: afterschoolactivityInclude<ExtArgs> | null
    /**
     * The filter to search for the afterschoolactivity to update in case it exists.
     */
    where: afterschoolactivityWhereUniqueInput
    /**
     * In case the afterschoolactivity found by the `where` argument doesn't exist, create a new afterschoolactivity with this data.
     */
    create: XOR<afterschoolactivityCreateInput, afterschoolactivityUncheckedCreateInput>
    /**
     * In case the afterschoolactivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<afterschoolactivityUpdateInput, afterschoolactivityUncheckedUpdateInput>
  }

  /**
   * afterschoolactivity delete
   */
  export type afterschoolactivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the afterschoolactivity
     */
    select?: afterschoolactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the afterschoolactivity
     */
    omit?: afterschoolactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: afterschoolactivityInclude<ExtArgs> | null
    /**
     * Filter which afterschoolactivity to delete.
     */
    where: afterschoolactivityWhereUniqueInput
  }

  /**
   * afterschoolactivity deleteMany
   */
  export type afterschoolactivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which afterschoolactivities to delete
     */
    where?: afterschoolactivityWhereInput
    /**
     * Limit how many afterschoolactivities to delete.
     */
    limit?: number
  }

  /**
   * afterschoolactivity.activitysession
   */
  export type afterschoolactivity$activitysessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitysession
     */
    select?: activitysessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitysession
     */
    omit?: activitysessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitysessionInclude<ExtArgs> | null
    where?: activitysessionWhereInput
    orderBy?: activitysessionOrderByWithRelationInput | activitysessionOrderByWithRelationInput[]
    cursor?: activitysessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivitysessionScalarFieldEnum | ActivitysessionScalarFieldEnum[]
  }

  /**
   * afterschoolactivity.enrolledactivity
   */
  export type afterschoolactivity$enrolledactivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrolledactivity
     */
    select?: enrolledactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrolledactivity
     */
    omit?: enrolledactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrolledactivityInclude<ExtArgs> | null
    where?: enrolledactivityWhereInput
    orderBy?: enrolledactivityOrderByWithRelationInput | enrolledactivityOrderByWithRelationInput[]
    cursor?: enrolledactivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrolledactivityScalarFieldEnum | EnrolledactivityScalarFieldEnum[]
  }

  /**
   * afterschoolactivity without action
   */
  export type afterschoolactivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the afterschoolactivity
     */
    select?: afterschoolactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the afterschoolactivity
     */
    omit?: afterschoolactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: afterschoolactivityInclude<ExtArgs> | null
  }


  /**
   * Model attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    id: number | null
    sessionId: number | null
    userId: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    id: number | null
    sessionId: number | null
    userId: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: number | null
    sessionId: number | null
    userId: number | null
    status: string | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: number | null
    sessionId: number | null
    userId: number | null
    status: string | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    status: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
  }

  export type AttendanceSumAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    status?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    status?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    status?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendance to aggregate.
     */
    where?: attendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type attendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendanceWhereInput
    orderBy?: attendanceOrderByWithAggregationInput | attendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: attendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: number
    sessionId: number
    userId: number
    status: string
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends attendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type attendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    activitysession?: boolean | activitysessionDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>



  export type attendanceSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
  }

  export type attendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "status", ExtArgs["result"]["attendance"]>
  export type attendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activitysession?: boolean | activitysessionDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $attendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attendance"
    objects: {
      activitysession: Prisma.$activitysessionPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionId: number
      userId: number
      status: string
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type attendanceGetPayload<S extends boolean | null | undefined | attendanceDefaultArgs> = $Result.GetResult<Prisma.$attendancePayload, S>

  type attendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface attendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attendance'], meta: { name: 'attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {attendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attendanceFindUniqueArgs>(args: SelectSubset<T, attendanceFindUniqueArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, attendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attendanceFindFirstArgs>(args?: SelectSubset<T, attendanceFindFirstArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, attendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attendanceFindManyArgs>(args?: SelectSubset<T, attendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {attendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends attendanceCreateArgs>(args: SelectSubset<T, attendanceCreateArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {attendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attendanceCreateManyArgs>(args?: SelectSubset<T, attendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendance.
     * @param {attendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends attendanceDeleteArgs>(args: SelectSubset<T, attendanceDeleteArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {attendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attendanceUpdateArgs>(args: SelectSubset<T, attendanceUpdateArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {attendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attendanceDeleteManyArgs>(args?: SelectSubset<T, attendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attendanceUpdateManyArgs>(args: SelectSubset<T, attendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendance.
     * @param {attendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends attendanceUpsertArgs>(args: SelectSubset<T, attendanceUpsertArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends attendanceCountArgs>(
      args?: Subset<T, attendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attendanceGroupByArgs['orderBy'] }
        : { orderBy?: attendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attendance model
   */
  readonly fields: attendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activitysession<T extends activitysessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, activitysessionDefaultArgs<ExtArgs>>): Prisma__activitysessionClient<$Result.GetResult<Prisma.$activitysessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attendance model
   */
  interface attendanceFieldRefs {
    readonly id: FieldRef<"attendance", 'Int'>
    readonly sessionId: FieldRef<"attendance", 'Int'>
    readonly userId: FieldRef<"attendance", 'Int'>
    readonly status: FieldRef<"attendance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * attendance findUnique
   */
  export type attendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendance to fetch.
     */
    where: attendanceWhereUniqueInput
  }

  /**
   * attendance findUniqueOrThrow
   */
  export type attendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendance to fetch.
     */
    where: attendanceWhereUniqueInput
  }

  /**
   * attendance findFirst
   */
  export type attendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendance to fetch.
     */
    where?: attendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendances.
     */
    cursor?: attendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * attendance findFirstOrThrow
   */
  export type attendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendance to fetch.
     */
    where?: attendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendances.
     */
    cursor?: attendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * attendance findMany
   */
  export type attendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where?: attendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attendances.
     */
    cursor?: attendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * attendance create
   */
  export type attendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a attendance.
     */
    data: XOR<attendanceCreateInput, attendanceUncheckedCreateInput>
  }

  /**
   * attendance createMany
   */
  export type attendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attendances.
     */
    data: attendanceCreateManyInput | attendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attendance update
   */
  export type attendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a attendance.
     */
    data: XOR<attendanceUpdateInput, attendanceUncheckedUpdateInput>
    /**
     * Choose, which attendance to update.
     */
    where: attendanceWhereUniqueInput
  }

  /**
   * attendance updateMany
   */
  export type attendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attendances.
     */
    data: XOR<attendanceUpdateManyMutationInput, attendanceUncheckedUpdateManyInput>
    /**
     * Filter which attendances to update
     */
    where?: attendanceWhereInput
    /**
     * Limit how many attendances to update.
     */
    limit?: number
  }

  /**
   * attendance upsert
   */
  export type attendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the attendance to update in case it exists.
     */
    where: attendanceWhereUniqueInput
    /**
     * In case the attendance found by the `where` argument doesn't exist, create a new attendance with this data.
     */
    create: XOR<attendanceCreateInput, attendanceUncheckedCreateInput>
    /**
     * In case the attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attendanceUpdateInput, attendanceUncheckedUpdateInput>
  }

  /**
   * attendance delete
   */
  export type attendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter which attendance to delete.
     */
    where: attendanceWhereUniqueInput
  }

  /**
   * attendance deleteMany
   */
  export type attendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendances to delete
     */
    where?: attendanceWhereInput
    /**
     * Limit how many attendances to delete.
     */
    limit?: number
  }

  /**
   * attendance without action
   */
  export type attendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
  }


  /**
   * Model attendance_library
   */

  export type AggregateAttendance_library = {
    _count: Attendance_libraryCountAggregateOutputType | null
    _avg: Attendance_libraryAvgAggregateOutputType | null
    _sum: Attendance_librarySumAggregateOutputType | null
    _min: Attendance_libraryMinAggregateOutputType | null
    _max: Attendance_libraryMaxAggregateOutputType | null
  }

  export type Attendance_libraryAvgAggregateOutputType = {
    id: number | null
  }

  export type Attendance_librarySumAggregateOutputType = {
    id: number | null
  }

  export type Attendance_libraryMinAggregateOutputType = {
    id: number | null
    name: string | null
    date: Date | null
    rfid: string | null
  }

  export type Attendance_libraryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    date: Date | null
    rfid: string | null
  }

  export type Attendance_libraryCountAggregateOutputType = {
    id: number
    name: number
    date: number
    rfid: number
    _all: number
  }


  export type Attendance_libraryAvgAggregateInputType = {
    id?: true
  }

  export type Attendance_librarySumAggregateInputType = {
    id?: true
  }

  export type Attendance_libraryMinAggregateInputType = {
    id?: true
    name?: true
    date?: true
    rfid?: true
  }

  export type Attendance_libraryMaxAggregateInputType = {
    id?: true
    name?: true
    date?: true
    rfid?: true
  }

  export type Attendance_libraryCountAggregateInputType = {
    id?: true
    name?: true
    date?: true
    rfid?: true
    _all?: true
  }

  export type Attendance_libraryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendance_library to aggregate.
     */
    where?: attendance_libraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendance_libraries to fetch.
     */
    orderBy?: attendance_libraryOrderByWithRelationInput | attendance_libraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attendance_libraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendance_libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendance_libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attendance_libraries
    **/
    _count?: true | Attendance_libraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Attendance_libraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Attendance_librarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Attendance_libraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Attendance_libraryMaxAggregateInputType
  }

  export type GetAttendance_libraryAggregateType<T extends Attendance_libraryAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance_library]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance_library[P]>
      : GetScalarType<T[P], AggregateAttendance_library[P]>
  }




  export type attendance_libraryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendance_libraryWhereInput
    orderBy?: attendance_libraryOrderByWithAggregationInput | attendance_libraryOrderByWithAggregationInput[]
    by: Attendance_libraryScalarFieldEnum[] | Attendance_libraryScalarFieldEnum
    having?: attendance_libraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Attendance_libraryCountAggregateInputType | true
    _avg?: Attendance_libraryAvgAggregateInputType
    _sum?: Attendance_librarySumAggregateInputType
    _min?: Attendance_libraryMinAggregateInputType
    _max?: Attendance_libraryMaxAggregateInputType
  }

  export type Attendance_libraryGroupByOutputType = {
    id: number
    name: string | null
    date: Date | null
    rfid: string | null
    _count: Attendance_libraryCountAggregateOutputType | null
    _avg: Attendance_libraryAvgAggregateOutputType | null
    _sum: Attendance_librarySumAggregateOutputType | null
    _min: Attendance_libraryMinAggregateOutputType | null
    _max: Attendance_libraryMaxAggregateOutputType | null
  }

  type GetAttendance_libraryGroupByPayload<T extends attendance_libraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Attendance_libraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Attendance_libraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Attendance_libraryGroupByOutputType[P]>
            : GetScalarType<T[P], Attendance_libraryGroupByOutputType[P]>
        }
      >
    >


  export type attendance_librarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    rfid?: boolean
  }, ExtArgs["result"]["attendance_library"]>



  export type attendance_librarySelectScalar = {
    id?: boolean
    name?: boolean
    date?: boolean
    rfid?: boolean
  }

  export type attendance_libraryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "date" | "rfid", ExtArgs["result"]["attendance_library"]>

  export type $attendance_libraryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attendance_library"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      date: Date | null
      rfid: string | null
    }, ExtArgs["result"]["attendance_library"]>
    composites: {}
  }

  type attendance_libraryGetPayload<S extends boolean | null | undefined | attendance_libraryDefaultArgs> = $Result.GetResult<Prisma.$attendance_libraryPayload, S>

  type attendance_libraryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attendance_libraryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Attendance_libraryCountAggregateInputType | true
    }

  export interface attendance_libraryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attendance_library'], meta: { name: 'attendance_library' } }
    /**
     * Find zero or one Attendance_library that matches the filter.
     * @param {attendance_libraryFindUniqueArgs} args - Arguments to find a Attendance_library
     * @example
     * // Get one Attendance_library
     * const attendance_library = await prisma.attendance_library.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attendance_libraryFindUniqueArgs>(args: SelectSubset<T, attendance_libraryFindUniqueArgs<ExtArgs>>): Prisma__attendance_libraryClient<$Result.GetResult<Prisma.$attendance_libraryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance_library that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attendance_libraryFindUniqueOrThrowArgs} args - Arguments to find a Attendance_library
     * @example
     * // Get one Attendance_library
     * const attendance_library = await prisma.attendance_library.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attendance_libraryFindUniqueOrThrowArgs>(args: SelectSubset<T, attendance_libraryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attendance_libraryClient<$Result.GetResult<Prisma.$attendance_libraryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance_library that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendance_libraryFindFirstArgs} args - Arguments to find a Attendance_library
     * @example
     * // Get one Attendance_library
     * const attendance_library = await prisma.attendance_library.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attendance_libraryFindFirstArgs>(args?: SelectSubset<T, attendance_libraryFindFirstArgs<ExtArgs>>): Prisma__attendance_libraryClient<$Result.GetResult<Prisma.$attendance_libraryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance_library that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendance_libraryFindFirstOrThrowArgs} args - Arguments to find a Attendance_library
     * @example
     * // Get one Attendance_library
     * const attendance_library = await prisma.attendance_library.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attendance_libraryFindFirstOrThrowArgs>(args?: SelectSubset<T, attendance_libraryFindFirstOrThrowArgs<ExtArgs>>): Prisma__attendance_libraryClient<$Result.GetResult<Prisma.$attendance_libraryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendance_libraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendance_libraryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendance_libraries
     * const attendance_libraries = await prisma.attendance_library.findMany()
     * 
     * // Get first 10 Attendance_libraries
     * const attendance_libraries = await prisma.attendance_library.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendance_libraryWithIdOnly = await prisma.attendance_library.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attendance_libraryFindManyArgs>(args?: SelectSubset<T, attendance_libraryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendance_libraryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance_library.
     * @param {attendance_libraryCreateArgs} args - Arguments to create a Attendance_library.
     * @example
     * // Create one Attendance_library
     * const Attendance_library = await prisma.attendance_library.create({
     *   data: {
     *     // ... data to create a Attendance_library
     *   }
     * })
     * 
     */
    create<T extends attendance_libraryCreateArgs>(args: SelectSubset<T, attendance_libraryCreateArgs<ExtArgs>>): Prisma__attendance_libraryClient<$Result.GetResult<Prisma.$attendance_libraryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendance_libraries.
     * @param {attendance_libraryCreateManyArgs} args - Arguments to create many Attendance_libraries.
     * @example
     * // Create many Attendance_libraries
     * const attendance_library = await prisma.attendance_library.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attendance_libraryCreateManyArgs>(args?: SelectSubset<T, attendance_libraryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendance_library.
     * @param {attendance_libraryDeleteArgs} args - Arguments to delete one Attendance_library.
     * @example
     * // Delete one Attendance_library
     * const Attendance_library = await prisma.attendance_library.delete({
     *   where: {
     *     // ... filter to delete one Attendance_library
     *   }
     * })
     * 
     */
    delete<T extends attendance_libraryDeleteArgs>(args: SelectSubset<T, attendance_libraryDeleteArgs<ExtArgs>>): Prisma__attendance_libraryClient<$Result.GetResult<Prisma.$attendance_libraryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance_library.
     * @param {attendance_libraryUpdateArgs} args - Arguments to update one Attendance_library.
     * @example
     * // Update one Attendance_library
     * const attendance_library = await prisma.attendance_library.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attendance_libraryUpdateArgs>(args: SelectSubset<T, attendance_libraryUpdateArgs<ExtArgs>>): Prisma__attendance_libraryClient<$Result.GetResult<Prisma.$attendance_libraryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendance_libraries.
     * @param {attendance_libraryDeleteManyArgs} args - Arguments to filter Attendance_libraries to delete.
     * @example
     * // Delete a few Attendance_libraries
     * const { count } = await prisma.attendance_library.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attendance_libraryDeleteManyArgs>(args?: SelectSubset<T, attendance_libraryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendance_libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendance_libraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendance_libraries
     * const attendance_library = await prisma.attendance_library.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attendance_libraryUpdateManyArgs>(args: SelectSubset<T, attendance_libraryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendance_library.
     * @param {attendance_libraryUpsertArgs} args - Arguments to update or create a Attendance_library.
     * @example
     * // Update or create a Attendance_library
     * const attendance_library = await prisma.attendance_library.upsert({
     *   create: {
     *     // ... data to create a Attendance_library
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance_library we want to update
     *   }
     * })
     */
    upsert<T extends attendance_libraryUpsertArgs>(args: SelectSubset<T, attendance_libraryUpsertArgs<ExtArgs>>): Prisma__attendance_libraryClient<$Result.GetResult<Prisma.$attendance_libraryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendance_libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendance_libraryCountArgs} args - Arguments to filter Attendance_libraries to count.
     * @example
     * // Count the number of Attendance_libraries
     * const count = await prisma.attendance_library.count({
     *   where: {
     *     // ... the filter for the Attendance_libraries we want to count
     *   }
     * })
    **/
    count<T extends attendance_libraryCountArgs>(
      args?: Subset<T, attendance_libraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Attendance_libraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance_library.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Attendance_libraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Attendance_libraryAggregateArgs>(args: Subset<T, Attendance_libraryAggregateArgs>): Prisma.PrismaPromise<GetAttendance_libraryAggregateType<T>>

    /**
     * Group by Attendance_library.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendance_libraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attendance_libraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attendance_libraryGroupByArgs['orderBy'] }
        : { orderBy?: attendance_libraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attendance_libraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendance_libraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attendance_library model
   */
  readonly fields: attendance_libraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attendance_library.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attendance_libraryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attendance_library model
   */
  interface attendance_libraryFieldRefs {
    readonly id: FieldRef<"attendance_library", 'Int'>
    readonly name: FieldRef<"attendance_library", 'String'>
    readonly date: FieldRef<"attendance_library", 'DateTime'>
    readonly rfid: FieldRef<"attendance_library", 'String'>
  }
    

  // Custom InputTypes
  /**
   * attendance_library findUnique
   */
  export type attendance_libraryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance_library
     */
    select?: attendance_librarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance_library
     */
    omit?: attendance_libraryOmit<ExtArgs> | null
    /**
     * Filter, which attendance_library to fetch.
     */
    where: attendance_libraryWhereUniqueInput
  }

  /**
   * attendance_library findUniqueOrThrow
   */
  export type attendance_libraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance_library
     */
    select?: attendance_librarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance_library
     */
    omit?: attendance_libraryOmit<ExtArgs> | null
    /**
     * Filter, which attendance_library to fetch.
     */
    where: attendance_libraryWhereUniqueInput
  }

  /**
   * attendance_library findFirst
   */
  export type attendance_libraryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance_library
     */
    select?: attendance_librarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance_library
     */
    omit?: attendance_libraryOmit<ExtArgs> | null
    /**
     * Filter, which attendance_library to fetch.
     */
    where?: attendance_libraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendance_libraries to fetch.
     */
    orderBy?: attendance_libraryOrderByWithRelationInput | attendance_libraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendance_libraries.
     */
    cursor?: attendance_libraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendance_libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendance_libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendance_libraries.
     */
    distinct?: Attendance_libraryScalarFieldEnum | Attendance_libraryScalarFieldEnum[]
  }

  /**
   * attendance_library findFirstOrThrow
   */
  export type attendance_libraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance_library
     */
    select?: attendance_librarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance_library
     */
    omit?: attendance_libraryOmit<ExtArgs> | null
    /**
     * Filter, which attendance_library to fetch.
     */
    where?: attendance_libraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendance_libraries to fetch.
     */
    orderBy?: attendance_libraryOrderByWithRelationInput | attendance_libraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendance_libraries.
     */
    cursor?: attendance_libraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendance_libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendance_libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendance_libraries.
     */
    distinct?: Attendance_libraryScalarFieldEnum | Attendance_libraryScalarFieldEnum[]
  }

  /**
   * attendance_library findMany
   */
  export type attendance_libraryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance_library
     */
    select?: attendance_librarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance_library
     */
    omit?: attendance_libraryOmit<ExtArgs> | null
    /**
     * Filter, which attendance_libraries to fetch.
     */
    where?: attendance_libraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendance_libraries to fetch.
     */
    orderBy?: attendance_libraryOrderByWithRelationInput | attendance_libraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attendance_libraries.
     */
    cursor?: attendance_libraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendance_libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendance_libraries.
     */
    skip?: number
    distinct?: Attendance_libraryScalarFieldEnum | Attendance_libraryScalarFieldEnum[]
  }

  /**
   * attendance_library create
   */
  export type attendance_libraryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance_library
     */
    select?: attendance_librarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance_library
     */
    omit?: attendance_libraryOmit<ExtArgs> | null
    /**
     * The data needed to create a attendance_library.
     */
    data?: XOR<attendance_libraryCreateInput, attendance_libraryUncheckedCreateInput>
  }

  /**
   * attendance_library createMany
   */
  export type attendance_libraryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attendance_libraries.
     */
    data: attendance_libraryCreateManyInput | attendance_libraryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attendance_library update
   */
  export type attendance_libraryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance_library
     */
    select?: attendance_librarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance_library
     */
    omit?: attendance_libraryOmit<ExtArgs> | null
    /**
     * The data needed to update a attendance_library.
     */
    data: XOR<attendance_libraryUpdateInput, attendance_libraryUncheckedUpdateInput>
    /**
     * Choose, which attendance_library to update.
     */
    where: attendance_libraryWhereUniqueInput
  }

  /**
   * attendance_library updateMany
   */
  export type attendance_libraryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attendance_libraries.
     */
    data: XOR<attendance_libraryUpdateManyMutationInput, attendance_libraryUncheckedUpdateManyInput>
    /**
     * Filter which attendance_libraries to update
     */
    where?: attendance_libraryWhereInput
    /**
     * Limit how many attendance_libraries to update.
     */
    limit?: number
  }

  /**
   * attendance_library upsert
   */
  export type attendance_libraryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance_library
     */
    select?: attendance_librarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance_library
     */
    omit?: attendance_libraryOmit<ExtArgs> | null
    /**
     * The filter to search for the attendance_library to update in case it exists.
     */
    where: attendance_libraryWhereUniqueInput
    /**
     * In case the attendance_library found by the `where` argument doesn't exist, create a new attendance_library with this data.
     */
    create: XOR<attendance_libraryCreateInput, attendance_libraryUncheckedCreateInput>
    /**
     * In case the attendance_library was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attendance_libraryUpdateInput, attendance_libraryUncheckedUpdateInput>
  }

  /**
   * attendance_library delete
   */
  export type attendance_libraryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance_library
     */
    select?: attendance_librarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance_library
     */
    omit?: attendance_libraryOmit<ExtArgs> | null
    /**
     * Filter which attendance_library to delete.
     */
    where: attendance_libraryWhereUniqueInput
  }

  /**
   * attendance_library deleteMany
   */
  export type attendance_libraryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendance_libraries to delete
     */
    where?: attendance_libraryWhereInput
    /**
     * Limit how many attendance_libraries to delete.
     */
    limit?: number
  }

  /**
   * attendance_library without action
   */
  export type attendance_libraryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance_library
     */
    select?: attendance_librarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance_library
     */
    omit?: attendance_libraryOmit<ExtArgs> | null
  }


  /**
   * Model borrowers
   */

  export type AggregateBorrowers = {
    _count: BorrowersCountAggregateOutputType | null
    _avg: BorrowersAvgAggregateOutputType | null
    _sum: BorrowersSumAggregateOutputType | null
    _min: BorrowersMinAggregateOutputType | null
    _max: BorrowersMaxAggregateOutputType | null
  }

  export type BorrowersAvgAggregateOutputType = {
    id: number | null
  }

  export type BorrowersSumAggregateOutputType = {
    id: number | null
  }

  export type BorrowersMinAggregateOutputType = {
    id: number | null
    name: string | null
    rfid: string | null
    title: string | null
    date_borrowed: Date | null
    date_returned: Date | null
    remarks: string | null
  }

  export type BorrowersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    rfid: string | null
    title: string | null
    date_borrowed: Date | null
    date_returned: Date | null
    remarks: string | null
  }

  export type BorrowersCountAggregateOutputType = {
    id: number
    name: number
    rfid: number
    title: number
    date_borrowed: number
    date_returned: number
    remarks: number
    _all: number
  }


  export type BorrowersAvgAggregateInputType = {
    id?: true
  }

  export type BorrowersSumAggregateInputType = {
    id?: true
  }

  export type BorrowersMinAggregateInputType = {
    id?: true
    name?: true
    rfid?: true
    title?: true
    date_borrowed?: true
    date_returned?: true
    remarks?: true
  }

  export type BorrowersMaxAggregateInputType = {
    id?: true
    name?: true
    rfid?: true
    title?: true
    date_borrowed?: true
    date_returned?: true
    remarks?: true
  }

  export type BorrowersCountAggregateInputType = {
    id?: true
    name?: true
    rfid?: true
    title?: true
    date_borrowed?: true
    date_returned?: true
    remarks?: true
    _all?: true
  }

  export type BorrowersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which borrowers to aggregate.
     */
    where?: borrowersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of borrowers to fetch.
     */
    orderBy?: borrowersOrderByWithRelationInput | borrowersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: borrowersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` borrowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` borrowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned borrowers
    **/
    _count?: true | BorrowersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BorrowersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BorrowersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BorrowersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BorrowersMaxAggregateInputType
  }

  export type GetBorrowersAggregateType<T extends BorrowersAggregateArgs> = {
        [P in keyof T & keyof AggregateBorrowers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBorrowers[P]>
      : GetScalarType<T[P], AggregateBorrowers[P]>
  }




  export type borrowersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: borrowersWhereInput
    orderBy?: borrowersOrderByWithAggregationInput | borrowersOrderByWithAggregationInput[]
    by: BorrowersScalarFieldEnum[] | BorrowersScalarFieldEnum
    having?: borrowersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BorrowersCountAggregateInputType | true
    _avg?: BorrowersAvgAggregateInputType
    _sum?: BorrowersSumAggregateInputType
    _min?: BorrowersMinAggregateInputType
    _max?: BorrowersMaxAggregateInputType
  }

  export type BorrowersGroupByOutputType = {
    id: number
    name: string | null
    rfid: string | null
    title: string | null
    date_borrowed: Date | null
    date_returned: Date | null
    remarks: string | null
    _count: BorrowersCountAggregateOutputType | null
    _avg: BorrowersAvgAggregateOutputType | null
    _sum: BorrowersSumAggregateOutputType | null
    _min: BorrowersMinAggregateOutputType | null
    _max: BorrowersMaxAggregateOutputType | null
  }

  type GetBorrowersGroupByPayload<T extends borrowersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BorrowersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BorrowersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BorrowersGroupByOutputType[P]>
            : GetScalarType<T[P], BorrowersGroupByOutputType[P]>
        }
      >
    >


  export type borrowersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rfid?: boolean
    title?: boolean
    date_borrowed?: boolean
    date_returned?: boolean
    remarks?: boolean
  }, ExtArgs["result"]["borrowers"]>



  export type borrowersSelectScalar = {
    id?: boolean
    name?: boolean
    rfid?: boolean
    title?: boolean
    date_borrowed?: boolean
    date_returned?: boolean
    remarks?: boolean
  }

  export type borrowersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "rfid" | "title" | "date_borrowed" | "date_returned" | "remarks", ExtArgs["result"]["borrowers"]>

  export type $borrowersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "borrowers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      rfid: string | null
      title: string | null
      date_borrowed: Date | null
      date_returned: Date | null
      remarks: string | null
    }, ExtArgs["result"]["borrowers"]>
    composites: {}
  }

  type borrowersGetPayload<S extends boolean | null | undefined | borrowersDefaultArgs> = $Result.GetResult<Prisma.$borrowersPayload, S>

  type borrowersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<borrowersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BorrowersCountAggregateInputType | true
    }

  export interface borrowersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['borrowers'], meta: { name: 'borrowers' } }
    /**
     * Find zero or one Borrowers that matches the filter.
     * @param {borrowersFindUniqueArgs} args - Arguments to find a Borrowers
     * @example
     * // Get one Borrowers
     * const borrowers = await prisma.borrowers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends borrowersFindUniqueArgs>(args: SelectSubset<T, borrowersFindUniqueArgs<ExtArgs>>): Prisma__borrowersClient<$Result.GetResult<Prisma.$borrowersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Borrowers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {borrowersFindUniqueOrThrowArgs} args - Arguments to find a Borrowers
     * @example
     * // Get one Borrowers
     * const borrowers = await prisma.borrowers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends borrowersFindUniqueOrThrowArgs>(args: SelectSubset<T, borrowersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__borrowersClient<$Result.GetResult<Prisma.$borrowersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Borrowers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borrowersFindFirstArgs} args - Arguments to find a Borrowers
     * @example
     * // Get one Borrowers
     * const borrowers = await prisma.borrowers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends borrowersFindFirstArgs>(args?: SelectSubset<T, borrowersFindFirstArgs<ExtArgs>>): Prisma__borrowersClient<$Result.GetResult<Prisma.$borrowersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Borrowers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borrowersFindFirstOrThrowArgs} args - Arguments to find a Borrowers
     * @example
     * // Get one Borrowers
     * const borrowers = await prisma.borrowers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends borrowersFindFirstOrThrowArgs>(args?: SelectSubset<T, borrowersFindFirstOrThrowArgs<ExtArgs>>): Prisma__borrowersClient<$Result.GetResult<Prisma.$borrowersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Borrowers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borrowersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Borrowers
     * const borrowers = await prisma.borrowers.findMany()
     * 
     * // Get first 10 Borrowers
     * const borrowers = await prisma.borrowers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const borrowersWithIdOnly = await prisma.borrowers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends borrowersFindManyArgs>(args?: SelectSubset<T, borrowersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$borrowersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Borrowers.
     * @param {borrowersCreateArgs} args - Arguments to create a Borrowers.
     * @example
     * // Create one Borrowers
     * const Borrowers = await prisma.borrowers.create({
     *   data: {
     *     // ... data to create a Borrowers
     *   }
     * })
     * 
     */
    create<T extends borrowersCreateArgs>(args: SelectSubset<T, borrowersCreateArgs<ExtArgs>>): Prisma__borrowersClient<$Result.GetResult<Prisma.$borrowersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Borrowers.
     * @param {borrowersCreateManyArgs} args - Arguments to create many Borrowers.
     * @example
     * // Create many Borrowers
     * const borrowers = await prisma.borrowers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends borrowersCreateManyArgs>(args?: SelectSubset<T, borrowersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Borrowers.
     * @param {borrowersDeleteArgs} args - Arguments to delete one Borrowers.
     * @example
     * // Delete one Borrowers
     * const Borrowers = await prisma.borrowers.delete({
     *   where: {
     *     // ... filter to delete one Borrowers
     *   }
     * })
     * 
     */
    delete<T extends borrowersDeleteArgs>(args: SelectSubset<T, borrowersDeleteArgs<ExtArgs>>): Prisma__borrowersClient<$Result.GetResult<Prisma.$borrowersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Borrowers.
     * @param {borrowersUpdateArgs} args - Arguments to update one Borrowers.
     * @example
     * // Update one Borrowers
     * const borrowers = await prisma.borrowers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends borrowersUpdateArgs>(args: SelectSubset<T, borrowersUpdateArgs<ExtArgs>>): Prisma__borrowersClient<$Result.GetResult<Prisma.$borrowersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Borrowers.
     * @param {borrowersDeleteManyArgs} args - Arguments to filter Borrowers to delete.
     * @example
     * // Delete a few Borrowers
     * const { count } = await prisma.borrowers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends borrowersDeleteManyArgs>(args?: SelectSubset<T, borrowersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Borrowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borrowersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Borrowers
     * const borrowers = await prisma.borrowers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends borrowersUpdateManyArgs>(args: SelectSubset<T, borrowersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Borrowers.
     * @param {borrowersUpsertArgs} args - Arguments to update or create a Borrowers.
     * @example
     * // Update or create a Borrowers
     * const borrowers = await prisma.borrowers.upsert({
     *   create: {
     *     // ... data to create a Borrowers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Borrowers we want to update
     *   }
     * })
     */
    upsert<T extends borrowersUpsertArgs>(args: SelectSubset<T, borrowersUpsertArgs<ExtArgs>>): Prisma__borrowersClient<$Result.GetResult<Prisma.$borrowersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Borrowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borrowersCountArgs} args - Arguments to filter Borrowers to count.
     * @example
     * // Count the number of Borrowers
     * const count = await prisma.borrowers.count({
     *   where: {
     *     // ... the filter for the Borrowers we want to count
     *   }
     * })
    **/
    count<T extends borrowersCountArgs>(
      args?: Subset<T, borrowersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BorrowersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Borrowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BorrowersAggregateArgs>(args: Subset<T, BorrowersAggregateArgs>): Prisma.PrismaPromise<GetBorrowersAggregateType<T>>

    /**
     * Group by Borrowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borrowersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends borrowersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: borrowersGroupByArgs['orderBy'] }
        : { orderBy?: borrowersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, borrowersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBorrowersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the borrowers model
   */
  readonly fields: borrowersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for borrowers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__borrowersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the borrowers model
   */
  interface borrowersFieldRefs {
    readonly id: FieldRef<"borrowers", 'Int'>
    readonly name: FieldRef<"borrowers", 'String'>
    readonly rfid: FieldRef<"borrowers", 'String'>
    readonly title: FieldRef<"borrowers", 'String'>
    readonly date_borrowed: FieldRef<"borrowers", 'DateTime'>
    readonly date_returned: FieldRef<"borrowers", 'DateTime'>
    readonly remarks: FieldRef<"borrowers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * borrowers findUnique
   */
  export type borrowersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the borrowers
     */
    select?: borrowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the borrowers
     */
    omit?: borrowersOmit<ExtArgs> | null
    /**
     * Filter, which borrowers to fetch.
     */
    where: borrowersWhereUniqueInput
  }

  /**
   * borrowers findUniqueOrThrow
   */
  export type borrowersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the borrowers
     */
    select?: borrowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the borrowers
     */
    omit?: borrowersOmit<ExtArgs> | null
    /**
     * Filter, which borrowers to fetch.
     */
    where: borrowersWhereUniqueInput
  }

  /**
   * borrowers findFirst
   */
  export type borrowersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the borrowers
     */
    select?: borrowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the borrowers
     */
    omit?: borrowersOmit<ExtArgs> | null
    /**
     * Filter, which borrowers to fetch.
     */
    where?: borrowersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of borrowers to fetch.
     */
    orderBy?: borrowersOrderByWithRelationInput | borrowersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for borrowers.
     */
    cursor?: borrowersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` borrowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` borrowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of borrowers.
     */
    distinct?: BorrowersScalarFieldEnum | BorrowersScalarFieldEnum[]
  }

  /**
   * borrowers findFirstOrThrow
   */
  export type borrowersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the borrowers
     */
    select?: borrowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the borrowers
     */
    omit?: borrowersOmit<ExtArgs> | null
    /**
     * Filter, which borrowers to fetch.
     */
    where?: borrowersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of borrowers to fetch.
     */
    orderBy?: borrowersOrderByWithRelationInput | borrowersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for borrowers.
     */
    cursor?: borrowersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` borrowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` borrowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of borrowers.
     */
    distinct?: BorrowersScalarFieldEnum | BorrowersScalarFieldEnum[]
  }

  /**
   * borrowers findMany
   */
  export type borrowersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the borrowers
     */
    select?: borrowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the borrowers
     */
    omit?: borrowersOmit<ExtArgs> | null
    /**
     * Filter, which borrowers to fetch.
     */
    where?: borrowersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of borrowers to fetch.
     */
    orderBy?: borrowersOrderByWithRelationInput | borrowersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing borrowers.
     */
    cursor?: borrowersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` borrowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` borrowers.
     */
    skip?: number
    distinct?: BorrowersScalarFieldEnum | BorrowersScalarFieldEnum[]
  }

  /**
   * borrowers create
   */
  export type borrowersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the borrowers
     */
    select?: borrowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the borrowers
     */
    omit?: borrowersOmit<ExtArgs> | null
    /**
     * The data needed to create a borrowers.
     */
    data?: XOR<borrowersCreateInput, borrowersUncheckedCreateInput>
  }

  /**
   * borrowers createMany
   */
  export type borrowersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many borrowers.
     */
    data: borrowersCreateManyInput | borrowersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * borrowers update
   */
  export type borrowersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the borrowers
     */
    select?: borrowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the borrowers
     */
    omit?: borrowersOmit<ExtArgs> | null
    /**
     * The data needed to update a borrowers.
     */
    data: XOR<borrowersUpdateInput, borrowersUncheckedUpdateInput>
    /**
     * Choose, which borrowers to update.
     */
    where: borrowersWhereUniqueInput
  }

  /**
   * borrowers updateMany
   */
  export type borrowersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update borrowers.
     */
    data: XOR<borrowersUpdateManyMutationInput, borrowersUncheckedUpdateManyInput>
    /**
     * Filter which borrowers to update
     */
    where?: borrowersWhereInput
    /**
     * Limit how many borrowers to update.
     */
    limit?: number
  }

  /**
   * borrowers upsert
   */
  export type borrowersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the borrowers
     */
    select?: borrowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the borrowers
     */
    omit?: borrowersOmit<ExtArgs> | null
    /**
     * The filter to search for the borrowers to update in case it exists.
     */
    where: borrowersWhereUniqueInput
    /**
     * In case the borrowers found by the `where` argument doesn't exist, create a new borrowers with this data.
     */
    create: XOR<borrowersCreateInput, borrowersUncheckedCreateInput>
    /**
     * In case the borrowers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<borrowersUpdateInput, borrowersUncheckedUpdateInput>
  }

  /**
   * borrowers delete
   */
  export type borrowersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the borrowers
     */
    select?: borrowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the borrowers
     */
    omit?: borrowersOmit<ExtArgs> | null
    /**
     * Filter which borrowers to delete.
     */
    where: borrowersWhereUniqueInput
  }

  /**
   * borrowers deleteMany
   */
  export type borrowersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which borrowers to delete
     */
    where?: borrowersWhereInput
    /**
     * Limit how many borrowers to delete.
     */
    limit?: number
  }

  /**
   * borrowers without action
   */
  export type borrowersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the borrowers
     */
    select?: borrowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the borrowers
     */
    omit?: borrowersOmit<ExtArgs> | null
  }


  /**
   * Model buyers
   */

  export type AggregateBuyers = {
    _count: BuyersCountAggregateOutputType | null
    _avg: BuyersAvgAggregateOutputType | null
    _sum: BuyersSumAggregateOutputType | null
    _min: BuyersMinAggregateOutputType | null
    _max: BuyersMaxAggregateOutputType | null
  }

  export type BuyersAvgAggregateOutputType = {
    buyer_id: number | null
    rfid: number | null
  }

  export type BuyersSumAggregateOutputType = {
    buyer_id: number | null
    rfid: bigint | null
  }

  export type BuyersMinAggregateOutputType = {
    buyer_id: number | null
    buyer_name: string | null
    rfid: bigint | null
  }

  export type BuyersMaxAggregateOutputType = {
    buyer_id: number | null
    buyer_name: string | null
    rfid: bigint | null
  }

  export type BuyersCountAggregateOutputType = {
    buyer_id: number
    buyer_name: number
    rfid: number
    _all: number
  }


  export type BuyersAvgAggregateInputType = {
    buyer_id?: true
    rfid?: true
  }

  export type BuyersSumAggregateInputType = {
    buyer_id?: true
    rfid?: true
  }

  export type BuyersMinAggregateInputType = {
    buyer_id?: true
    buyer_name?: true
    rfid?: true
  }

  export type BuyersMaxAggregateInputType = {
    buyer_id?: true
    buyer_name?: true
    rfid?: true
  }

  export type BuyersCountAggregateInputType = {
    buyer_id?: true
    buyer_name?: true
    rfid?: true
    _all?: true
  }

  export type BuyersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which buyers to aggregate.
     */
    where?: buyersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of buyers to fetch.
     */
    orderBy?: buyersOrderByWithRelationInput | buyersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: buyersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` buyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` buyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned buyers
    **/
    _count?: true | BuyersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuyersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuyersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuyersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuyersMaxAggregateInputType
  }

  export type GetBuyersAggregateType<T extends BuyersAggregateArgs> = {
        [P in keyof T & keyof AggregateBuyers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuyers[P]>
      : GetScalarType<T[P], AggregateBuyers[P]>
  }




  export type buyersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: buyersWhereInput
    orderBy?: buyersOrderByWithAggregationInput | buyersOrderByWithAggregationInput[]
    by: BuyersScalarFieldEnum[] | BuyersScalarFieldEnum
    having?: buyersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuyersCountAggregateInputType | true
    _avg?: BuyersAvgAggregateInputType
    _sum?: BuyersSumAggregateInputType
    _min?: BuyersMinAggregateInputType
    _max?: BuyersMaxAggregateInputType
  }

  export type BuyersGroupByOutputType = {
    buyer_id: number
    buyer_name: string
    rfid: bigint | null
    _count: BuyersCountAggregateOutputType | null
    _avg: BuyersAvgAggregateOutputType | null
    _sum: BuyersSumAggregateOutputType | null
    _min: BuyersMinAggregateOutputType | null
    _max: BuyersMaxAggregateOutputType | null
  }

  type GetBuyersGroupByPayload<T extends buyersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuyersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuyersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuyersGroupByOutputType[P]>
            : GetScalarType<T[P], BuyersGroupByOutputType[P]>
        }
      >
    >


  export type buyersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    buyer_id?: boolean
    buyer_name?: boolean
    rfid?: boolean
  }, ExtArgs["result"]["buyers"]>



  export type buyersSelectScalar = {
    buyer_id?: boolean
    buyer_name?: boolean
    rfid?: boolean
  }

  export type buyersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"buyer_id" | "buyer_name" | "rfid", ExtArgs["result"]["buyers"]>

  export type $buyersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "buyers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      buyer_id: number
      buyer_name: string
      rfid: bigint | null
    }, ExtArgs["result"]["buyers"]>
    composites: {}
  }

  type buyersGetPayload<S extends boolean | null | undefined | buyersDefaultArgs> = $Result.GetResult<Prisma.$buyersPayload, S>

  type buyersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<buyersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuyersCountAggregateInputType | true
    }

  export interface buyersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['buyers'], meta: { name: 'buyers' } }
    /**
     * Find zero or one Buyers that matches the filter.
     * @param {buyersFindUniqueArgs} args - Arguments to find a Buyers
     * @example
     * // Get one Buyers
     * const buyers = await prisma.buyers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends buyersFindUniqueArgs>(args: SelectSubset<T, buyersFindUniqueArgs<ExtArgs>>): Prisma__buyersClient<$Result.GetResult<Prisma.$buyersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Buyers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {buyersFindUniqueOrThrowArgs} args - Arguments to find a Buyers
     * @example
     * // Get one Buyers
     * const buyers = await prisma.buyers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends buyersFindUniqueOrThrowArgs>(args: SelectSubset<T, buyersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__buyersClient<$Result.GetResult<Prisma.$buyersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Buyers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buyersFindFirstArgs} args - Arguments to find a Buyers
     * @example
     * // Get one Buyers
     * const buyers = await prisma.buyers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends buyersFindFirstArgs>(args?: SelectSubset<T, buyersFindFirstArgs<ExtArgs>>): Prisma__buyersClient<$Result.GetResult<Prisma.$buyersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Buyers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buyersFindFirstOrThrowArgs} args - Arguments to find a Buyers
     * @example
     * // Get one Buyers
     * const buyers = await prisma.buyers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends buyersFindFirstOrThrowArgs>(args?: SelectSubset<T, buyersFindFirstOrThrowArgs<ExtArgs>>): Prisma__buyersClient<$Result.GetResult<Prisma.$buyersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Buyers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buyersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Buyers
     * const buyers = await prisma.buyers.findMany()
     * 
     * // Get first 10 Buyers
     * const buyers = await prisma.buyers.findMany({ take: 10 })
     * 
     * // Only select the `buyer_id`
     * const buyersWithBuyer_idOnly = await prisma.buyers.findMany({ select: { buyer_id: true } })
     * 
     */
    findMany<T extends buyersFindManyArgs>(args?: SelectSubset<T, buyersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$buyersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Buyers.
     * @param {buyersCreateArgs} args - Arguments to create a Buyers.
     * @example
     * // Create one Buyers
     * const Buyers = await prisma.buyers.create({
     *   data: {
     *     // ... data to create a Buyers
     *   }
     * })
     * 
     */
    create<T extends buyersCreateArgs>(args: SelectSubset<T, buyersCreateArgs<ExtArgs>>): Prisma__buyersClient<$Result.GetResult<Prisma.$buyersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Buyers.
     * @param {buyersCreateManyArgs} args - Arguments to create many Buyers.
     * @example
     * // Create many Buyers
     * const buyers = await prisma.buyers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends buyersCreateManyArgs>(args?: SelectSubset<T, buyersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Buyers.
     * @param {buyersDeleteArgs} args - Arguments to delete one Buyers.
     * @example
     * // Delete one Buyers
     * const Buyers = await prisma.buyers.delete({
     *   where: {
     *     // ... filter to delete one Buyers
     *   }
     * })
     * 
     */
    delete<T extends buyersDeleteArgs>(args: SelectSubset<T, buyersDeleteArgs<ExtArgs>>): Prisma__buyersClient<$Result.GetResult<Prisma.$buyersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Buyers.
     * @param {buyersUpdateArgs} args - Arguments to update one Buyers.
     * @example
     * // Update one Buyers
     * const buyers = await prisma.buyers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends buyersUpdateArgs>(args: SelectSubset<T, buyersUpdateArgs<ExtArgs>>): Prisma__buyersClient<$Result.GetResult<Prisma.$buyersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Buyers.
     * @param {buyersDeleteManyArgs} args - Arguments to filter Buyers to delete.
     * @example
     * // Delete a few Buyers
     * const { count } = await prisma.buyers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends buyersDeleteManyArgs>(args?: SelectSubset<T, buyersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buyersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Buyers
     * const buyers = await prisma.buyers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends buyersUpdateManyArgs>(args: SelectSubset<T, buyersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Buyers.
     * @param {buyersUpsertArgs} args - Arguments to update or create a Buyers.
     * @example
     * // Update or create a Buyers
     * const buyers = await prisma.buyers.upsert({
     *   create: {
     *     // ... data to create a Buyers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Buyers we want to update
     *   }
     * })
     */
    upsert<T extends buyersUpsertArgs>(args: SelectSubset<T, buyersUpsertArgs<ExtArgs>>): Prisma__buyersClient<$Result.GetResult<Prisma.$buyersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Buyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buyersCountArgs} args - Arguments to filter Buyers to count.
     * @example
     * // Count the number of Buyers
     * const count = await prisma.buyers.count({
     *   where: {
     *     // ... the filter for the Buyers we want to count
     *   }
     * })
    **/
    count<T extends buyersCountArgs>(
      args?: Subset<T, buyersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuyersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Buyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuyersAggregateArgs>(args: Subset<T, BuyersAggregateArgs>): Prisma.PrismaPromise<GetBuyersAggregateType<T>>

    /**
     * Group by Buyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buyersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends buyersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: buyersGroupByArgs['orderBy'] }
        : { orderBy?: buyersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, buyersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuyersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the buyers model
   */
  readonly fields: buyersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for buyers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__buyersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the buyers model
   */
  interface buyersFieldRefs {
    readonly buyer_id: FieldRef<"buyers", 'Int'>
    readonly buyer_name: FieldRef<"buyers", 'String'>
    readonly rfid: FieldRef<"buyers", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * buyers findUnique
   */
  export type buyersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the buyers
     */
    select?: buyersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the buyers
     */
    omit?: buyersOmit<ExtArgs> | null
    /**
     * Filter, which buyers to fetch.
     */
    where: buyersWhereUniqueInput
  }

  /**
   * buyers findUniqueOrThrow
   */
  export type buyersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the buyers
     */
    select?: buyersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the buyers
     */
    omit?: buyersOmit<ExtArgs> | null
    /**
     * Filter, which buyers to fetch.
     */
    where: buyersWhereUniqueInput
  }

  /**
   * buyers findFirst
   */
  export type buyersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the buyers
     */
    select?: buyersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the buyers
     */
    omit?: buyersOmit<ExtArgs> | null
    /**
     * Filter, which buyers to fetch.
     */
    where?: buyersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of buyers to fetch.
     */
    orderBy?: buyersOrderByWithRelationInput | buyersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for buyers.
     */
    cursor?: buyersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` buyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` buyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of buyers.
     */
    distinct?: BuyersScalarFieldEnum | BuyersScalarFieldEnum[]
  }

  /**
   * buyers findFirstOrThrow
   */
  export type buyersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the buyers
     */
    select?: buyersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the buyers
     */
    omit?: buyersOmit<ExtArgs> | null
    /**
     * Filter, which buyers to fetch.
     */
    where?: buyersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of buyers to fetch.
     */
    orderBy?: buyersOrderByWithRelationInput | buyersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for buyers.
     */
    cursor?: buyersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` buyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` buyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of buyers.
     */
    distinct?: BuyersScalarFieldEnum | BuyersScalarFieldEnum[]
  }

  /**
   * buyers findMany
   */
  export type buyersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the buyers
     */
    select?: buyersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the buyers
     */
    omit?: buyersOmit<ExtArgs> | null
    /**
     * Filter, which buyers to fetch.
     */
    where?: buyersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of buyers to fetch.
     */
    orderBy?: buyersOrderByWithRelationInput | buyersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing buyers.
     */
    cursor?: buyersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` buyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` buyers.
     */
    skip?: number
    distinct?: BuyersScalarFieldEnum | BuyersScalarFieldEnum[]
  }

  /**
   * buyers create
   */
  export type buyersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the buyers
     */
    select?: buyersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the buyers
     */
    omit?: buyersOmit<ExtArgs> | null
    /**
     * The data needed to create a buyers.
     */
    data: XOR<buyersCreateInput, buyersUncheckedCreateInput>
  }

  /**
   * buyers createMany
   */
  export type buyersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many buyers.
     */
    data: buyersCreateManyInput | buyersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * buyers update
   */
  export type buyersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the buyers
     */
    select?: buyersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the buyers
     */
    omit?: buyersOmit<ExtArgs> | null
    /**
     * The data needed to update a buyers.
     */
    data: XOR<buyersUpdateInput, buyersUncheckedUpdateInput>
    /**
     * Choose, which buyers to update.
     */
    where: buyersWhereUniqueInput
  }

  /**
   * buyers updateMany
   */
  export type buyersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update buyers.
     */
    data: XOR<buyersUpdateManyMutationInput, buyersUncheckedUpdateManyInput>
    /**
     * Filter which buyers to update
     */
    where?: buyersWhereInput
    /**
     * Limit how many buyers to update.
     */
    limit?: number
  }

  /**
   * buyers upsert
   */
  export type buyersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the buyers
     */
    select?: buyersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the buyers
     */
    omit?: buyersOmit<ExtArgs> | null
    /**
     * The filter to search for the buyers to update in case it exists.
     */
    where: buyersWhereUniqueInput
    /**
     * In case the buyers found by the `where` argument doesn't exist, create a new buyers with this data.
     */
    create: XOR<buyersCreateInput, buyersUncheckedCreateInput>
    /**
     * In case the buyers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<buyersUpdateInput, buyersUncheckedUpdateInput>
  }

  /**
   * buyers delete
   */
  export type buyersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the buyers
     */
    select?: buyersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the buyers
     */
    omit?: buyersOmit<ExtArgs> | null
    /**
     * Filter which buyers to delete.
     */
    where: buyersWhereUniqueInput
  }

  /**
   * buyers deleteMany
   */
  export type buyersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which buyers to delete
     */
    where?: buyersWhereInput
    /**
     * Limit how many buyers to delete.
     */
    limit?: number
  }

  /**
   * buyers without action
   */
  export type buyersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the buyers
     */
    select?: buyersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the buyers
     */
    omit?: buyersOmit<ExtArgs> | null
  }


  /**
   * Model clinic_history
   */

  export type AggregateClinic_history = {
    _count: Clinic_historyCountAggregateOutputType | null
    _avg: Clinic_historyAvgAggregateOutputType | null
    _sum: Clinic_historySumAggregateOutputType | null
    _min: Clinic_historyMinAggregateOutputType | null
    _max: Clinic_historyMaxAggregateOutputType | null
  }

  export type Clinic_historyAvgAggregateOutputType = {
    Id: number | null
  }

  export type Clinic_historySumAggregateOutputType = {
    Id: number | null
  }

  export type Clinic_historyMinAggregateOutputType = {
    Id: number | null
    name: string | null
    grade: string | null
    complaint: string | null
    diagnose: string | null
    treatment: string | null
    vital_signs: string | null
    time_in: Date | null
    time_out: Date | null
    date: string | null
    remarks: string | null
  }

  export type Clinic_historyMaxAggregateOutputType = {
    Id: number | null
    name: string | null
    grade: string | null
    complaint: string | null
    diagnose: string | null
    treatment: string | null
    vital_signs: string | null
    time_in: Date | null
    time_out: Date | null
    date: string | null
    remarks: string | null
  }

  export type Clinic_historyCountAggregateOutputType = {
    Id: number
    name: number
    grade: number
    complaint: number
    diagnose: number
    treatment: number
    vital_signs: number
    time_in: number
    time_out: number
    date: number
    remarks: number
    _all: number
  }


  export type Clinic_historyAvgAggregateInputType = {
    Id?: true
  }

  export type Clinic_historySumAggregateInputType = {
    Id?: true
  }

  export type Clinic_historyMinAggregateInputType = {
    Id?: true
    name?: true
    grade?: true
    complaint?: true
    diagnose?: true
    treatment?: true
    vital_signs?: true
    time_in?: true
    time_out?: true
    date?: true
    remarks?: true
  }

  export type Clinic_historyMaxAggregateInputType = {
    Id?: true
    name?: true
    grade?: true
    complaint?: true
    diagnose?: true
    treatment?: true
    vital_signs?: true
    time_in?: true
    time_out?: true
    date?: true
    remarks?: true
  }

  export type Clinic_historyCountAggregateInputType = {
    Id?: true
    name?: true
    grade?: true
    complaint?: true
    diagnose?: true
    treatment?: true
    vital_signs?: true
    time_in?: true
    time_out?: true
    date?: true
    remarks?: true
    _all?: true
  }

  export type Clinic_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinic_history to aggregate.
     */
    where?: clinic_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_histories to fetch.
     */
    orderBy?: clinic_historyOrderByWithRelationInput | clinic_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clinic_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clinic_histories
    **/
    _count?: true | Clinic_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Clinic_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Clinic_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Clinic_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Clinic_historyMaxAggregateInputType
  }

  export type GetClinic_historyAggregateType<T extends Clinic_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateClinic_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinic_history[P]>
      : GetScalarType<T[P], AggregateClinic_history[P]>
  }




  export type clinic_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clinic_historyWhereInput
    orderBy?: clinic_historyOrderByWithAggregationInput | clinic_historyOrderByWithAggregationInput[]
    by: Clinic_historyScalarFieldEnum[] | Clinic_historyScalarFieldEnum
    having?: clinic_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Clinic_historyCountAggregateInputType | true
    _avg?: Clinic_historyAvgAggregateInputType
    _sum?: Clinic_historySumAggregateInputType
    _min?: Clinic_historyMinAggregateInputType
    _max?: Clinic_historyMaxAggregateInputType
  }

  export type Clinic_historyGroupByOutputType = {
    Id: number
    name: string
    grade: string
    complaint: string
    diagnose: string
    treatment: string
    vital_signs: string
    time_in: Date
    time_out: Date
    date: string
    remarks: string
    _count: Clinic_historyCountAggregateOutputType | null
    _avg: Clinic_historyAvgAggregateOutputType | null
    _sum: Clinic_historySumAggregateOutputType | null
    _min: Clinic_historyMinAggregateOutputType | null
    _max: Clinic_historyMaxAggregateOutputType | null
  }

  type GetClinic_historyGroupByPayload<T extends clinic_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Clinic_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Clinic_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Clinic_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Clinic_historyGroupByOutputType[P]>
        }
      >
    >


  export type clinic_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    name?: boolean
    grade?: boolean
    complaint?: boolean
    diagnose?: boolean
    treatment?: boolean
    vital_signs?: boolean
    time_in?: boolean
    time_out?: boolean
    date?: boolean
    remarks?: boolean
  }, ExtArgs["result"]["clinic_history"]>



  export type clinic_historySelectScalar = {
    Id?: boolean
    name?: boolean
    grade?: boolean
    complaint?: boolean
    diagnose?: boolean
    treatment?: boolean
    vital_signs?: boolean
    time_in?: boolean
    time_out?: boolean
    date?: boolean
    remarks?: boolean
  }

  export type clinic_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "name" | "grade" | "complaint" | "diagnose" | "treatment" | "vital_signs" | "time_in" | "time_out" | "date" | "remarks", ExtArgs["result"]["clinic_history"]>

  export type $clinic_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clinic_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      name: string
      grade: string
      complaint: string
      diagnose: string
      treatment: string
      vital_signs: string
      time_in: Date
      time_out: Date
      date: string
      remarks: string
    }, ExtArgs["result"]["clinic_history"]>
    composites: {}
  }

  type clinic_historyGetPayload<S extends boolean | null | undefined | clinic_historyDefaultArgs> = $Result.GetResult<Prisma.$clinic_historyPayload, S>

  type clinic_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clinic_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Clinic_historyCountAggregateInputType | true
    }

  export interface clinic_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clinic_history'], meta: { name: 'clinic_history' } }
    /**
     * Find zero or one Clinic_history that matches the filter.
     * @param {clinic_historyFindUniqueArgs} args - Arguments to find a Clinic_history
     * @example
     * // Get one Clinic_history
     * const clinic_history = await prisma.clinic_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clinic_historyFindUniqueArgs>(args: SelectSubset<T, clinic_historyFindUniqueArgs<ExtArgs>>): Prisma__clinic_historyClient<$Result.GetResult<Prisma.$clinic_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clinic_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clinic_historyFindUniqueOrThrowArgs} args - Arguments to find a Clinic_history
     * @example
     * // Get one Clinic_history
     * const clinic_history = await prisma.clinic_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clinic_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, clinic_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clinic_historyClient<$Result.GetResult<Prisma.$clinic_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clinic_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_historyFindFirstArgs} args - Arguments to find a Clinic_history
     * @example
     * // Get one Clinic_history
     * const clinic_history = await prisma.clinic_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clinic_historyFindFirstArgs>(args?: SelectSubset<T, clinic_historyFindFirstArgs<ExtArgs>>): Prisma__clinic_historyClient<$Result.GetResult<Prisma.$clinic_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clinic_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_historyFindFirstOrThrowArgs} args - Arguments to find a Clinic_history
     * @example
     * // Get one Clinic_history
     * const clinic_history = await prisma.clinic_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clinic_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, clinic_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__clinic_historyClient<$Result.GetResult<Prisma.$clinic_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clinic_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinic_histories
     * const clinic_histories = await prisma.clinic_history.findMany()
     * 
     * // Get first 10 Clinic_histories
     * const clinic_histories = await prisma.clinic_history.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const clinic_historyWithIdOnly = await prisma.clinic_history.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends clinic_historyFindManyArgs>(args?: SelectSubset<T, clinic_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinic_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clinic_history.
     * @param {clinic_historyCreateArgs} args - Arguments to create a Clinic_history.
     * @example
     * // Create one Clinic_history
     * const Clinic_history = await prisma.clinic_history.create({
     *   data: {
     *     // ... data to create a Clinic_history
     *   }
     * })
     * 
     */
    create<T extends clinic_historyCreateArgs>(args: SelectSubset<T, clinic_historyCreateArgs<ExtArgs>>): Prisma__clinic_historyClient<$Result.GetResult<Prisma.$clinic_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clinic_histories.
     * @param {clinic_historyCreateManyArgs} args - Arguments to create many Clinic_histories.
     * @example
     * // Create many Clinic_histories
     * const clinic_history = await prisma.clinic_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clinic_historyCreateManyArgs>(args?: SelectSubset<T, clinic_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clinic_history.
     * @param {clinic_historyDeleteArgs} args - Arguments to delete one Clinic_history.
     * @example
     * // Delete one Clinic_history
     * const Clinic_history = await prisma.clinic_history.delete({
     *   where: {
     *     // ... filter to delete one Clinic_history
     *   }
     * })
     * 
     */
    delete<T extends clinic_historyDeleteArgs>(args: SelectSubset<T, clinic_historyDeleteArgs<ExtArgs>>): Prisma__clinic_historyClient<$Result.GetResult<Prisma.$clinic_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clinic_history.
     * @param {clinic_historyUpdateArgs} args - Arguments to update one Clinic_history.
     * @example
     * // Update one Clinic_history
     * const clinic_history = await prisma.clinic_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clinic_historyUpdateArgs>(args: SelectSubset<T, clinic_historyUpdateArgs<ExtArgs>>): Prisma__clinic_historyClient<$Result.GetResult<Prisma.$clinic_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clinic_histories.
     * @param {clinic_historyDeleteManyArgs} args - Arguments to filter Clinic_histories to delete.
     * @example
     * // Delete a few Clinic_histories
     * const { count } = await prisma.clinic_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clinic_historyDeleteManyArgs>(args?: SelectSubset<T, clinic_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinic_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinic_histories
     * const clinic_history = await prisma.clinic_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clinic_historyUpdateManyArgs>(args: SelectSubset<T, clinic_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clinic_history.
     * @param {clinic_historyUpsertArgs} args - Arguments to update or create a Clinic_history.
     * @example
     * // Update or create a Clinic_history
     * const clinic_history = await prisma.clinic_history.upsert({
     *   create: {
     *     // ... data to create a Clinic_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinic_history we want to update
     *   }
     * })
     */
    upsert<T extends clinic_historyUpsertArgs>(args: SelectSubset<T, clinic_historyUpsertArgs<ExtArgs>>): Prisma__clinic_historyClient<$Result.GetResult<Prisma.$clinic_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clinic_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_historyCountArgs} args - Arguments to filter Clinic_histories to count.
     * @example
     * // Count the number of Clinic_histories
     * const count = await prisma.clinic_history.count({
     *   where: {
     *     // ... the filter for the Clinic_histories we want to count
     *   }
     * })
    **/
    count<T extends clinic_historyCountArgs>(
      args?: Subset<T, clinic_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Clinic_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinic_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Clinic_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Clinic_historyAggregateArgs>(args: Subset<T, Clinic_historyAggregateArgs>): Prisma.PrismaPromise<GetClinic_historyAggregateType<T>>

    /**
     * Group by Clinic_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clinic_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clinic_historyGroupByArgs['orderBy'] }
        : { orderBy?: clinic_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clinic_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinic_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clinic_history model
   */
  readonly fields: clinic_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clinic_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clinic_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clinic_history model
   */
  interface clinic_historyFieldRefs {
    readonly Id: FieldRef<"clinic_history", 'Int'>
    readonly name: FieldRef<"clinic_history", 'String'>
    readonly grade: FieldRef<"clinic_history", 'String'>
    readonly complaint: FieldRef<"clinic_history", 'String'>
    readonly diagnose: FieldRef<"clinic_history", 'String'>
    readonly treatment: FieldRef<"clinic_history", 'String'>
    readonly vital_signs: FieldRef<"clinic_history", 'String'>
    readonly time_in: FieldRef<"clinic_history", 'DateTime'>
    readonly time_out: FieldRef<"clinic_history", 'DateTime'>
    readonly date: FieldRef<"clinic_history", 'String'>
    readonly remarks: FieldRef<"clinic_history", 'String'>
  }
    

  // Custom InputTypes
  /**
   * clinic_history findUnique
   */
  export type clinic_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_history
     */
    select?: clinic_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_history
     */
    omit?: clinic_historyOmit<ExtArgs> | null
    /**
     * Filter, which clinic_history to fetch.
     */
    where: clinic_historyWhereUniqueInput
  }

  /**
   * clinic_history findUniqueOrThrow
   */
  export type clinic_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_history
     */
    select?: clinic_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_history
     */
    omit?: clinic_historyOmit<ExtArgs> | null
    /**
     * Filter, which clinic_history to fetch.
     */
    where: clinic_historyWhereUniqueInput
  }

  /**
   * clinic_history findFirst
   */
  export type clinic_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_history
     */
    select?: clinic_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_history
     */
    omit?: clinic_historyOmit<ExtArgs> | null
    /**
     * Filter, which clinic_history to fetch.
     */
    where?: clinic_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_histories to fetch.
     */
    orderBy?: clinic_historyOrderByWithRelationInput | clinic_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinic_histories.
     */
    cursor?: clinic_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinic_histories.
     */
    distinct?: Clinic_historyScalarFieldEnum | Clinic_historyScalarFieldEnum[]
  }

  /**
   * clinic_history findFirstOrThrow
   */
  export type clinic_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_history
     */
    select?: clinic_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_history
     */
    omit?: clinic_historyOmit<ExtArgs> | null
    /**
     * Filter, which clinic_history to fetch.
     */
    where?: clinic_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_histories to fetch.
     */
    orderBy?: clinic_historyOrderByWithRelationInput | clinic_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinic_histories.
     */
    cursor?: clinic_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinic_histories.
     */
    distinct?: Clinic_historyScalarFieldEnum | Clinic_historyScalarFieldEnum[]
  }

  /**
   * clinic_history findMany
   */
  export type clinic_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_history
     */
    select?: clinic_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_history
     */
    omit?: clinic_historyOmit<ExtArgs> | null
    /**
     * Filter, which clinic_histories to fetch.
     */
    where?: clinic_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_histories to fetch.
     */
    orderBy?: clinic_historyOrderByWithRelationInput | clinic_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clinic_histories.
     */
    cursor?: clinic_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_histories.
     */
    skip?: number
    distinct?: Clinic_historyScalarFieldEnum | Clinic_historyScalarFieldEnum[]
  }

  /**
   * clinic_history create
   */
  export type clinic_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_history
     */
    select?: clinic_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_history
     */
    omit?: clinic_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a clinic_history.
     */
    data: XOR<clinic_historyCreateInput, clinic_historyUncheckedCreateInput>
  }

  /**
   * clinic_history createMany
   */
  export type clinic_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clinic_histories.
     */
    data: clinic_historyCreateManyInput | clinic_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clinic_history update
   */
  export type clinic_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_history
     */
    select?: clinic_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_history
     */
    omit?: clinic_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a clinic_history.
     */
    data: XOR<clinic_historyUpdateInput, clinic_historyUncheckedUpdateInput>
    /**
     * Choose, which clinic_history to update.
     */
    where: clinic_historyWhereUniqueInput
  }

  /**
   * clinic_history updateMany
   */
  export type clinic_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clinic_histories.
     */
    data: XOR<clinic_historyUpdateManyMutationInput, clinic_historyUncheckedUpdateManyInput>
    /**
     * Filter which clinic_histories to update
     */
    where?: clinic_historyWhereInput
    /**
     * Limit how many clinic_histories to update.
     */
    limit?: number
  }

  /**
   * clinic_history upsert
   */
  export type clinic_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_history
     */
    select?: clinic_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_history
     */
    omit?: clinic_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the clinic_history to update in case it exists.
     */
    where: clinic_historyWhereUniqueInput
    /**
     * In case the clinic_history found by the `where` argument doesn't exist, create a new clinic_history with this data.
     */
    create: XOR<clinic_historyCreateInput, clinic_historyUncheckedCreateInput>
    /**
     * In case the clinic_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clinic_historyUpdateInput, clinic_historyUncheckedUpdateInput>
  }

  /**
   * clinic_history delete
   */
  export type clinic_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_history
     */
    select?: clinic_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_history
     */
    omit?: clinic_historyOmit<ExtArgs> | null
    /**
     * Filter which clinic_history to delete.
     */
    where: clinic_historyWhereUniqueInput
  }

  /**
   * clinic_history deleteMany
   */
  export type clinic_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinic_histories to delete
     */
    where?: clinic_historyWhereInput
    /**
     * Limit how many clinic_histories to delete.
     */
    limit?: number
  }

  /**
   * clinic_history without action
   */
  export type clinic_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_history
     */
    select?: clinic_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_history
     */
    omit?: clinic_historyOmit<ExtArgs> | null
  }


  /**
   * Model countries
   */

  export type AggregateCountries = {
    _count: CountriesCountAggregateOutputType | null
    _avg: CountriesAvgAggregateOutputType | null
    _sum: CountriesSumAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  export type CountriesAvgAggregateOutputType = {
    id: number | null
  }

  export type CountriesSumAggregateOutputType = {
    id: number | null
  }

  export type CountriesMinAggregateOutputType = {
    id: number | null
    countryCode: string | null
    countryName: string | null
    currencyCode: string | null
    fipsCode: string | null
    isoNumeric: string | null
    north: string | null
    south: string | null
    east: string | null
    west: string | null
    capital: string | null
    continentName: string | null
    continent: string | null
    languages: string | null
  }

  export type CountriesMaxAggregateOutputType = {
    id: number | null
    countryCode: string | null
    countryName: string | null
    currencyCode: string | null
    fipsCode: string | null
    isoNumeric: string | null
    north: string | null
    south: string | null
    east: string | null
    west: string | null
    capital: string | null
    continentName: string | null
    continent: string | null
    languages: string | null
  }

  export type CountriesCountAggregateOutputType = {
    id: number
    countryCode: number
    countryName: number
    currencyCode: number
    fipsCode: number
    isoNumeric: number
    north: number
    south: number
    east: number
    west: number
    capital: number
    continentName: number
    continent: number
    languages: number
    _all: number
  }


  export type CountriesAvgAggregateInputType = {
    id?: true
  }

  export type CountriesSumAggregateInputType = {
    id?: true
  }

  export type CountriesMinAggregateInputType = {
    id?: true
    countryCode?: true
    countryName?: true
    currencyCode?: true
    fipsCode?: true
    isoNumeric?: true
    north?: true
    south?: true
    east?: true
    west?: true
    capital?: true
    continentName?: true
    continent?: true
    languages?: true
  }

  export type CountriesMaxAggregateInputType = {
    id?: true
    countryCode?: true
    countryName?: true
    currencyCode?: true
    fipsCode?: true
    isoNumeric?: true
    north?: true
    south?: true
    east?: true
    west?: true
    capital?: true
    continentName?: true
    continent?: true
    languages?: true
  }

  export type CountriesCountAggregateInputType = {
    id?: true
    countryCode?: true
    countryName?: true
    currencyCode?: true
    fipsCode?: true
    isoNumeric?: true
    north?: true
    south?: true
    east?: true
    west?: true
    capital?: true
    continentName?: true
    continent?: true
    languages?: true
    _all?: true
  }

  export type CountriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which countries to aggregate.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countriesOrderByWithRelationInput | countriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned countries
    **/
    _count?: true | CountriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountriesMaxAggregateInputType
  }

  export type GetCountriesAggregateType<T extends CountriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCountries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountries[P]>
      : GetScalarType<T[P], AggregateCountries[P]>
  }




  export type countriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: countriesWhereInput
    orderBy?: countriesOrderByWithAggregationInput | countriesOrderByWithAggregationInput[]
    by: CountriesScalarFieldEnum[] | CountriesScalarFieldEnum
    having?: countriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountriesCountAggregateInputType | true
    _avg?: CountriesAvgAggregateInputType
    _sum?: CountriesSumAggregateInputType
    _min?: CountriesMinAggregateInputType
    _max?: CountriesMaxAggregateInputType
  }

  export type CountriesGroupByOutputType = {
    id: number
    countryCode: string
    countryName: string
    currencyCode: string | null
    fipsCode: string | null
    isoNumeric: string | null
    north: string | null
    south: string | null
    east: string | null
    west: string | null
    capital: string | null
    continentName: string | null
    continent: string | null
    languages: string | null
    _count: CountriesCountAggregateOutputType | null
    _avg: CountriesAvgAggregateOutputType | null
    _sum: CountriesSumAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  type GetCountriesGroupByPayload<T extends countriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountriesGroupByOutputType[P]>
            : GetScalarType<T[P], CountriesGroupByOutputType[P]>
        }
      >
    >


  export type countriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryCode?: boolean
    countryName?: boolean
    currencyCode?: boolean
    fipsCode?: boolean
    isoNumeric?: boolean
    north?: boolean
    south?: boolean
    east?: boolean
    west?: boolean
    capital?: boolean
    continentName?: boolean
    continent?: boolean
    languages?: boolean
  }, ExtArgs["result"]["countries"]>



  export type countriesSelectScalar = {
    id?: boolean
    countryCode?: boolean
    countryName?: boolean
    currencyCode?: boolean
    fipsCode?: boolean
    isoNumeric?: boolean
    north?: boolean
    south?: boolean
    east?: boolean
    west?: boolean
    capital?: boolean
    continentName?: boolean
    continent?: boolean
    languages?: boolean
  }

  export type countriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "countryCode" | "countryName" | "currencyCode" | "fipsCode" | "isoNumeric" | "north" | "south" | "east" | "west" | "capital" | "continentName" | "continent" | "languages", ExtArgs["result"]["countries"]>

  export type $countriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "countries"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      countryCode: string
      countryName: string
      currencyCode: string | null
      fipsCode: string | null
      isoNumeric: string | null
      north: string | null
      south: string | null
      east: string | null
      west: string | null
      capital: string | null
      continentName: string | null
      continent: string | null
      languages: string | null
    }, ExtArgs["result"]["countries"]>
    composites: {}
  }

  type countriesGetPayload<S extends boolean | null | undefined | countriesDefaultArgs> = $Result.GetResult<Prisma.$countriesPayload, S>

  type countriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<countriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountriesCountAggregateInputType | true
    }

  export interface countriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['countries'], meta: { name: 'countries' } }
    /**
     * Find zero or one Countries that matches the filter.
     * @param {countriesFindUniqueArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends countriesFindUniqueArgs>(args: SelectSubset<T, countriesFindUniqueArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Countries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {countriesFindUniqueOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends countriesFindUniqueOrThrowArgs>(args: SelectSubset<T, countriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindFirstArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends countriesFindFirstArgs>(args?: SelectSubset<T, countriesFindFirstArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Countries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindFirstOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends countriesFindFirstOrThrowArgs>(args?: SelectSubset<T, countriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.countries.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.countries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countriesWithIdOnly = await prisma.countries.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends countriesFindManyArgs>(args?: SelectSubset<T, countriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Countries.
     * @param {countriesCreateArgs} args - Arguments to create a Countries.
     * @example
     * // Create one Countries
     * const Countries = await prisma.countries.create({
     *   data: {
     *     // ... data to create a Countries
     *   }
     * })
     * 
     */
    create<T extends countriesCreateArgs>(args: SelectSubset<T, countriesCreateArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {countriesCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const countries = await prisma.countries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends countriesCreateManyArgs>(args?: SelectSubset<T, countriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Countries.
     * @param {countriesDeleteArgs} args - Arguments to delete one Countries.
     * @example
     * // Delete one Countries
     * const Countries = await prisma.countries.delete({
     *   where: {
     *     // ... filter to delete one Countries
     *   }
     * })
     * 
     */
    delete<T extends countriesDeleteArgs>(args: SelectSubset<T, countriesDeleteArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Countries.
     * @param {countriesUpdateArgs} args - Arguments to update one Countries.
     * @example
     * // Update one Countries
     * const countries = await prisma.countries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends countriesUpdateArgs>(args: SelectSubset<T, countriesUpdateArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {countriesDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.countries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends countriesDeleteManyArgs>(args?: SelectSubset<T, countriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const countries = await prisma.countries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends countriesUpdateManyArgs>(args: SelectSubset<T, countriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Countries.
     * @param {countriesUpsertArgs} args - Arguments to update or create a Countries.
     * @example
     * // Update or create a Countries
     * const countries = await prisma.countries.upsert({
     *   create: {
     *     // ... data to create a Countries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Countries we want to update
     *   }
     * })
     */
    upsert<T extends countriesUpsertArgs>(args: SelectSubset<T, countriesUpsertArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.countries.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends countriesCountArgs>(
      args?: Subset<T, countriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountriesAggregateArgs>(args: Subset<T, CountriesAggregateArgs>): Prisma.PrismaPromise<GetCountriesAggregateType<T>>

    /**
     * Group by Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends countriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: countriesGroupByArgs['orderBy'] }
        : { orderBy?: countriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, countriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the countries model
   */
  readonly fields: countriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for countries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__countriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the countries model
   */
  interface countriesFieldRefs {
    readonly id: FieldRef<"countries", 'Int'>
    readonly countryCode: FieldRef<"countries", 'String'>
    readonly countryName: FieldRef<"countries", 'String'>
    readonly currencyCode: FieldRef<"countries", 'String'>
    readonly fipsCode: FieldRef<"countries", 'String'>
    readonly isoNumeric: FieldRef<"countries", 'String'>
    readonly north: FieldRef<"countries", 'String'>
    readonly south: FieldRef<"countries", 'String'>
    readonly east: FieldRef<"countries", 'String'>
    readonly west: FieldRef<"countries", 'String'>
    readonly capital: FieldRef<"countries", 'String'>
    readonly continentName: FieldRef<"countries", 'String'>
    readonly continent: FieldRef<"countries", 'String'>
    readonly languages: FieldRef<"countries", 'String'>
  }
    

  // Custom InputTypes
  /**
   * countries findUnique
   */
  export type countriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where: countriesWhereUniqueInput
  }

  /**
   * countries findUniqueOrThrow
   */
  export type countriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where: countriesWhereUniqueInput
  }

  /**
   * countries findFirst
   */
  export type countriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countriesOrderByWithRelationInput | countriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }

  /**
   * countries findFirstOrThrow
   */
  export type countriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countriesOrderByWithRelationInput | countriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }

  /**
   * countries findMany
   */
  export type countriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countriesOrderByWithRelationInput | countriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing countries.
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }

  /**
   * countries create
   */
  export type countriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * The data needed to create a countries.
     */
    data?: XOR<countriesCreateInput, countriesUncheckedCreateInput>
  }

  /**
   * countries createMany
   */
  export type countriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many countries.
     */
    data: countriesCreateManyInput | countriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * countries update
   */
  export type countriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * The data needed to update a countries.
     */
    data: XOR<countriesUpdateInput, countriesUncheckedUpdateInput>
    /**
     * Choose, which countries to update.
     */
    where: countriesWhereUniqueInput
  }

  /**
   * countries updateMany
   */
  export type countriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update countries.
     */
    data: XOR<countriesUpdateManyMutationInput, countriesUncheckedUpdateManyInput>
    /**
     * Filter which countries to update
     */
    where?: countriesWhereInput
    /**
     * Limit how many countries to update.
     */
    limit?: number
  }

  /**
   * countries upsert
   */
  export type countriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * The filter to search for the countries to update in case it exists.
     */
    where: countriesWhereUniqueInput
    /**
     * In case the countries found by the `where` argument doesn't exist, create a new countries with this data.
     */
    create: XOR<countriesCreateInput, countriesUncheckedCreateInput>
    /**
     * In case the countries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<countriesUpdateInput, countriesUncheckedUpdateInput>
  }

  /**
   * countries delete
   */
  export type countriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * Filter which countries to delete.
     */
    where: countriesWhereUniqueInput
  }

  /**
   * countries deleteMany
   */
  export type countriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which countries to delete
     */
    where?: countriesWhereInput
    /**
     * Limit how many countries to delete.
     */
    limit?: number
  }

  /**
   * countries without action
   */
  export type countriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
  }


  /**
   * Model enrolledactivity
   */

  export type AggregateEnrolledactivity = {
    _count: EnrolledactivityCountAggregateOutputType | null
    _avg: EnrolledactivityAvgAggregateOutputType | null
    _sum: EnrolledactivitySumAggregateOutputType | null
    _min: EnrolledactivityMinAggregateOutputType | null
    _max: EnrolledactivityMaxAggregateOutputType | null
  }

  export type EnrolledactivityAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    activityId: number | null
  }

  export type EnrolledactivitySumAggregateOutputType = {
    id: number | null
    userId: number | null
    activityId: number | null
  }

  export type EnrolledactivityMinAggregateOutputType = {
    id: number | null
    userId: number | null
    activityId: number | null
    enrollmentDate: Date | null
  }

  export type EnrolledactivityMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    activityId: number | null
    enrollmentDate: Date | null
  }

  export type EnrolledactivityCountAggregateOutputType = {
    id: number
    userId: number
    activityId: number
    enrollmentDate: number
    _all: number
  }


  export type EnrolledactivityAvgAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
  }

  export type EnrolledactivitySumAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
  }

  export type EnrolledactivityMinAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
    enrollmentDate?: true
  }

  export type EnrolledactivityMaxAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
    enrollmentDate?: true
  }

  export type EnrolledactivityCountAggregateInputType = {
    id?: true
    userId?: true
    activityId?: true
    enrollmentDate?: true
    _all?: true
  }

  export type EnrolledactivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which enrolledactivity to aggregate.
     */
    where?: enrolledactivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrolledactivities to fetch.
     */
    orderBy?: enrolledactivityOrderByWithRelationInput | enrolledactivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: enrolledactivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrolledactivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrolledactivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned enrolledactivities
    **/
    _count?: true | EnrolledactivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnrolledactivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnrolledactivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrolledactivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrolledactivityMaxAggregateInputType
  }

  export type GetEnrolledactivityAggregateType<T extends EnrolledactivityAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrolledactivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrolledactivity[P]>
      : GetScalarType<T[P], AggregateEnrolledactivity[P]>
  }




  export type enrolledactivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrolledactivityWhereInput
    orderBy?: enrolledactivityOrderByWithAggregationInput | enrolledactivityOrderByWithAggregationInput[]
    by: EnrolledactivityScalarFieldEnum[] | EnrolledactivityScalarFieldEnum
    having?: enrolledactivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrolledactivityCountAggregateInputType | true
    _avg?: EnrolledactivityAvgAggregateInputType
    _sum?: EnrolledactivitySumAggregateInputType
    _min?: EnrolledactivityMinAggregateInputType
    _max?: EnrolledactivityMaxAggregateInputType
  }

  export type EnrolledactivityGroupByOutputType = {
    id: number
    userId: number
    activityId: number
    enrollmentDate: Date
    _count: EnrolledactivityCountAggregateOutputType | null
    _avg: EnrolledactivityAvgAggregateOutputType | null
    _sum: EnrolledactivitySumAggregateOutputType | null
    _min: EnrolledactivityMinAggregateOutputType | null
    _max: EnrolledactivityMaxAggregateOutputType | null
  }

  type GetEnrolledactivityGroupByPayload<T extends enrolledactivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrolledactivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrolledactivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrolledactivityGroupByOutputType[P]>
            : GetScalarType<T[P], EnrolledactivityGroupByOutputType[P]>
        }
      >
    >


  export type enrolledactivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activityId?: boolean
    enrollmentDate?: boolean
    afterschoolactivity?: boolean | afterschoolactivityDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrolledactivity"]>



  export type enrolledactivitySelectScalar = {
    id?: boolean
    userId?: boolean
    activityId?: boolean
    enrollmentDate?: boolean
  }

  export type enrolledactivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "activityId" | "enrollmentDate", ExtArgs["result"]["enrolledactivity"]>
  export type enrolledactivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    afterschoolactivity?: boolean | afterschoolactivityDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $enrolledactivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "enrolledactivity"
    objects: {
      afterschoolactivity: Prisma.$afterschoolactivityPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      activityId: number
      enrollmentDate: Date
    }, ExtArgs["result"]["enrolledactivity"]>
    composites: {}
  }

  type enrolledactivityGetPayload<S extends boolean | null | undefined | enrolledactivityDefaultArgs> = $Result.GetResult<Prisma.$enrolledactivityPayload, S>

  type enrolledactivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<enrolledactivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrolledactivityCountAggregateInputType | true
    }

  export interface enrolledactivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['enrolledactivity'], meta: { name: 'enrolledactivity' } }
    /**
     * Find zero or one Enrolledactivity that matches the filter.
     * @param {enrolledactivityFindUniqueArgs} args - Arguments to find a Enrolledactivity
     * @example
     * // Get one Enrolledactivity
     * const enrolledactivity = await prisma.enrolledactivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends enrolledactivityFindUniqueArgs>(args: SelectSubset<T, enrolledactivityFindUniqueArgs<ExtArgs>>): Prisma__enrolledactivityClient<$Result.GetResult<Prisma.$enrolledactivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrolledactivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {enrolledactivityFindUniqueOrThrowArgs} args - Arguments to find a Enrolledactivity
     * @example
     * // Get one Enrolledactivity
     * const enrolledactivity = await prisma.enrolledactivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends enrolledactivityFindUniqueOrThrowArgs>(args: SelectSubset<T, enrolledactivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__enrolledactivityClient<$Result.GetResult<Prisma.$enrolledactivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrolledactivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrolledactivityFindFirstArgs} args - Arguments to find a Enrolledactivity
     * @example
     * // Get one Enrolledactivity
     * const enrolledactivity = await prisma.enrolledactivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends enrolledactivityFindFirstArgs>(args?: SelectSubset<T, enrolledactivityFindFirstArgs<ExtArgs>>): Prisma__enrolledactivityClient<$Result.GetResult<Prisma.$enrolledactivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrolledactivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrolledactivityFindFirstOrThrowArgs} args - Arguments to find a Enrolledactivity
     * @example
     * // Get one Enrolledactivity
     * const enrolledactivity = await prisma.enrolledactivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends enrolledactivityFindFirstOrThrowArgs>(args?: SelectSubset<T, enrolledactivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__enrolledactivityClient<$Result.GetResult<Prisma.$enrolledactivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrolledactivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrolledactivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrolledactivities
     * const enrolledactivities = await prisma.enrolledactivity.findMany()
     * 
     * // Get first 10 Enrolledactivities
     * const enrolledactivities = await prisma.enrolledactivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrolledactivityWithIdOnly = await prisma.enrolledactivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends enrolledactivityFindManyArgs>(args?: SelectSubset<T, enrolledactivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrolledactivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrolledactivity.
     * @param {enrolledactivityCreateArgs} args - Arguments to create a Enrolledactivity.
     * @example
     * // Create one Enrolledactivity
     * const Enrolledactivity = await prisma.enrolledactivity.create({
     *   data: {
     *     // ... data to create a Enrolledactivity
     *   }
     * })
     * 
     */
    create<T extends enrolledactivityCreateArgs>(args: SelectSubset<T, enrolledactivityCreateArgs<ExtArgs>>): Prisma__enrolledactivityClient<$Result.GetResult<Prisma.$enrolledactivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrolledactivities.
     * @param {enrolledactivityCreateManyArgs} args - Arguments to create many Enrolledactivities.
     * @example
     * // Create many Enrolledactivities
     * const enrolledactivity = await prisma.enrolledactivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends enrolledactivityCreateManyArgs>(args?: SelectSubset<T, enrolledactivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enrolledactivity.
     * @param {enrolledactivityDeleteArgs} args - Arguments to delete one Enrolledactivity.
     * @example
     * // Delete one Enrolledactivity
     * const Enrolledactivity = await prisma.enrolledactivity.delete({
     *   where: {
     *     // ... filter to delete one Enrolledactivity
     *   }
     * })
     * 
     */
    delete<T extends enrolledactivityDeleteArgs>(args: SelectSubset<T, enrolledactivityDeleteArgs<ExtArgs>>): Prisma__enrolledactivityClient<$Result.GetResult<Prisma.$enrolledactivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrolledactivity.
     * @param {enrolledactivityUpdateArgs} args - Arguments to update one Enrolledactivity.
     * @example
     * // Update one Enrolledactivity
     * const enrolledactivity = await prisma.enrolledactivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends enrolledactivityUpdateArgs>(args: SelectSubset<T, enrolledactivityUpdateArgs<ExtArgs>>): Prisma__enrolledactivityClient<$Result.GetResult<Prisma.$enrolledactivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrolledactivities.
     * @param {enrolledactivityDeleteManyArgs} args - Arguments to filter Enrolledactivities to delete.
     * @example
     * // Delete a few Enrolledactivities
     * const { count } = await prisma.enrolledactivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends enrolledactivityDeleteManyArgs>(args?: SelectSubset<T, enrolledactivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrolledactivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrolledactivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrolledactivities
     * const enrolledactivity = await prisma.enrolledactivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends enrolledactivityUpdateManyArgs>(args: SelectSubset<T, enrolledactivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enrolledactivity.
     * @param {enrolledactivityUpsertArgs} args - Arguments to update or create a Enrolledactivity.
     * @example
     * // Update or create a Enrolledactivity
     * const enrolledactivity = await prisma.enrolledactivity.upsert({
     *   create: {
     *     // ... data to create a Enrolledactivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrolledactivity we want to update
     *   }
     * })
     */
    upsert<T extends enrolledactivityUpsertArgs>(args: SelectSubset<T, enrolledactivityUpsertArgs<ExtArgs>>): Prisma__enrolledactivityClient<$Result.GetResult<Prisma.$enrolledactivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enrolledactivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrolledactivityCountArgs} args - Arguments to filter Enrolledactivities to count.
     * @example
     * // Count the number of Enrolledactivities
     * const count = await prisma.enrolledactivity.count({
     *   where: {
     *     // ... the filter for the Enrolledactivities we want to count
     *   }
     * })
    **/
    count<T extends enrolledactivityCountArgs>(
      args?: Subset<T, enrolledactivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrolledactivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrolledactivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrolledactivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrolledactivityAggregateArgs>(args: Subset<T, EnrolledactivityAggregateArgs>): Prisma.PrismaPromise<GetEnrolledactivityAggregateType<T>>

    /**
     * Group by Enrolledactivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrolledactivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends enrolledactivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: enrolledactivityGroupByArgs['orderBy'] }
        : { orderBy?: enrolledactivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, enrolledactivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrolledactivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the enrolledactivity model
   */
  readonly fields: enrolledactivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for enrolledactivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__enrolledactivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    afterschoolactivity<T extends afterschoolactivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, afterschoolactivityDefaultArgs<ExtArgs>>): Prisma__afterschoolactivityClient<$Result.GetResult<Prisma.$afterschoolactivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the enrolledactivity model
   */
  interface enrolledactivityFieldRefs {
    readonly id: FieldRef<"enrolledactivity", 'Int'>
    readonly userId: FieldRef<"enrolledactivity", 'Int'>
    readonly activityId: FieldRef<"enrolledactivity", 'Int'>
    readonly enrollmentDate: FieldRef<"enrolledactivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * enrolledactivity findUnique
   */
  export type enrolledactivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrolledactivity
     */
    select?: enrolledactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrolledactivity
     */
    omit?: enrolledactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrolledactivityInclude<ExtArgs> | null
    /**
     * Filter, which enrolledactivity to fetch.
     */
    where: enrolledactivityWhereUniqueInput
  }

  /**
   * enrolledactivity findUniqueOrThrow
   */
  export type enrolledactivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrolledactivity
     */
    select?: enrolledactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrolledactivity
     */
    omit?: enrolledactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrolledactivityInclude<ExtArgs> | null
    /**
     * Filter, which enrolledactivity to fetch.
     */
    where: enrolledactivityWhereUniqueInput
  }

  /**
   * enrolledactivity findFirst
   */
  export type enrolledactivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrolledactivity
     */
    select?: enrolledactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrolledactivity
     */
    omit?: enrolledactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrolledactivityInclude<ExtArgs> | null
    /**
     * Filter, which enrolledactivity to fetch.
     */
    where?: enrolledactivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrolledactivities to fetch.
     */
    orderBy?: enrolledactivityOrderByWithRelationInput | enrolledactivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enrolledactivities.
     */
    cursor?: enrolledactivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrolledactivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrolledactivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enrolledactivities.
     */
    distinct?: EnrolledactivityScalarFieldEnum | EnrolledactivityScalarFieldEnum[]
  }

  /**
   * enrolledactivity findFirstOrThrow
   */
  export type enrolledactivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrolledactivity
     */
    select?: enrolledactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrolledactivity
     */
    omit?: enrolledactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrolledactivityInclude<ExtArgs> | null
    /**
     * Filter, which enrolledactivity to fetch.
     */
    where?: enrolledactivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrolledactivities to fetch.
     */
    orderBy?: enrolledactivityOrderByWithRelationInput | enrolledactivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enrolledactivities.
     */
    cursor?: enrolledactivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrolledactivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrolledactivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enrolledactivities.
     */
    distinct?: EnrolledactivityScalarFieldEnum | EnrolledactivityScalarFieldEnum[]
  }

  /**
   * enrolledactivity findMany
   */
  export type enrolledactivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrolledactivity
     */
    select?: enrolledactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrolledactivity
     */
    omit?: enrolledactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrolledactivityInclude<ExtArgs> | null
    /**
     * Filter, which enrolledactivities to fetch.
     */
    where?: enrolledactivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrolledactivities to fetch.
     */
    orderBy?: enrolledactivityOrderByWithRelationInput | enrolledactivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing enrolledactivities.
     */
    cursor?: enrolledactivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrolledactivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrolledactivities.
     */
    skip?: number
    distinct?: EnrolledactivityScalarFieldEnum | EnrolledactivityScalarFieldEnum[]
  }

  /**
   * enrolledactivity create
   */
  export type enrolledactivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrolledactivity
     */
    select?: enrolledactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrolledactivity
     */
    omit?: enrolledactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrolledactivityInclude<ExtArgs> | null
    /**
     * The data needed to create a enrolledactivity.
     */
    data: XOR<enrolledactivityCreateInput, enrolledactivityUncheckedCreateInput>
  }

  /**
   * enrolledactivity createMany
   */
  export type enrolledactivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many enrolledactivities.
     */
    data: enrolledactivityCreateManyInput | enrolledactivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * enrolledactivity update
   */
  export type enrolledactivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrolledactivity
     */
    select?: enrolledactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrolledactivity
     */
    omit?: enrolledactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrolledactivityInclude<ExtArgs> | null
    /**
     * The data needed to update a enrolledactivity.
     */
    data: XOR<enrolledactivityUpdateInput, enrolledactivityUncheckedUpdateInput>
    /**
     * Choose, which enrolledactivity to update.
     */
    where: enrolledactivityWhereUniqueInput
  }

  /**
   * enrolledactivity updateMany
   */
  export type enrolledactivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update enrolledactivities.
     */
    data: XOR<enrolledactivityUpdateManyMutationInput, enrolledactivityUncheckedUpdateManyInput>
    /**
     * Filter which enrolledactivities to update
     */
    where?: enrolledactivityWhereInput
    /**
     * Limit how many enrolledactivities to update.
     */
    limit?: number
  }

  /**
   * enrolledactivity upsert
   */
  export type enrolledactivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrolledactivity
     */
    select?: enrolledactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrolledactivity
     */
    omit?: enrolledactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrolledactivityInclude<ExtArgs> | null
    /**
     * The filter to search for the enrolledactivity to update in case it exists.
     */
    where: enrolledactivityWhereUniqueInput
    /**
     * In case the enrolledactivity found by the `where` argument doesn't exist, create a new enrolledactivity with this data.
     */
    create: XOR<enrolledactivityCreateInput, enrolledactivityUncheckedCreateInput>
    /**
     * In case the enrolledactivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<enrolledactivityUpdateInput, enrolledactivityUncheckedUpdateInput>
  }

  /**
   * enrolledactivity delete
   */
  export type enrolledactivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrolledactivity
     */
    select?: enrolledactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrolledactivity
     */
    omit?: enrolledactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrolledactivityInclude<ExtArgs> | null
    /**
     * Filter which enrolledactivity to delete.
     */
    where: enrolledactivityWhereUniqueInput
  }

  /**
   * enrolledactivity deleteMany
   */
  export type enrolledactivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which enrolledactivities to delete
     */
    where?: enrolledactivityWhereInput
    /**
     * Limit how many enrolledactivities to delete.
     */
    limit?: number
  }

  /**
   * enrolledactivity without action
   */
  export type enrolledactivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrolledactivity
     */
    select?: enrolledactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrolledactivity
     */
    omit?: enrolledactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrolledactivityInclude<ExtArgs> | null
  }


  /**
   * Model inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    id: number | null
  }

  export type InventorySumAggregateOutputType = {
    id: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: number | null
    empno: string | null
    description: string | null
    serial: string | null
    dateout: Date | null
    datein: Date | null
    issuedby: string | null
    remarks: string | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: number | null
    empno: string | null
    description: string | null
    serial: string | null
    dateout: Date | null
    datein: Date | null
    issuedby: string | null
    remarks: string | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    empno: number
    description: number
    serial: number
    dateout: number
    datein: number
    issuedby: number
    remarks: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    id?: true
  }

  export type InventorySumAggregateInputType = {
    id?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    empno?: true
    description?: true
    serial?: true
    dateout?: true
    datein?: true
    issuedby?: true
    remarks?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    empno?: true
    description?: true
    serial?: true
    dateout?: true
    datein?: true
    issuedby?: true
    remarks?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    empno?: true
    description?: true
    serial?: true
    dateout?: true
    datein?: true
    issuedby?: true
    remarks?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventory to aggregate.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type inventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventoryWhereInput
    orderBy?: inventoryOrderByWithAggregationInput | inventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: inventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: number
    empno: string
    description: string
    serial: string
    dateout: Date
    datein: Date
    issuedby: string
    remarks: string
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends inventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type inventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empno?: boolean
    description?: boolean
    serial?: boolean
    dateout?: boolean
    datein?: boolean
    issuedby?: boolean
    remarks?: boolean
  }, ExtArgs["result"]["inventory"]>



  export type inventorySelectScalar = {
    id?: boolean
    empno?: boolean
    description?: boolean
    serial?: boolean
    dateout?: boolean
    datein?: boolean
    issuedby?: boolean
    remarks?: boolean
  }

  export type inventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "empno" | "description" | "serial" | "dateout" | "datein" | "issuedby" | "remarks", ExtArgs["result"]["inventory"]>

  export type $inventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inventory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      empno: string
      description: string
      serial: string
      dateout: Date
      datein: Date
      issuedby: string
      remarks: string
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type inventoryGetPayload<S extends boolean | null | undefined | inventoryDefaultArgs> = $Result.GetResult<Prisma.$inventoryPayload, S>

  type inventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<inventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface inventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inventory'], meta: { name: 'inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {inventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inventoryFindUniqueArgs>(args: SelectSubset<T, inventoryFindUniqueArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {inventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, inventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inventoryFindFirstArgs>(args?: SelectSubset<T, inventoryFindFirstArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, inventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends inventoryFindManyArgs>(args?: SelectSubset<T, inventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {inventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends inventoryCreateArgs>(args: SelectSubset<T, inventoryCreateArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {inventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inventoryCreateManyArgs>(args?: SelectSubset<T, inventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {inventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends inventoryDeleteArgs>(args: SelectSubset<T, inventoryDeleteArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {inventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inventoryUpdateArgs>(args: SelectSubset<T, inventoryUpdateArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {inventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inventoryDeleteManyArgs>(args?: SelectSubset<T, inventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inventoryUpdateManyArgs>(args: SelectSubset<T, inventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {inventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends inventoryUpsertArgs>(args: SelectSubset<T, inventoryUpsertArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends inventoryCountArgs>(
      args?: Subset<T, inventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inventoryGroupByArgs['orderBy'] }
        : { orderBy?: inventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inventory model
   */
  readonly fields: inventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inventory model
   */
  interface inventoryFieldRefs {
    readonly id: FieldRef<"inventory", 'Int'>
    readonly empno: FieldRef<"inventory", 'String'>
    readonly description: FieldRef<"inventory", 'String'>
    readonly serial: FieldRef<"inventory", 'String'>
    readonly dateout: FieldRef<"inventory", 'DateTime'>
    readonly datein: FieldRef<"inventory", 'DateTime'>
    readonly issuedby: FieldRef<"inventory", 'String'>
    readonly remarks: FieldRef<"inventory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * inventory findUnique
   */
  export type inventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory findUniqueOrThrow
   */
  export type inventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory findFirst
   */
  export type inventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * inventory findFirstOrThrow
   */
  export type inventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * inventory findMany
   */
  export type inventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Filter, which inventories to fetch.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventories.
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * inventory create
   */
  export type inventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * The data needed to create a inventory.
     */
    data: XOR<inventoryCreateInput, inventoryUncheckedCreateInput>
  }

  /**
   * inventory createMany
   */
  export type inventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inventories.
     */
    data: inventoryCreateManyInput | inventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inventory update
   */
  export type inventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * The data needed to update a inventory.
     */
    data: XOR<inventoryUpdateInput, inventoryUncheckedUpdateInput>
    /**
     * Choose, which inventory to update.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory updateMany
   */
  export type inventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inventories.
     */
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyInput>
    /**
     * Filter which inventories to update
     */
    where?: inventoryWhereInput
    /**
     * Limit how many inventories to update.
     */
    limit?: number
  }

  /**
   * inventory upsert
   */
  export type inventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * The filter to search for the inventory to update in case it exists.
     */
    where: inventoryWhereUniqueInput
    /**
     * In case the inventory found by the `where` argument doesn't exist, create a new inventory with this data.
     */
    create: XOR<inventoryCreateInput, inventoryUncheckedCreateInput>
    /**
     * In case the inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inventoryUpdateInput, inventoryUncheckedUpdateInput>
  }

  /**
   * inventory delete
   */
  export type inventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
    /**
     * Filter which inventory to delete.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory deleteMany
   */
  export type inventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventories to delete
     */
    where?: inventoryWhereInput
    /**
     * Limit how many inventories to delete.
     */
    limit?: number
  }

  /**
   * inventory without action
   */
  export type inventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory
     */
    omit?: inventoryOmit<ExtArgs> | null
  }


  /**
   * Model inventory__suppliers
   */

  export type AggregateInventory__suppliers = {
    _count: Inventory__suppliersCountAggregateOutputType | null
    _avg: Inventory__suppliersAvgAggregateOutputType | null
    _sum: Inventory__suppliersSumAggregateOutputType | null
    _min: Inventory__suppliersMinAggregateOutputType | null
    _max: Inventory__suppliersMaxAggregateOutputType | null
  }

  export type Inventory__suppliersAvgAggregateOutputType = {
    id: number | null
    rating: Decimal | null
  }

  export type Inventory__suppliersSumAggregateOutputType = {
    id: number | null
    rating: Decimal | null
  }

  export type Inventory__suppliersMinAggregateOutputType = {
    id: number | null
    companyName: string | null
    itemsProvided: string | null
    address: string | null
    phoneNumber: string | null
    email: string | null
    rating: Decimal | null
  }

  export type Inventory__suppliersMaxAggregateOutputType = {
    id: number | null
    companyName: string | null
    itemsProvided: string | null
    address: string | null
    phoneNumber: string | null
    email: string | null
    rating: Decimal | null
  }

  export type Inventory__suppliersCountAggregateOutputType = {
    id: number
    companyName: number
    itemsProvided: number
    address: number
    phoneNumber: number
    email: number
    rating: number
    _all: number
  }


  export type Inventory__suppliersAvgAggregateInputType = {
    id?: true
    rating?: true
  }

  export type Inventory__suppliersSumAggregateInputType = {
    id?: true
    rating?: true
  }

  export type Inventory__suppliersMinAggregateInputType = {
    id?: true
    companyName?: true
    itemsProvided?: true
    address?: true
    phoneNumber?: true
    email?: true
    rating?: true
  }

  export type Inventory__suppliersMaxAggregateInputType = {
    id?: true
    companyName?: true
    itemsProvided?: true
    address?: true
    phoneNumber?: true
    email?: true
    rating?: true
  }

  export type Inventory__suppliersCountAggregateInputType = {
    id?: true
    companyName?: true
    itemsProvided?: true
    address?: true
    phoneNumber?: true
    email?: true
    rating?: true
    _all?: true
  }

  export type Inventory__suppliersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventory__suppliers to aggregate.
     */
    where?: inventory__suppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventory__suppliers to fetch.
     */
    orderBy?: inventory__suppliersOrderByWithRelationInput | inventory__suppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inventory__suppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventory__suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventory__suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventory__suppliers
    **/
    _count?: true | Inventory__suppliersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inventory__suppliersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inventory__suppliersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inventory__suppliersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inventory__suppliersMaxAggregateInputType
  }

  export type GetInventory__suppliersAggregateType<T extends Inventory__suppliersAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory__suppliers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory__suppliers[P]>
      : GetScalarType<T[P], AggregateInventory__suppliers[P]>
  }




  export type inventory__suppliersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventory__suppliersWhereInput
    orderBy?: inventory__suppliersOrderByWithAggregationInput | inventory__suppliersOrderByWithAggregationInput[]
    by: Inventory__suppliersScalarFieldEnum[] | Inventory__suppliersScalarFieldEnum
    having?: inventory__suppliersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inventory__suppliersCountAggregateInputType | true
    _avg?: Inventory__suppliersAvgAggregateInputType
    _sum?: Inventory__suppliersSumAggregateInputType
    _min?: Inventory__suppliersMinAggregateInputType
    _max?: Inventory__suppliersMaxAggregateInputType
  }

  export type Inventory__suppliersGroupByOutputType = {
    id: number
    companyName: string
    itemsProvided: string | null
    address: string | null
    phoneNumber: string | null
    email: string | null
    rating: Decimal | null
    _count: Inventory__suppliersCountAggregateOutputType | null
    _avg: Inventory__suppliersAvgAggregateOutputType | null
    _sum: Inventory__suppliersSumAggregateOutputType | null
    _min: Inventory__suppliersMinAggregateOutputType | null
    _max: Inventory__suppliersMaxAggregateOutputType | null
  }

  type GetInventory__suppliersGroupByPayload<T extends inventory__suppliersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inventory__suppliersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inventory__suppliersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inventory__suppliersGroupByOutputType[P]>
            : GetScalarType<T[P], Inventory__suppliersGroupByOutputType[P]>
        }
      >
    >


  export type inventory__suppliersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    itemsProvided?: boolean
    address?: boolean
    phoneNumber?: boolean
    email?: boolean
    rating?: boolean
  }, ExtArgs["result"]["inventory__suppliers"]>



  export type inventory__suppliersSelectScalar = {
    id?: boolean
    companyName?: boolean
    itemsProvided?: boolean
    address?: boolean
    phoneNumber?: boolean
    email?: boolean
    rating?: boolean
  }

  export type inventory__suppliersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "itemsProvided" | "address" | "phoneNumber" | "email" | "rating", ExtArgs["result"]["inventory__suppliers"]>

  export type $inventory__suppliersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inventory__suppliers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyName: string
      itemsProvided: string | null
      address: string | null
      phoneNumber: string | null
      email: string | null
      rating: Prisma.Decimal | null
    }, ExtArgs["result"]["inventory__suppliers"]>
    composites: {}
  }

  type inventory__suppliersGetPayload<S extends boolean | null | undefined | inventory__suppliersDefaultArgs> = $Result.GetResult<Prisma.$inventory__suppliersPayload, S>

  type inventory__suppliersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<inventory__suppliersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Inventory__suppliersCountAggregateInputType | true
    }

  export interface inventory__suppliersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inventory__suppliers'], meta: { name: 'inventory__suppliers' } }
    /**
     * Find zero or one Inventory__suppliers that matches the filter.
     * @param {inventory__suppliersFindUniqueArgs} args - Arguments to find a Inventory__suppliers
     * @example
     * // Get one Inventory__suppliers
     * const inventory__suppliers = await prisma.inventory__suppliers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inventory__suppliersFindUniqueArgs>(args: SelectSubset<T, inventory__suppliersFindUniqueArgs<ExtArgs>>): Prisma__inventory__suppliersClient<$Result.GetResult<Prisma.$inventory__suppliersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory__suppliers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {inventory__suppliersFindUniqueOrThrowArgs} args - Arguments to find a Inventory__suppliers
     * @example
     * // Get one Inventory__suppliers
     * const inventory__suppliers = await prisma.inventory__suppliers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inventory__suppliersFindUniqueOrThrowArgs>(args: SelectSubset<T, inventory__suppliersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inventory__suppliersClient<$Result.GetResult<Prisma.$inventory__suppliersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory__suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory__suppliersFindFirstArgs} args - Arguments to find a Inventory__suppliers
     * @example
     * // Get one Inventory__suppliers
     * const inventory__suppliers = await prisma.inventory__suppliers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inventory__suppliersFindFirstArgs>(args?: SelectSubset<T, inventory__suppliersFindFirstArgs<ExtArgs>>): Prisma__inventory__suppliersClient<$Result.GetResult<Prisma.$inventory__suppliersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory__suppliers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory__suppliersFindFirstOrThrowArgs} args - Arguments to find a Inventory__suppliers
     * @example
     * // Get one Inventory__suppliers
     * const inventory__suppliers = await prisma.inventory__suppliers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inventory__suppliersFindFirstOrThrowArgs>(args?: SelectSubset<T, inventory__suppliersFindFirstOrThrowArgs<ExtArgs>>): Prisma__inventory__suppliersClient<$Result.GetResult<Prisma.$inventory__suppliersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventory__suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory__suppliersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventory__suppliers
     * const inventory__suppliers = await prisma.inventory__suppliers.findMany()
     * 
     * // Get first 10 Inventory__suppliers
     * const inventory__suppliers = await prisma.inventory__suppliers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventory__suppliersWithIdOnly = await prisma.inventory__suppliers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends inventory__suppliersFindManyArgs>(args?: SelectSubset<T, inventory__suppliersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventory__suppliersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory__suppliers.
     * @param {inventory__suppliersCreateArgs} args - Arguments to create a Inventory__suppliers.
     * @example
     * // Create one Inventory__suppliers
     * const Inventory__suppliers = await prisma.inventory__suppliers.create({
     *   data: {
     *     // ... data to create a Inventory__suppliers
     *   }
     * })
     * 
     */
    create<T extends inventory__suppliersCreateArgs>(args: SelectSubset<T, inventory__suppliersCreateArgs<ExtArgs>>): Prisma__inventory__suppliersClient<$Result.GetResult<Prisma.$inventory__suppliersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventory__suppliers.
     * @param {inventory__suppliersCreateManyArgs} args - Arguments to create many Inventory__suppliers.
     * @example
     * // Create many Inventory__suppliers
     * const inventory__suppliers = await prisma.inventory__suppliers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inventory__suppliersCreateManyArgs>(args?: SelectSubset<T, inventory__suppliersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory__suppliers.
     * @param {inventory__suppliersDeleteArgs} args - Arguments to delete one Inventory__suppliers.
     * @example
     * // Delete one Inventory__suppliers
     * const Inventory__suppliers = await prisma.inventory__suppliers.delete({
     *   where: {
     *     // ... filter to delete one Inventory__suppliers
     *   }
     * })
     * 
     */
    delete<T extends inventory__suppliersDeleteArgs>(args: SelectSubset<T, inventory__suppliersDeleteArgs<ExtArgs>>): Prisma__inventory__suppliersClient<$Result.GetResult<Prisma.$inventory__suppliersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory__suppliers.
     * @param {inventory__suppliersUpdateArgs} args - Arguments to update one Inventory__suppliers.
     * @example
     * // Update one Inventory__suppliers
     * const inventory__suppliers = await prisma.inventory__suppliers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inventory__suppliersUpdateArgs>(args: SelectSubset<T, inventory__suppliersUpdateArgs<ExtArgs>>): Prisma__inventory__suppliersClient<$Result.GetResult<Prisma.$inventory__suppliersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventory__suppliers.
     * @param {inventory__suppliersDeleteManyArgs} args - Arguments to filter Inventory__suppliers to delete.
     * @example
     * // Delete a few Inventory__suppliers
     * const { count } = await prisma.inventory__suppliers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inventory__suppliersDeleteManyArgs>(args?: SelectSubset<T, inventory__suppliersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventory__suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory__suppliersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventory__suppliers
     * const inventory__suppliers = await prisma.inventory__suppliers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inventory__suppliersUpdateManyArgs>(args: SelectSubset<T, inventory__suppliersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory__suppliers.
     * @param {inventory__suppliersUpsertArgs} args - Arguments to update or create a Inventory__suppliers.
     * @example
     * // Update or create a Inventory__suppliers
     * const inventory__suppliers = await prisma.inventory__suppliers.upsert({
     *   create: {
     *     // ... data to create a Inventory__suppliers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory__suppliers we want to update
     *   }
     * })
     */
    upsert<T extends inventory__suppliersUpsertArgs>(args: SelectSubset<T, inventory__suppliersUpsertArgs<ExtArgs>>): Prisma__inventory__suppliersClient<$Result.GetResult<Prisma.$inventory__suppliersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventory__suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory__suppliersCountArgs} args - Arguments to filter Inventory__suppliers to count.
     * @example
     * // Count the number of Inventory__suppliers
     * const count = await prisma.inventory__suppliers.count({
     *   where: {
     *     // ... the filter for the Inventory__suppliers we want to count
     *   }
     * })
    **/
    count<T extends inventory__suppliersCountArgs>(
      args?: Subset<T, inventory__suppliersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inventory__suppliersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory__suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inventory__suppliersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inventory__suppliersAggregateArgs>(args: Subset<T, Inventory__suppliersAggregateArgs>): Prisma.PrismaPromise<GetInventory__suppliersAggregateType<T>>

    /**
     * Group by Inventory__suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory__suppliersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inventory__suppliersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inventory__suppliersGroupByArgs['orderBy'] }
        : { orderBy?: inventory__suppliersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inventory__suppliersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventory__suppliersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inventory__suppliers model
   */
  readonly fields: inventory__suppliersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inventory__suppliers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inventory__suppliersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inventory__suppliers model
   */
  interface inventory__suppliersFieldRefs {
    readonly id: FieldRef<"inventory__suppliers", 'Int'>
    readonly companyName: FieldRef<"inventory__suppliers", 'String'>
    readonly itemsProvided: FieldRef<"inventory__suppliers", 'String'>
    readonly address: FieldRef<"inventory__suppliers", 'String'>
    readonly phoneNumber: FieldRef<"inventory__suppliers", 'String'>
    readonly email: FieldRef<"inventory__suppliers", 'String'>
    readonly rating: FieldRef<"inventory__suppliers", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * inventory__suppliers findUnique
   */
  export type inventory__suppliersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory__suppliers
     */
    select?: inventory__suppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory__suppliers
     */
    omit?: inventory__suppliersOmit<ExtArgs> | null
    /**
     * Filter, which inventory__suppliers to fetch.
     */
    where: inventory__suppliersWhereUniqueInput
  }

  /**
   * inventory__suppliers findUniqueOrThrow
   */
  export type inventory__suppliersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory__suppliers
     */
    select?: inventory__suppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory__suppliers
     */
    omit?: inventory__suppliersOmit<ExtArgs> | null
    /**
     * Filter, which inventory__suppliers to fetch.
     */
    where: inventory__suppliersWhereUniqueInput
  }

  /**
   * inventory__suppliers findFirst
   */
  export type inventory__suppliersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory__suppliers
     */
    select?: inventory__suppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory__suppliers
     */
    omit?: inventory__suppliersOmit<ExtArgs> | null
    /**
     * Filter, which inventory__suppliers to fetch.
     */
    where?: inventory__suppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventory__suppliers to fetch.
     */
    orderBy?: inventory__suppliersOrderByWithRelationInput | inventory__suppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventory__suppliers.
     */
    cursor?: inventory__suppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventory__suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventory__suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventory__suppliers.
     */
    distinct?: Inventory__suppliersScalarFieldEnum | Inventory__suppliersScalarFieldEnum[]
  }

  /**
   * inventory__suppliers findFirstOrThrow
   */
  export type inventory__suppliersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory__suppliers
     */
    select?: inventory__suppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory__suppliers
     */
    omit?: inventory__suppliersOmit<ExtArgs> | null
    /**
     * Filter, which inventory__suppliers to fetch.
     */
    where?: inventory__suppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventory__suppliers to fetch.
     */
    orderBy?: inventory__suppliersOrderByWithRelationInput | inventory__suppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventory__suppliers.
     */
    cursor?: inventory__suppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventory__suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventory__suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventory__suppliers.
     */
    distinct?: Inventory__suppliersScalarFieldEnum | Inventory__suppliersScalarFieldEnum[]
  }

  /**
   * inventory__suppliers findMany
   */
  export type inventory__suppliersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory__suppliers
     */
    select?: inventory__suppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory__suppliers
     */
    omit?: inventory__suppliersOmit<ExtArgs> | null
    /**
     * Filter, which inventory__suppliers to fetch.
     */
    where?: inventory__suppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventory__suppliers to fetch.
     */
    orderBy?: inventory__suppliersOrderByWithRelationInput | inventory__suppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventory__suppliers.
     */
    cursor?: inventory__suppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventory__suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventory__suppliers.
     */
    skip?: number
    distinct?: Inventory__suppliersScalarFieldEnum | Inventory__suppliersScalarFieldEnum[]
  }

  /**
   * inventory__suppliers create
   */
  export type inventory__suppliersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory__suppliers
     */
    select?: inventory__suppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory__suppliers
     */
    omit?: inventory__suppliersOmit<ExtArgs> | null
    /**
     * The data needed to create a inventory__suppliers.
     */
    data: XOR<inventory__suppliersCreateInput, inventory__suppliersUncheckedCreateInput>
  }

  /**
   * inventory__suppliers createMany
   */
  export type inventory__suppliersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inventory__suppliers.
     */
    data: inventory__suppliersCreateManyInput | inventory__suppliersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inventory__suppliers update
   */
  export type inventory__suppliersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory__suppliers
     */
    select?: inventory__suppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory__suppliers
     */
    omit?: inventory__suppliersOmit<ExtArgs> | null
    /**
     * The data needed to update a inventory__suppliers.
     */
    data: XOR<inventory__suppliersUpdateInput, inventory__suppliersUncheckedUpdateInput>
    /**
     * Choose, which inventory__suppliers to update.
     */
    where: inventory__suppliersWhereUniqueInput
  }

  /**
   * inventory__suppliers updateMany
   */
  export type inventory__suppliersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inventory__suppliers.
     */
    data: XOR<inventory__suppliersUpdateManyMutationInput, inventory__suppliersUncheckedUpdateManyInput>
    /**
     * Filter which inventory__suppliers to update
     */
    where?: inventory__suppliersWhereInput
    /**
     * Limit how many inventory__suppliers to update.
     */
    limit?: number
  }

  /**
   * inventory__suppliers upsert
   */
  export type inventory__suppliersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory__suppliers
     */
    select?: inventory__suppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory__suppliers
     */
    omit?: inventory__suppliersOmit<ExtArgs> | null
    /**
     * The filter to search for the inventory__suppliers to update in case it exists.
     */
    where: inventory__suppliersWhereUniqueInput
    /**
     * In case the inventory__suppliers found by the `where` argument doesn't exist, create a new inventory__suppliers with this data.
     */
    create: XOR<inventory__suppliersCreateInput, inventory__suppliersUncheckedCreateInput>
    /**
     * In case the inventory__suppliers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inventory__suppliersUpdateInput, inventory__suppliersUncheckedUpdateInput>
  }

  /**
   * inventory__suppliers delete
   */
  export type inventory__suppliersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory__suppliers
     */
    select?: inventory__suppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory__suppliers
     */
    omit?: inventory__suppliersOmit<ExtArgs> | null
    /**
     * Filter which inventory__suppliers to delete.
     */
    where: inventory__suppliersWhereUniqueInput
  }

  /**
   * inventory__suppliers deleteMany
   */
  export type inventory__suppliersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventory__suppliers to delete
     */
    where?: inventory__suppliersWhereInput
    /**
     * Limit how many inventory__suppliers to delete.
     */
    limit?: number
  }

  /**
   * inventory__suppliers without action
   */
  export type inventory__suppliersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory__suppliers
     */
    select?: inventory__suppliersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory__suppliers
     */
    omit?: inventory__suppliersOmit<ExtArgs> | null
  }


  /**
   * Model inventory_bookstore
   */

  export type AggregateInventory_bookstore = {
    _count: Inventory_bookstoreCountAggregateOutputType | null
    _avg: Inventory_bookstoreAvgAggregateOutputType | null
    _sum: Inventory_bookstoreSumAggregateOutputType | null
    _min: Inventory_bookstoreMinAggregateOutputType | null
    _max: Inventory_bookstoreMaxAggregateOutputType | null
  }

  export type Inventory_bookstoreAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    selling_price: number | null
  }

  export type Inventory_bookstoreSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    selling_price: number | null
  }

  export type Inventory_bookstoreMinAggregateOutputType = {
    id: number | null
    product_name: string | null
    quantity: number | null
    selling_price: number | null
    date: Date | null
  }

  export type Inventory_bookstoreMaxAggregateOutputType = {
    id: number | null
    product_name: string | null
    quantity: number | null
    selling_price: number | null
    date: Date | null
  }

  export type Inventory_bookstoreCountAggregateOutputType = {
    id: number
    product_name: number
    quantity: number
    selling_price: number
    date: number
    _all: number
  }


  export type Inventory_bookstoreAvgAggregateInputType = {
    id?: true
    quantity?: true
    selling_price?: true
  }

  export type Inventory_bookstoreSumAggregateInputType = {
    id?: true
    quantity?: true
    selling_price?: true
  }

  export type Inventory_bookstoreMinAggregateInputType = {
    id?: true
    product_name?: true
    quantity?: true
    selling_price?: true
    date?: true
  }

  export type Inventory_bookstoreMaxAggregateInputType = {
    id?: true
    product_name?: true
    quantity?: true
    selling_price?: true
    date?: true
  }

  export type Inventory_bookstoreCountAggregateInputType = {
    id?: true
    product_name?: true
    quantity?: true
    selling_price?: true
    date?: true
    _all?: true
  }

  export type Inventory_bookstoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventory_bookstore to aggregate.
     */
    where?: inventory_bookstoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventory_bookstores to fetch.
     */
    orderBy?: inventory_bookstoreOrderByWithRelationInput | inventory_bookstoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inventory_bookstoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventory_bookstores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventory_bookstores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventory_bookstores
    **/
    _count?: true | Inventory_bookstoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inventory_bookstoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inventory_bookstoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inventory_bookstoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inventory_bookstoreMaxAggregateInputType
  }

  export type GetInventory_bookstoreAggregateType<T extends Inventory_bookstoreAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory_bookstore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory_bookstore[P]>
      : GetScalarType<T[P], AggregateInventory_bookstore[P]>
  }




  export type inventory_bookstoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventory_bookstoreWhereInput
    orderBy?: inventory_bookstoreOrderByWithAggregationInput | inventory_bookstoreOrderByWithAggregationInput[]
    by: Inventory_bookstoreScalarFieldEnum[] | Inventory_bookstoreScalarFieldEnum
    having?: inventory_bookstoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inventory_bookstoreCountAggregateInputType | true
    _avg?: Inventory_bookstoreAvgAggregateInputType
    _sum?: Inventory_bookstoreSumAggregateInputType
    _min?: Inventory_bookstoreMinAggregateInputType
    _max?: Inventory_bookstoreMaxAggregateInputType
  }

  export type Inventory_bookstoreGroupByOutputType = {
    id: number
    product_name: string
    quantity: number
    selling_price: number
    date: Date
    _count: Inventory_bookstoreCountAggregateOutputType | null
    _avg: Inventory_bookstoreAvgAggregateOutputType | null
    _sum: Inventory_bookstoreSumAggregateOutputType | null
    _min: Inventory_bookstoreMinAggregateOutputType | null
    _max: Inventory_bookstoreMaxAggregateOutputType | null
  }

  type GetInventory_bookstoreGroupByPayload<T extends inventory_bookstoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inventory_bookstoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inventory_bookstoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inventory_bookstoreGroupByOutputType[P]>
            : GetScalarType<T[P], Inventory_bookstoreGroupByOutputType[P]>
        }
      >
    >


  export type inventory_bookstoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_name?: boolean
    quantity?: boolean
    selling_price?: boolean
    date?: boolean
  }, ExtArgs["result"]["inventory_bookstore"]>



  export type inventory_bookstoreSelectScalar = {
    id?: boolean
    product_name?: boolean
    quantity?: boolean
    selling_price?: boolean
    date?: boolean
  }

  export type inventory_bookstoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "product_name" | "quantity" | "selling_price" | "date", ExtArgs["result"]["inventory_bookstore"]>

  export type $inventory_bookstorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inventory_bookstore"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      product_name: string
      quantity: number
      selling_price: number
      date: Date
    }, ExtArgs["result"]["inventory_bookstore"]>
    composites: {}
  }

  type inventory_bookstoreGetPayload<S extends boolean | null | undefined | inventory_bookstoreDefaultArgs> = $Result.GetResult<Prisma.$inventory_bookstorePayload, S>

  type inventory_bookstoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<inventory_bookstoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Inventory_bookstoreCountAggregateInputType | true
    }

  export interface inventory_bookstoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inventory_bookstore'], meta: { name: 'inventory_bookstore' } }
    /**
     * Find zero or one Inventory_bookstore that matches the filter.
     * @param {inventory_bookstoreFindUniqueArgs} args - Arguments to find a Inventory_bookstore
     * @example
     * // Get one Inventory_bookstore
     * const inventory_bookstore = await prisma.inventory_bookstore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inventory_bookstoreFindUniqueArgs>(args: SelectSubset<T, inventory_bookstoreFindUniqueArgs<ExtArgs>>): Prisma__inventory_bookstoreClient<$Result.GetResult<Prisma.$inventory_bookstorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory_bookstore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {inventory_bookstoreFindUniqueOrThrowArgs} args - Arguments to find a Inventory_bookstore
     * @example
     * // Get one Inventory_bookstore
     * const inventory_bookstore = await prisma.inventory_bookstore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inventory_bookstoreFindUniqueOrThrowArgs>(args: SelectSubset<T, inventory_bookstoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inventory_bookstoreClient<$Result.GetResult<Prisma.$inventory_bookstorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory_bookstore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory_bookstoreFindFirstArgs} args - Arguments to find a Inventory_bookstore
     * @example
     * // Get one Inventory_bookstore
     * const inventory_bookstore = await prisma.inventory_bookstore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inventory_bookstoreFindFirstArgs>(args?: SelectSubset<T, inventory_bookstoreFindFirstArgs<ExtArgs>>): Prisma__inventory_bookstoreClient<$Result.GetResult<Prisma.$inventory_bookstorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory_bookstore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory_bookstoreFindFirstOrThrowArgs} args - Arguments to find a Inventory_bookstore
     * @example
     * // Get one Inventory_bookstore
     * const inventory_bookstore = await prisma.inventory_bookstore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inventory_bookstoreFindFirstOrThrowArgs>(args?: SelectSubset<T, inventory_bookstoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__inventory_bookstoreClient<$Result.GetResult<Prisma.$inventory_bookstorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventory_bookstores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory_bookstoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventory_bookstores
     * const inventory_bookstores = await prisma.inventory_bookstore.findMany()
     * 
     * // Get first 10 Inventory_bookstores
     * const inventory_bookstores = await prisma.inventory_bookstore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventory_bookstoreWithIdOnly = await prisma.inventory_bookstore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends inventory_bookstoreFindManyArgs>(args?: SelectSubset<T, inventory_bookstoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventory_bookstorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory_bookstore.
     * @param {inventory_bookstoreCreateArgs} args - Arguments to create a Inventory_bookstore.
     * @example
     * // Create one Inventory_bookstore
     * const Inventory_bookstore = await prisma.inventory_bookstore.create({
     *   data: {
     *     // ... data to create a Inventory_bookstore
     *   }
     * })
     * 
     */
    create<T extends inventory_bookstoreCreateArgs>(args: SelectSubset<T, inventory_bookstoreCreateArgs<ExtArgs>>): Prisma__inventory_bookstoreClient<$Result.GetResult<Prisma.$inventory_bookstorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventory_bookstores.
     * @param {inventory_bookstoreCreateManyArgs} args - Arguments to create many Inventory_bookstores.
     * @example
     * // Create many Inventory_bookstores
     * const inventory_bookstore = await prisma.inventory_bookstore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inventory_bookstoreCreateManyArgs>(args?: SelectSubset<T, inventory_bookstoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory_bookstore.
     * @param {inventory_bookstoreDeleteArgs} args - Arguments to delete one Inventory_bookstore.
     * @example
     * // Delete one Inventory_bookstore
     * const Inventory_bookstore = await prisma.inventory_bookstore.delete({
     *   where: {
     *     // ... filter to delete one Inventory_bookstore
     *   }
     * })
     * 
     */
    delete<T extends inventory_bookstoreDeleteArgs>(args: SelectSubset<T, inventory_bookstoreDeleteArgs<ExtArgs>>): Prisma__inventory_bookstoreClient<$Result.GetResult<Prisma.$inventory_bookstorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory_bookstore.
     * @param {inventory_bookstoreUpdateArgs} args - Arguments to update one Inventory_bookstore.
     * @example
     * // Update one Inventory_bookstore
     * const inventory_bookstore = await prisma.inventory_bookstore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inventory_bookstoreUpdateArgs>(args: SelectSubset<T, inventory_bookstoreUpdateArgs<ExtArgs>>): Prisma__inventory_bookstoreClient<$Result.GetResult<Prisma.$inventory_bookstorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventory_bookstores.
     * @param {inventory_bookstoreDeleteManyArgs} args - Arguments to filter Inventory_bookstores to delete.
     * @example
     * // Delete a few Inventory_bookstores
     * const { count } = await prisma.inventory_bookstore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inventory_bookstoreDeleteManyArgs>(args?: SelectSubset<T, inventory_bookstoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventory_bookstores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory_bookstoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventory_bookstores
     * const inventory_bookstore = await prisma.inventory_bookstore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inventory_bookstoreUpdateManyArgs>(args: SelectSubset<T, inventory_bookstoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory_bookstore.
     * @param {inventory_bookstoreUpsertArgs} args - Arguments to update or create a Inventory_bookstore.
     * @example
     * // Update or create a Inventory_bookstore
     * const inventory_bookstore = await prisma.inventory_bookstore.upsert({
     *   create: {
     *     // ... data to create a Inventory_bookstore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory_bookstore we want to update
     *   }
     * })
     */
    upsert<T extends inventory_bookstoreUpsertArgs>(args: SelectSubset<T, inventory_bookstoreUpsertArgs<ExtArgs>>): Prisma__inventory_bookstoreClient<$Result.GetResult<Prisma.$inventory_bookstorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventory_bookstores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory_bookstoreCountArgs} args - Arguments to filter Inventory_bookstores to count.
     * @example
     * // Count the number of Inventory_bookstores
     * const count = await prisma.inventory_bookstore.count({
     *   where: {
     *     // ... the filter for the Inventory_bookstores we want to count
     *   }
     * })
    **/
    count<T extends inventory_bookstoreCountArgs>(
      args?: Subset<T, inventory_bookstoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inventory_bookstoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory_bookstore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inventory_bookstoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inventory_bookstoreAggregateArgs>(args: Subset<T, Inventory_bookstoreAggregateArgs>): Prisma.PrismaPromise<GetInventory_bookstoreAggregateType<T>>

    /**
     * Group by Inventory_bookstore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory_bookstoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inventory_bookstoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inventory_bookstoreGroupByArgs['orderBy'] }
        : { orderBy?: inventory_bookstoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inventory_bookstoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventory_bookstoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inventory_bookstore model
   */
  readonly fields: inventory_bookstoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inventory_bookstore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inventory_bookstoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inventory_bookstore model
   */
  interface inventory_bookstoreFieldRefs {
    readonly id: FieldRef<"inventory_bookstore", 'Int'>
    readonly product_name: FieldRef<"inventory_bookstore", 'String'>
    readonly quantity: FieldRef<"inventory_bookstore", 'Int'>
    readonly selling_price: FieldRef<"inventory_bookstore", 'Float'>
    readonly date: FieldRef<"inventory_bookstore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * inventory_bookstore findUnique
   */
  export type inventory_bookstoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_bookstore
     */
    select?: inventory_bookstoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory_bookstore
     */
    omit?: inventory_bookstoreOmit<ExtArgs> | null
    /**
     * Filter, which inventory_bookstore to fetch.
     */
    where: inventory_bookstoreWhereUniqueInput
  }

  /**
   * inventory_bookstore findUniqueOrThrow
   */
  export type inventory_bookstoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_bookstore
     */
    select?: inventory_bookstoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory_bookstore
     */
    omit?: inventory_bookstoreOmit<ExtArgs> | null
    /**
     * Filter, which inventory_bookstore to fetch.
     */
    where: inventory_bookstoreWhereUniqueInput
  }

  /**
   * inventory_bookstore findFirst
   */
  export type inventory_bookstoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_bookstore
     */
    select?: inventory_bookstoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory_bookstore
     */
    omit?: inventory_bookstoreOmit<ExtArgs> | null
    /**
     * Filter, which inventory_bookstore to fetch.
     */
    where?: inventory_bookstoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventory_bookstores to fetch.
     */
    orderBy?: inventory_bookstoreOrderByWithRelationInput | inventory_bookstoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventory_bookstores.
     */
    cursor?: inventory_bookstoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventory_bookstores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventory_bookstores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventory_bookstores.
     */
    distinct?: Inventory_bookstoreScalarFieldEnum | Inventory_bookstoreScalarFieldEnum[]
  }

  /**
   * inventory_bookstore findFirstOrThrow
   */
  export type inventory_bookstoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_bookstore
     */
    select?: inventory_bookstoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory_bookstore
     */
    omit?: inventory_bookstoreOmit<ExtArgs> | null
    /**
     * Filter, which inventory_bookstore to fetch.
     */
    where?: inventory_bookstoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventory_bookstores to fetch.
     */
    orderBy?: inventory_bookstoreOrderByWithRelationInput | inventory_bookstoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventory_bookstores.
     */
    cursor?: inventory_bookstoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventory_bookstores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventory_bookstores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventory_bookstores.
     */
    distinct?: Inventory_bookstoreScalarFieldEnum | Inventory_bookstoreScalarFieldEnum[]
  }

  /**
   * inventory_bookstore findMany
   */
  export type inventory_bookstoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_bookstore
     */
    select?: inventory_bookstoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory_bookstore
     */
    omit?: inventory_bookstoreOmit<ExtArgs> | null
    /**
     * Filter, which inventory_bookstores to fetch.
     */
    where?: inventory_bookstoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventory_bookstores to fetch.
     */
    orderBy?: inventory_bookstoreOrderByWithRelationInput | inventory_bookstoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventory_bookstores.
     */
    cursor?: inventory_bookstoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventory_bookstores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventory_bookstores.
     */
    skip?: number
    distinct?: Inventory_bookstoreScalarFieldEnum | Inventory_bookstoreScalarFieldEnum[]
  }

  /**
   * inventory_bookstore create
   */
  export type inventory_bookstoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_bookstore
     */
    select?: inventory_bookstoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory_bookstore
     */
    omit?: inventory_bookstoreOmit<ExtArgs> | null
    /**
     * The data needed to create a inventory_bookstore.
     */
    data: XOR<inventory_bookstoreCreateInput, inventory_bookstoreUncheckedCreateInput>
  }

  /**
   * inventory_bookstore createMany
   */
  export type inventory_bookstoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inventory_bookstores.
     */
    data: inventory_bookstoreCreateManyInput | inventory_bookstoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inventory_bookstore update
   */
  export type inventory_bookstoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_bookstore
     */
    select?: inventory_bookstoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory_bookstore
     */
    omit?: inventory_bookstoreOmit<ExtArgs> | null
    /**
     * The data needed to update a inventory_bookstore.
     */
    data: XOR<inventory_bookstoreUpdateInput, inventory_bookstoreUncheckedUpdateInput>
    /**
     * Choose, which inventory_bookstore to update.
     */
    where: inventory_bookstoreWhereUniqueInput
  }

  /**
   * inventory_bookstore updateMany
   */
  export type inventory_bookstoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inventory_bookstores.
     */
    data: XOR<inventory_bookstoreUpdateManyMutationInput, inventory_bookstoreUncheckedUpdateManyInput>
    /**
     * Filter which inventory_bookstores to update
     */
    where?: inventory_bookstoreWhereInput
    /**
     * Limit how many inventory_bookstores to update.
     */
    limit?: number
  }

  /**
   * inventory_bookstore upsert
   */
  export type inventory_bookstoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_bookstore
     */
    select?: inventory_bookstoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory_bookstore
     */
    omit?: inventory_bookstoreOmit<ExtArgs> | null
    /**
     * The filter to search for the inventory_bookstore to update in case it exists.
     */
    where: inventory_bookstoreWhereUniqueInput
    /**
     * In case the inventory_bookstore found by the `where` argument doesn't exist, create a new inventory_bookstore with this data.
     */
    create: XOR<inventory_bookstoreCreateInput, inventory_bookstoreUncheckedCreateInput>
    /**
     * In case the inventory_bookstore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inventory_bookstoreUpdateInput, inventory_bookstoreUncheckedUpdateInput>
  }

  /**
   * inventory_bookstore delete
   */
  export type inventory_bookstoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_bookstore
     */
    select?: inventory_bookstoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory_bookstore
     */
    omit?: inventory_bookstoreOmit<ExtArgs> | null
    /**
     * Filter which inventory_bookstore to delete.
     */
    where: inventory_bookstoreWhereUniqueInput
  }

  /**
   * inventory_bookstore deleteMany
   */
  export type inventory_bookstoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventory_bookstores to delete
     */
    where?: inventory_bookstoreWhereInput
    /**
     * Limit how many inventory_bookstores to delete.
     */
    limit?: number
  }

  /**
   * inventory_bookstore without action
   */
  export type inventory_bookstoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_bookstore
     */
    select?: inventory_bookstoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inventory_bookstore
     */
    omit?: inventory_bookstoreOmit<ExtArgs> | null
  }


  /**
   * Model library_login
   */

  export type AggregateLibrary_login = {
    _count: Library_loginCountAggregateOutputType | null
    _avg: Library_loginAvgAggregateOutputType | null
    _sum: Library_loginSumAggregateOutputType | null
    _min: Library_loginMinAggregateOutputType | null
    _max: Library_loginMaxAggregateOutputType | null
  }

  export type Library_loginAvgAggregateOutputType = {
    id: number | null
  }

  export type Library_loginSumAggregateOutputType = {
    id: number | null
  }

  export type Library_loginMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
  }

  export type Library_loginMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
  }

  export type Library_loginCountAggregateOutputType = {
    id: number
    username: number
    password: number
    _all: number
  }


  export type Library_loginAvgAggregateInputType = {
    id?: true
  }

  export type Library_loginSumAggregateInputType = {
    id?: true
  }

  export type Library_loginMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type Library_loginMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type Library_loginCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    _all?: true
  }

  export type Library_loginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which library_login to aggregate.
     */
    where?: library_loginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of library_logins to fetch.
     */
    orderBy?: library_loginOrderByWithRelationInput | library_loginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: library_loginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` library_logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` library_logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned library_logins
    **/
    _count?: true | Library_loginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Library_loginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Library_loginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Library_loginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Library_loginMaxAggregateInputType
  }

  export type GetLibrary_loginAggregateType<T extends Library_loginAggregateArgs> = {
        [P in keyof T & keyof AggregateLibrary_login]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibrary_login[P]>
      : GetScalarType<T[P], AggregateLibrary_login[P]>
  }




  export type library_loginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: library_loginWhereInput
    orderBy?: library_loginOrderByWithAggregationInput | library_loginOrderByWithAggregationInput[]
    by: Library_loginScalarFieldEnum[] | Library_loginScalarFieldEnum
    having?: library_loginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Library_loginCountAggregateInputType | true
    _avg?: Library_loginAvgAggregateInputType
    _sum?: Library_loginSumAggregateInputType
    _min?: Library_loginMinAggregateInputType
    _max?: Library_loginMaxAggregateInputType
  }

  export type Library_loginGroupByOutputType = {
    id: number
    username: string | null
    password: string | null
    _count: Library_loginCountAggregateOutputType | null
    _avg: Library_loginAvgAggregateOutputType | null
    _sum: Library_loginSumAggregateOutputType | null
    _min: Library_loginMinAggregateOutputType | null
    _max: Library_loginMaxAggregateOutputType | null
  }

  type GetLibrary_loginGroupByPayload<T extends library_loginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Library_loginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Library_loginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Library_loginGroupByOutputType[P]>
            : GetScalarType<T[P], Library_loginGroupByOutputType[P]>
        }
      >
    >


  export type library_loginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
  }, ExtArgs["result"]["library_login"]>



  export type library_loginSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
  }

  export type library_loginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password", ExtArgs["result"]["library_login"]>

  export type $library_loginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "library_login"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string | null
      password: string | null
    }, ExtArgs["result"]["library_login"]>
    composites: {}
  }

  type library_loginGetPayload<S extends boolean | null | undefined | library_loginDefaultArgs> = $Result.GetResult<Prisma.$library_loginPayload, S>

  type library_loginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<library_loginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Library_loginCountAggregateInputType | true
    }

  export interface library_loginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['library_login'], meta: { name: 'library_login' } }
    /**
     * Find zero or one Library_login that matches the filter.
     * @param {library_loginFindUniqueArgs} args - Arguments to find a Library_login
     * @example
     * // Get one Library_login
     * const library_login = await prisma.library_login.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends library_loginFindUniqueArgs>(args: SelectSubset<T, library_loginFindUniqueArgs<ExtArgs>>): Prisma__library_loginClient<$Result.GetResult<Prisma.$library_loginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Library_login that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {library_loginFindUniqueOrThrowArgs} args - Arguments to find a Library_login
     * @example
     * // Get one Library_login
     * const library_login = await prisma.library_login.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends library_loginFindUniqueOrThrowArgs>(args: SelectSubset<T, library_loginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__library_loginClient<$Result.GetResult<Prisma.$library_loginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Library_login that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {library_loginFindFirstArgs} args - Arguments to find a Library_login
     * @example
     * // Get one Library_login
     * const library_login = await prisma.library_login.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends library_loginFindFirstArgs>(args?: SelectSubset<T, library_loginFindFirstArgs<ExtArgs>>): Prisma__library_loginClient<$Result.GetResult<Prisma.$library_loginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Library_login that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {library_loginFindFirstOrThrowArgs} args - Arguments to find a Library_login
     * @example
     * // Get one Library_login
     * const library_login = await prisma.library_login.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends library_loginFindFirstOrThrowArgs>(args?: SelectSubset<T, library_loginFindFirstOrThrowArgs<ExtArgs>>): Prisma__library_loginClient<$Result.GetResult<Prisma.$library_loginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Library_logins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {library_loginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Library_logins
     * const library_logins = await prisma.library_login.findMany()
     * 
     * // Get first 10 Library_logins
     * const library_logins = await prisma.library_login.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const library_loginWithIdOnly = await prisma.library_login.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends library_loginFindManyArgs>(args?: SelectSubset<T, library_loginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$library_loginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Library_login.
     * @param {library_loginCreateArgs} args - Arguments to create a Library_login.
     * @example
     * // Create one Library_login
     * const Library_login = await prisma.library_login.create({
     *   data: {
     *     // ... data to create a Library_login
     *   }
     * })
     * 
     */
    create<T extends library_loginCreateArgs>(args: SelectSubset<T, library_loginCreateArgs<ExtArgs>>): Prisma__library_loginClient<$Result.GetResult<Prisma.$library_loginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Library_logins.
     * @param {library_loginCreateManyArgs} args - Arguments to create many Library_logins.
     * @example
     * // Create many Library_logins
     * const library_login = await prisma.library_login.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends library_loginCreateManyArgs>(args?: SelectSubset<T, library_loginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Library_login.
     * @param {library_loginDeleteArgs} args - Arguments to delete one Library_login.
     * @example
     * // Delete one Library_login
     * const Library_login = await prisma.library_login.delete({
     *   where: {
     *     // ... filter to delete one Library_login
     *   }
     * })
     * 
     */
    delete<T extends library_loginDeleteArgs>(args: SelectSubset<T, library_loginDeleteArgs<ExtArgs>>): Prisma__library_loginClient<$Result.GetResult<Prisma.$library_loginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Library_login.
     * @param {library_loginUpdateArgs} args - Arguments to update one Library_login.
     * @example
     * // Update one Library_login
     * const library_login = await prisma.library_login.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends library_loginUpdateArgs>(args: SelectSubset<T, library_loginUpdateArgs<ExtArgs>>): Prisma__library_loginClient<$Result.GetResult<Prisma.$library_loginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Library_logins.
     * @param {library_loginDeleteManyArgs} args - Arguments to filter Library_logins to delete.
     * @example
     * // Delete a few Library_logins
     * const { count } = await prisma.library_login.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends library_loginDeleteManyArgs>(args?: SelectSubset<T, library_loginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Library_logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {library_loginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Library_logins
     * const library_login = await prisma.library_login.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends library_loginUpdateManyArgs>(args: SelectSubset<T, library_loginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Library_login.
     * @param {library_loginUpsertArgs} args - Arguments to update or create a Library_login.
     * @example
     * // Update or create a Library_login
     * const library_login = await prisma.library_login.upsert({
     *   create: {
     *     // ... data to create a Library_login
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Library_login we want to update
     *   }
     * })
     */
    upsert<T extends library_loginUpsertArgs>(args: SelectSubset<T, library_loginUpsertArgs<ExtArgs>>): Prisma__library_loginClient<$Result.GetResult<Prisma.$library_loginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Library_logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {library_loginCountArgs} args - Arguments to filter Library_logins to count.
     * @example
     * // Count the number of Library_logins
     * const count = await prisma.library_login.count({
     *   where: {
     *     // ... the filter for the Library_logins we want to count
     *   }
     * })
    **/
    count<T extends library_loginCountArgs>(
      args?: Subset<T, library_loginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Library_loginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Library_login.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Library_loginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Library_loginAggregateArgs>(args: Subset<T, Library_loginAggregateArgs>): Prisma.PrismaPromise<GetLibrary_loginAggregateType<T>>

    /**
     * Group by Library_login.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {library_loginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends library_loginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: library_loginGroupByArgs['orderBy'] }
        : { orderBy?: library_loginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, library_loginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibrary_loginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the library_login model
   */
  readonly fields: library_loginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for library_login.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__library_loginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the library_login model
   */
  interface library_loginFieldRefs {
    readonly id: FieldRef<"library_login", 'Int'>
    readonly username: FieldRef<"library_login", 'String'>
    readonly password: FieldRef<"library_login", 'String'>
  }
    

  // Custom InputTypes
  /**
   * library_login findUnique
   */
  export type library_loginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the library_login
     */
    select?: library_loginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the library_login
     */
    omit?: library_loginOmit<ExtArgs> | null
    /**
     * Filter, which library_login to fetch.
     */
    where: library_loginWhereUniqueInput
  }

  /**
   * library_login findUniqueOrThrow
   */
  export type library_loginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the library_login
     */
    select?: library_loginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the library_login
     */
    omit?: library_loginOmit<ExtArgs> | null
    /**
     * Filter, which library_login to fetch.
     */
    where: library_loginWhereUniqueInput
  }

  /**
   * library_login findFirst
   */
  export type library_loginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the library_login
     */
    select?: library_loginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the library_login
     */
    omit?: library_loginOmit<ExtArgs> | null
    /**
     * Filter, which library_login to fetch.
     */
    where?: library_loginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of library_logins to fetch.
     */
    orderBy?: library_loginOrderByWithRelationInput | library_loginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for library_logins.
     */
    cursor?: library_loginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` library_logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` library_logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of library_logins.
     */
    distinct?: Library_loginScalarFieldEnum | Library_loginScalarFieldEnum[]
  }

  /**
   * library_login findFirstOrThrow
   */
  export type library_loginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the library_login
     */
    select?: library_loginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the library_login
     */
    omit?: library_loginOmit<ExtArgs> | null
    /**
     * Filter, which library_login to fetch.
     */
    where?: library_loginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of library_logins to fetch.
     */
    orderBy?: library_loginOrderByWithRelationInput | library_loginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for library_logins.
     */
    cursor?: library_loginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` library_logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` library_logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of library_logins.
     */
    distinct?: Library_loginScalarFieldEnum | Library_loginScalarFieldEnum[]
  }

  /**
   * library_login findMany
   */
  export type library_loginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the library_login
     */
    select?: library_loginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the library_login
     */
    omit?: library_loginOmit<ExtArgs> | null
    /**
     * Filter, which library_logins to fetch.
     */
    where?: library_loginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of library_logins to fetch.
     */
    orderBy?: library_loginOrderByWithRelationInput | library_loginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing library_logins.
     */
    cursor?: library_loginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` library_logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` library_logins.
     */
    skip?: number
    distinct?: Library_loginScalarFieldEnum | Library_loginScalarFieldEnum[]
  }

  /**
   * library_login create
   */
  export type library_loginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the library_login
     */
    select?: library_loginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the library_login
     */
    omit?: library_loginOmit<ExtArgs> | null
    /**
     * The data needed to create a library_login.
     */
    data?: XOR<library_loginCreateInput, library_loginUncheckedCreateInput>
  }

  /**
   * library_login createMany
   */
  export type library_loginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many library_logins.
     */
    data: library_loginCreateManyInput | library_loginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * library_login update
   */
  export type library_loginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the library_login
     */
    select?: library_loginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the library_login
     */
    omit?: library_loginOmit<ExtArgs> | null
    /**
     * The data needed to update a library_login.
     */
    data: XOR<library_loginUpdateInput, library_loginUncheckedUpdateInput>
    /**
     * Choose, which library_login to update.
     */
    where: library_loginWhereUniqueInput
  }

  /**
   * library_login updateMany
   */
  export type library_loginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update library_logins.
     */
    data: XOR<library_loginUpdateManyMutationInput, library_loginUncheckedUpdateManyInput>
    /**
     * Filter which library_logins to update
     */
    where?: library_loginWhereInput
    /**
     * Limit how many library_logins to update.
     */
    limit?: number
  }

  /**
   * library_login upsert
   */
  export type library_loginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the library_login
     */
    select?: library_loginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the library_login
     */
    omit?: library_loginOmit<ExtArgs> | null
    /**
     * The filter to search for the library_login to update in case it exists.
     */
    where: library_loginWhereUniqueInput
    /**
     * In case the library_login found by the `where` argument doesn't exist, create a new library_login with this data.
     */
    create: XOR<library_loginCreateInput, library_loginUncheckedCreateInput>
    /**
     * In case the library_login was found with the provided `where` argument, update it with this data.
     */
    update: XOR<library_loginUpdateInput, library_loginUncheckedUpdateInput>
  }

  /**
   * library_login delete
   */
  export type library_loginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the library_login
     */
    select?: library_loginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the library_login
     */
    omit?: library_loginOmit<ExtArgs> | null
    /**
     * Filter which library_login to delete.
     */
    where: library_loginWhereUniqueInput
  }

  /**
   * library_login deleteMany
   */
  export type library_loginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which library_logins to delete
     */
    where?: library_loginWhereInput
    /**
     * Limit how many library_logins to delete.
     */
    limit?: number
  }

  /**
   * library_login without action
   */
  export type library_loginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the library_login
     */
    select?: library_loginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the library_login
     */
    omit?: library_loginOmit<ExtArgs> | null
  }


  /**
   * Model logs_enroll
   */

  export type AggregateLogs_enroll = {
    _count: Logs_enrollCountAggregateOutputType | null
    _avg: Logs_enrollAvgAggregateOutputType | null
    _sum: Logs_enrollSumAggregateOutputType | null
    _min: Logs_enrollMinAggregateOutputType | null
    _max: Logs_enrollMaxAggregateOutputType | null
  }

  export type Logs_enrollAvgAggregateOutputType = {
    id: number | null
    stage: number | null
  }

  export type Logs_enrollSumAggregateOutputType = {
    id: number | null
    stage: number | null
  }

  export type Logs_enrollMinAggregateOutputType = {
    id: number | null
    ern: string | null
    stage: number | null
    usertouch: string | null
    touch: Date | null
    notes: string | null
  }

  export type Logs_enrollMaxAggregateOutputType = {
    id: number | null
    ern: string | null
    stage: number | null
    usertouch: string | null
    touch: Date | null
    notes: string | null
  }

  export type Logs_enrollCountAggregateOutputType = {
    id: number
    ern: number
    stage: number
    usertouch: number
    touch: number
    notes: number
    _all: number
  }


  export type Logs_enrollAvgAggregateInputType = {
    id?: true
    stage?: true
  }

  export type Logs_enrollSumAggregateInputType = {
    id?: true
    stage?: true
  }

  export type Logs_enrollMinAggregateInputType = {
    id?: true
    ern?: true
    stage?: true
    usertouch?: true
    touch?: true
    notes?: true
  }

  export type Logs_enrollMaxAggregateInputType = {
    id?: true
    ern?: true
    stage?: true
    usertouch?: true
    touch?: true
    notes?: true
  }

  export type Logs_enrollCountAggregateInputType = {
    id?: true
    ern?: true
    stage?: true
    usertouch?: true
    touch?: true
    notes?: true
    _all?: true
  }

  export type Logs_enrollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs_enroll to aggregate.
     */
    where?: logs_enrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_enrolls to fetch.
     */
    orderBy?: logs_enrollOrderByWithRelationInput | logs_enrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: logs_enrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_enrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_enrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logs_enrolls
    **/
    _count?: true | Logs_enrollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Logs_enrollAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Logs_enrollSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Logs_enrollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Logs_enrollMaxAggregateInputType
  }

  export type GetLogs_enrollAggregateType<T extends Logs_enrollAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs_enroll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs_enroll[P]>
      : GetScalarType<T[P], AggregateLogs_enroll[P]>
  }




  export type logs_enrollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logs_enrollWhereInput
    orderBy?: logs_enrollOrderByWithAggregationInput | logs_enrollOrderByWithAggregationInput[]
    by: Logs_enrollScalarFieldEnum[] | Logs_enrollScalarFieldEnum
    having?: logs_enrollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Logs_enrollCountAggregateInputType | true
    _avg?: Logs_enrollAvgAggregateInputType
    _sum?: Logs_enrollSumAggregateInputType
    _min?: Logs_enrollMinAggregateInputType
    _max?: Logs_enrollMaxAggregateInputType
  }

  export type Logs_enrollGroupByOutputType = {
    id: number
    ern: string
    stage: number
    usertouch: string
    touch: Date
    notes: string
    _count: Logs_enrollCountAggregateOutputType | null
    _avg: Logs_enrollAvgAggregateOutputType | null
    _sum: Logs_enrollSumAggregateOutputType | null
    _min: Logs_enrollMinAggregateOutputType | null
    _max: Logs_enrollMaxAggregateOutputType | null
  }

  type GetLogs_enrollGroupByPayload<T extends logs_enrollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Logs_enrollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Logs_enrollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Logs_enrollGroupByOutputType[P]>
            : GetScalarType<T[P], Logs_enrollGroupByOutputType[P]>
        }
      >
    >


  export type logs_enrollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ern?: boolean
    stage?: boolean
    usertouch?: boolean
    touch?: boolean
    notes?: boolean
  }, ExtArgs["result"]["logs_enroll"]>



  export type logs_enrollSelectScalar = {
    id?: boolean
    ern?: boolean
    stage?: boolean
    usertouch?: boolean
    touch?: boolean
    notes?: boolean
  }

  export type logs_enrollOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ern" | "stage" | "usertouch" | "touch" | "notes", ExtArgs["result"]["logs_enroll"]>

  export type $logs_enrollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "logs_enroll"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ern: string
      stage: number
      usertouch: string
      touch: Date
      notes: string
    }, ExtArgs["result"]["logs_enroll"]>
    composites: {}
  }

  type logs_enrollGetPayload<S extends boolean | null | undefined | logs_enrollDefaultArgs> = $Result.GetResult<Prisma.$logs_enrollPayload, S>

  type logs_enrollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<logs_enrollFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Logs_enrollCountAggregateInputType | true
    }

  export interface logs_enrollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['logs_enroll'], meta: { name: 'logs_enroll' } }
    /**
     * Find zero or one Logs_enroll that matches the filter.
     * @param {logs_enrollFindUniqueArgs} args - Arguments to find a Logs_enroll
     * @example
     * // Get one Logs_enroll
     * const logs_enroll = await prisma.logs_enroll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends logs_enrollFindUniqueArgs>(args: SelectSubset<T, logs_enrollFindUniqueArgs<ExtArgs>>): Prisma__logs_enrollClient<$Result.GetResult<Prisma.$logs_enrollPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Logs_enroll that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {logs_enrollFindUniqueOrThrowArgs} args - Arguments to find a Logs_enroll
     * @example
     * // Get one Logs_enroll
     * const logs_enroll = await prisma.logs_enroll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends logs_enrollFindUniqueOrThrowArgs>(args: SelectSubset<T, logs_enrollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__logs_enrollClient<$Result.GetResult<Prisma.$logs_enrollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logs_enroll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_enrollFindFirstArgs} args - Arguments to find a Logs_enroll
     * @example
     * // Get one Logs_enroll
     * const logs_enroll = await prisma.logs_enroll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends logs_enrollFindFirstArgs>(args?: SelectSubset<T, logs_enrollFindFirstArgs<ExtArgs>>): Prisma__logs_enrollClient<$Result.GetResult<Prisma.$logs_enrollPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logs_enroll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_enrollFindFirstOrThrowArgs} args - Arguments to find a Logs_enroll
     * @example
     * // Get one Logs_enroll
     * const logs_enroll = await prisma.logs_enroll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends logs_enrollFindFirstOrThrowArgs>(args?: SelectSubset<T, logs_enrollFindFirstOrThrowArgs<ExtArgs>>): Prisma__logs_enrollClient<$Result.GetResult<Prisma.$logs_enrollPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs_enrolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_enrollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs_enrolls
     * const logs_enrolls = await prisma.logs_enroll.findMany()
     * 
     * // Get first 10 Logs_enrolls
     * const logs_enrolls = await prisma.logs_enroll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logs_enrollWithIdOnly = await prisma.logs_enroll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends logs_enrollFindManyArgs>(args?: SelectSubset<T, logs_enrollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logs_enrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Logs_enroll.
     * @param {logs_enrollCreateArgs} args - Arguments to create a Logs_enroll.
     * @example
     * // Create one Logs_enroll
     * const Logs_enroll = await prisma.logs_enroll.create({
     *   data: {
     *     // ... data to create a Logs_enroll
     *   }
     * })
     * 
     */
    create<T extends logs_enrollCreateArgs>(args: SelectSubset<T, logs_enrollCreateArgs<ExtArgs>>): Prisma__logs_enrollClient<$Result.GetResult<Prisma.$logs_enrollPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs_enrolls.
     * @param {logs_enrollCreateManyArgs} args - Arguments to create many Logs_enrolls.
     * @example
     * // Create many Logs_enrolls
     * const logs_enroll = await prisma.logs_enroll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends logs_enrollCreateManyArgs>(args?: SelectSubset<T, logs_enrollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logs_enroll.
     * @param {logs_enrollDeleteArgs} args - Arguments to delete one Logs_enroll.
     * @example
     * // Delete one Logs_enroll
     * const Logs_enroll = await prisma.logs_enroll.delete({
     *   where: {
     *     // ... filter to delete one Logs_enroll
     *   }
     * })
     * 
     */
    delete<T extends logs_enrollDeleteArgs>(args: SelectSubset<T, logs_enrollDeleteArgs<ExtArgs>>): Prisma__logs_enrollClient<$Result.GetResult<Prisma.$logs_enrollPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Logs_enroll.
     * @param {logs_enrollUpdateArgs} args - Arguments to update one Logs_enroll.
     * @example
     * // Update one Logs_enroll
     * const logs_enroll = await prisma.logs_enroll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends logs_enrollUpdateArgs>(args: SelectSubset<T, logs_enrollUpdateArgs<ExtArgs>>): Prisma__logs_enrollClient<$Result.GetResult<Prisma.$logs_enrollPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs_enrolls.
     * @param {logs_enrollDeleteManyArgs} args - Arguments to filter Logs_enrolls to delete.
     * @example
     * // Delete a few Logs_enrolls
     * const { count } = await prisma.logs_enroll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends logs_enrollDeleteManyArgs>(args?: SelectSubset<T, logs_enrollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs_enrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_enrollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs_enrolls
     * const logs_enroll = await prisma.logs_enroll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends logs_enrollUpdateManyArgs>(args: SelectSubset<T, logs_enrollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logs_enroll.
     * @param {logs_enrollUpsertArgs} args - Arguments to update or create a Logs_enroll.
     * @example
     * // Update or create a Logs_enroll
     * const logs_enroll = await prisma.logs_enroll.upsert({
     *   create: {
     *     // ... data to create a Logs_enroll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs_enroll we want to update
     *   }
     * })
     */
    upsert<T extends logs_enrollUpsertArgs>(args: SelectSubset<T, logs_enrollUpsertArgs<ExtArgs>>): Prisma__logs_enrollClient<$Result.GetResult<Prisma.$logs_enrollPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs_enrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_enrollCountArgs} args - Arguments to filter Logs_enrolls to count.
     * @example
     * // Count the number of Logs_enrolls
     * const count = await prisma.logs_enroll.count({
     *   where: {
     *     // ... the filter for the Logs_enrolls we want to count
     *   }
     * })
    **/
    count<T extends logs_enrollCountArgs>(
      args?: Subset<T, logs_enrollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Logs_enrollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs_enroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Logs_enrollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Logs_enrollAggregateArgs>(args: Subset<T, Logs_enrollAggregateArgs>): Prisma.PrismaPromise<GetLogs_enrollAggregateType<T>>

    /**
     * Group by Logs_enroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_enrollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends logs_enrollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: logs_enrollGroupByArgs['orderBy'] }
        : { orderBy?: logs_enrollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, logs_enrollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogs_enrollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the logs_enroll model
   */
  readonly fields: logs_enrollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for logs_enroll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__logs_enrollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the logs_enroll model
   */
  interface logs_enrollFieldRefs {
    readonly id: FieldRef<"logs_enroll", 'Int'>
    readonly ern: FieldRef<"logs_enroll", 'String'>
    readonly stage: FieldRef<"logs_enroll", 'Int'>
    readonly usertouch: FieldRef<"logs_enroll", 'String'>
    readonly touch: FieldRef<"logs_enroll", 'DateTime'>
    readonly notes: FieldRef<"logs_enroll", 'String'>
  }
    

  // Custom InputTypes
  /**
   * logs_enroll findUnique
   */
  export type logs_enrollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_enroll
     */
    select?: logs_enrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_enroll
     */
    omit?: logs_enrollOmit<ExtArgs> | null
    /**
     * Filter, which logs_enroll to fetch.
     */
    where: logs_enrollWhereUniqueInput
  }

  /**
   * logs_enroll findUniqueOrThrow
   */
  export type logs_enrollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_enroll
     */
    select?: logs_enrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_enroll
     */
    omit?: logs_enrollOmit<ExtArgs> | null
    /**
     * Filter, which logs_enroll to fetch.
     */
    where: logs_enrollWhereUniqueInput
  }

  /**
   * logs_enroll findFirst
   */
  export type logs_enrollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_enroll
     */
    select?: logs_enrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_enroll
     */
    omit?: logs_enrollOmit<ExtArgs> | null
    /**
     * Filter, which logs_enroll to fetch.
     */
    where?: logs_enrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_enrolls to fetch.
     */
    orderBy?: logs_enrollOrderByWithRelationInput | logs_enrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs_enrolls.
     */
    cursor?: logs_enrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_enrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_enrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs_enrolls.
     */
    distinct?: Logs_enrollScalarFieldEnum | Logs_enrollScalarFieldEnum[]
  }

  /**
   * logs_enroll findFirstOrThrow
   */
  export type logs_enrollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_enroll
     */
    select?: logs_enrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_enroll
     */
    omit?: logs_enrollOmit<ExtArgs> | null
    /**
     * Filter, which logs_enroll to fetch.
     */
    where?: logs_enrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_enrolls to fetch.
     */
    orderBy?: logs_enrollOrderByWithRelationInput | logs_enrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs_enrolls.
     */
    cursor?: logs_enrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_enrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_enrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs_enrolls.
     */
    distinct?: Logs_enrollScalarFieldEnum | Logs_enrollScalarFieldEnum[]
  }

  /**
   * logs_enroll findMany
   */
  export type logs_enrollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_enroll
     */
    select?: logs_enrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_enroll
     */
    omit?: logs_enrollOmit<ExtArgs> | null
    /**
     * Filter, which logs_enrolls to fetch.
     */
    where?: logs_enrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_enrolls to fetch.
     */
    orderBy?: logs_enrollOrderByWithRelationInput | logs_enrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logs_enrolls.
     */
    cursor?: logs_enrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_enrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_enrolls.
     */
    skip?: number
    distinct?: Logs_enrollScalarFieldEnum | Logs_enrollScalarFieldEnum[]
  }

  /**
   * logs_enroll create
   */
  export type logs_enrollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_enroll
     */
    select?: logs_enrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_enroll
     */
    omit?: logs_enrollOmit<ExtArgs> | null
    /**
     * The data needed to create a logs_enroll.
     */
    data: XOR<logs_enrollCreateInput, logs_enrollUncheckedCreateInput>
  }

  /**
   * logs_enroll createMany
   */
  export type logs_enrollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many logs_enrolls.
     */
    data: logs_enrollCreateManyInput | logs_enrollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * logs_enroll update
   */
  export type logs_enrollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_enroll
     */
    select?: logs_enrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_enroll
     */
    omit?: logs_enrollOmit<ExtArgs> | null
    /**
     * The data needed to update a logs_enroll.
     */
    data: XOR<logs_enrollUpdateInput, logs_enrollUncheckedUpdateInput>
    /**
     * Choose, which logs_enroll to update.
     */
    where: logs_enrollWhereUniqueInput
  }

  /**
   * logs_enroll updateMany
   */
  export type logs_enrollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update logs_enrolls.
     */
    data: XOR<logs_enrollUpdateManyMutationInput, logs_enrollUncheckedUpdateManyInput>
    /**
     * Filter which logs_enrolls to update
     */
    where?: logs_enrollWhereInput
    /**
     * Limit how many logs_enrolls to update.
     */
    limit?: number
  }

  /**
   * logs_enroll upsert
   */
  export type logs_enrollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_enroll
     */
    select?: logs_enrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_enroll
     */
    omit?: logs_enrollOmit<ExtArgs> | null
    /**
     * The filter to search for the logs_enroll to update in case it exists.
     */
    where: logs_enrollWhereUniqueInput
    /**
     * In case the logs_enroll found by the `where` argument doesn't exist, create a new logs_enroll with this data.
     */
    create: XOR<logs_enrollCreateInput, logs_enrollUncheckedCreateInput>
    /**
     * In case the logs_enroll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<logs_enrollUpdateInput, logs_enrollUncheckedUpdateInput>
  }

  /**
   * logs_enroll delete
   */
  export type logs_enrollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_enroll
     */
    select?: logs_enrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_enroll
     */
    omit?: logs_enrollOmit<ExtArgs> | null
    /**
     * Filter which logs_enroll to delete.
     */
    where: logs_enrollWhereUniqueInput
  }

  /**
   * logs_enroll deleteMany
   */
  export type logs_enrollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs_enrolls to delete
     */
    where?: logs_enrollWhereInput
    /**
     * Limit how many logs_enrolls to delete.
     */
    limit?: number
  }

  /**
   * logs_enroll without action
   */
  export type logs_enrollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_enroll
     */
    select?: logs_enrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs_enroll
     */
    omit?: logs_enrollOmit<ExtArgs> | null
  }


  /**
   * Model nationalities
   */

  export type AggregateNationalities = {
    _count: NationalitiesCountAggregateOutputType | null
    _avg: NationalitiesAvgAggregateOutputType | null
    _sum: NationalitiesSumAggregateOutputType | null
    _min: NationalitiesMinAggregateOutputType | null
    _max: NationalitiesMaxAggregateOutputType | null
  }

  export type NationalitiesAvgAggregateOutputType = {
    id: number | null
  }

  export type NationalitiesSumAggregateOutputType = {
    id: number | null
  }

  export type NationalitiesMinAggregateOutputType = {
    id: number | null
    countryCode: string | null
    nationalityName: string | null
    currencyCode: string | null
    fipsCode: string | null
    isoNumeric: string | null
    north: string | null
    south: string | null
    east: string | null
    west: string | null
    capital: string | null
    continentName: string | null
    continent: string | null
  }

  export type NationalitiesMaxAggregateOutputType = {
    id: number | null
    countryCode: string | null
    nationalityName: string | null
    currencyCode: string | null
    fipsCode: string | null
    isoNumeric: string | null
    north: string | null
    south: string | null
    east: string | null
    west: string | null
    capital: string | null
    continentName: string | null
    continent: string | null
  }

  export type NationalitiesCountAggregateOutputType = {
    id: number
    countryCode: number
    nationalityName: number
    currencyCode: number
    fipsCode: number
    isoNumeric: number
    north: number
    south: number
    east: number
    west: number
    capital: number
    continentName: number
    continent: number
    _all: number
  }


  export type NationalitiesAvgAggregateInputType = {
    id?: true
  }

  export type NationalitiesSumAggregateInputType = {
    id?: true
  }

  export type NationalitiesMinAggregateInputType = {
    id?: true
    countryCode?: true
    nationalityName?: true
    currencyCode?: true
    fipsCode?: true
    isoNumeric?: true
    north?: true
    south?: true
    east?: true
    west?: true
    capital?: true
    continentName?: true
    continent?: true
  }

  export type NationalitiesMaxAggregateInputType = {
    id?: true
    countryCode?: true
    nationalityName?: true
    currencyCode?: true
    fipsCode?: true
    isoNumeric?: true
    north?: true
    south?: true
    east?: true
    west?: true
    capital?: true
    continentName?: true
    continent?: true
  }

  export type NationalitiesCountAggregateInputType = {
    id?: true
    countryCode?: true
    nationalityName?: true
    currencyCode?: true
    fipsCode?: true
    isoNumeric?: true
    north?: true
    south?: true
    east?: true
    west?: true
    capital?: true
    continentName?: true
    continent?: true
    _all?: true
  }

  export type NationalitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which nationalities to aggregate.
     */
    where?: nationalitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nationalities to fetch.
     */
    orderBy?: nationalitiesOrderByWithRelationInput | nationalitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: nationalitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nationalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned nationalities
    **/
    _count?: true | NationalitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NationalitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NationalitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NationalitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NationalitiesMaxAggregateInputType
  }

  export type GetNationalitiesAggregateType<T extends NationalitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateNationalities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNationalities[P]>
      : GetScalarType<T[P], AggregateNationalities[P]>
  }




  export type nationalitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: nationalitiesWhereInput
    orderBy?: nationalitiesOrderByWithAggregationInput | nationalitiesOrderByWithAggregationInput[]
    by: NationalitiesScalarFieldEnum[] | NationalitiesScalarFieldEnum
    having?: nationalitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NationalitiesCountAggregateInputType | true
    _avg?: NationalitiesAvgAggregateInputType
    _sum?: NationalitiesSumAggregateInputType
    _min?: NationalitiesMinAggregateInputType
    _max?: NationalitiesMaxAggregateInputType
  }

  export type NationalitiesGroupByOutputType = {
    id: number
    countryCode: string
    nationalityName: string
    currencyCode: string | null
    fipsCode: string | null
    isoNumeric: string | null
    north: string | null
    south: string | null
    east: string | null
    west: string | null
    capital: string | null
    continentName: string | null
    continent: string | null
    _count: NationalitiesCountAggregateOutputType | null
    _avg: NationalitiesAvgAggregateOutputType | null
    _sum: NationalitiesSumAggregateOutputType | null
    _min: NationalitiesMinAggregateOutputType | null
    _max: NationalitiesMaxAggregateOutputType | null
  }

  type GetNationalitiesGroupByPayload<T extends nationalitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NationalitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NationalitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NationalitiesGroupByOutputType[P]>
            : GetScalarType<T[P], NationalitiesGroupByOutputType[P]>
        }
      >
    >


  export type nationalitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryCode?: boolean
    nationalityName?: boolean
    currencyCode?: boolean
    fipsCode?: boolean
    isoNumeric?: boolean
    north?: boolean
    south?: boolean
    east?: boolean
    west?: boolean
    capital?: boolean
    continentName?: boolean
    continent?: boolean
  }, ExtArgs["result"]["nationalities"]>



  export type nationalitiesSelectScalar = {
    id?: boolean
    countryCode?: boolean
    nationalityName?: boolean
    currencyCode?: boolean
    fipsCode?: boolean
    isoNumeric?: boolean
    north?: boolean
    south?: boolean
    east?: boolean
    west?: boolean
    capital?: boolean
    continentName?: boolean
    continent?: boolean
  }

  export type nationalitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "countryCode" | "nationalityName" | "currencyCode" | "fipsCode" | "isoNumeric" | "north" | "south" | "east" | "west" | "capital" | "continentName" | "continent", ExtArgs["result"]["nationalities"]>

  export type $nationalitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "nationalities"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      countryCode: string
      nationalityName: string
      currencyCode: string | null
      fipsCode: string | null
      isoNumeric: string | null
      north: string | null
      south: string | null
      east: string | null
      west: string | null
      capital: string | null
      continentName: string | null
      continent: string | null
    }, ExtArgs["result"]["nationalities"]>
    composites: {}
  }

  type nationalitiesGetPayload<S extends boolean | null | undefined | nationalitiesDefaultArgs> = $Result.GetResult<Prisma.$nationalitiesPayload, S>

  type nationalitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<nationalitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NationalitiesCountAggregateInputType | true
    }

  export interface nationalitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['nationalities'], meta: { name: 'nationalities' } }
    /**
     * Find zero or one Nationalities that matches the filter.
     * @param {nationalitiesFindUniqueArgs} args - Arguments to find a Nationalities
     * @example
     * // Get one Nationalities
     * const nationalities = await prisma.nationalities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends nationalitiesFindUniqueArgs>(args: SelectSubset<T, nationalitiesFindUniqueArgs<ExtArgs>>): Prisma__nationalitiesClient<$Result.GetResult<Prisma.$nationalitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Nationalities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {nationalitiesFindUniqueOrThrowArgs} args - Arguments to find a Nationalities
     * @example
     * // Get one Nationalities
     * const nationalities = await prisma.nationalities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends nationalitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, nationalitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__nationalitiesClient<$Result.GetResult<Prisma.$nationalitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nationalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nationalitiesFindFirstArgs} args - Arguments to find a Nationalities
     * @example
     * // Get one Nationalities
     * const nationalities = await prisma.nationalities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends nationalitiesFindFirstArgs>(args?: SelectSubset<T, nationalitiesFindFirstArgs<ExtArgs>>): Prisma__nationalitiesClient<$Result.GetResult<Prisma.$nationalitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nationalities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nationalitiesFindFirstOrThrowArgs} args - Arguments to find a Nationalities
     * @example
     * // Get one Nationalities
     * const nationalities = await prisma.nationalities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends nationalitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, nationalitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__nationalitiesClient<$Result.GetResult<Prisma.$nationalitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Nationalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nationalitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nationalities
     * const nationalities = await prisma.nationalities.findMany()
     * 
     * // Get first 10 Nationalities
     * const nationalities = await prisma.nationalities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nationalitiesWithIdOnly = await prisma.nationalities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends nationalitiesFindManyArgs>(args?: SelectSubset<T, nationalitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$nationalitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Nationalities.
     * @param {nationalitiesCreateArgs} args - Arguments to create a Nationalities.
     * @example
     * // Create one Nationalities
     * const Nationalities = await prisma.nationalities.create({
     *   data: {
     *     // ... data to create a Nationalities
     *   }
     * })
     * 
     */
    create<T extends nationalitiesCreateArgs>(args: SelectSubset<T, nationalitiesCreateArgs<ExtArgs>>): Prisma__nationalitiesClient<$Result.GetResult<Prisma.$nationalitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Nationalities.
     * @param {nationalitiesCreateManyArgs} args - Arguments to create many Nationalities.
     * @example
     * // Create many Nationalities
     * const nationalities = await prisma.nationalities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends nationalitiesCreateManyArgs>(args?: SelectSubset<T, nationalitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Nationalities.
     * @param {nationalitiesDeleteArgs} args - Arguments to delete one Nationalities.
     * @example
     * // Delete one Nationalities
     * const Nationalities = await prisma.nationalities.delete({
     *   where: {
     *     // ... filter to delete one Nationalities
     *   }
     * })
     * 
     */
    delete<T extends nationalitiesDeleteArgs>(args: SelectSubset<T, nationalitiesDeleteArgs<ExtArgs>>): Prisma__nationalitiesClient<$Result.GetResult<Prisma.$nationalitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Nationalities.
     * @param {nationalitiesUpdateArgs} args - Arguments to update one Nationalities.
     * @example
     * // Update one Nationalities
     * const nationalities = await prisma.nationalities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends nationalitiesUpdateArgs>(args: SelectSubset<T, nationalitiesUpdateArgs<ExtArgs>>): Prisma__nationalitiesClient<$Result.GetResult<Prisma.$nationalitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Nationalities.
     * @param {nationalitiesDeleteManyArgs} args - Arguments to filter Nationalities to delete.
     * @example
     * // Delete a few Nationalities
     * const { count } = await prisma.nationalities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends nationalitiesDeleteManyArgs>(args?: SelectSubset<T, nationalitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nationalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nationalitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nationalities
     * const nationalities = await prisma.nationalities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends nationalitiesUpdateManyArgs>(args: SelectSubset<T, nationalitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Nationalities.
     * @param {nationalitiesUpsertArgs} args - Arguments to update or create a Nationalities.
     * @example
     * // Update or create a Nationalities
     * const nationalities = await prisma.nationalities.upsert({
     *   create: {
     *     // ... data to create a Nationalities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nationalities we want to update
     *   }
     * })
     */
    upsert<T extends nationalitiesUpsertArgs>(args: SelectSubset<T, nationalitiesUpsertArgs<ExtArgs>>): Prisma__nationalitiesClient<$Result.GetResult<Prisma.$nationalitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Nationalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nationalitiesCountArgs} args - Arguments to filter Nationalities to count.
     * @example
     * // Count the number of Nationalities
     * const count = await prisma.nationalities.count({
     *   where: {
     *     // ... the filter for the Nationalities we want to count
     *   }
     * })
    **/
    count<T extends nationalitiesCountArgs>(
      args?: Subset<T, nationalitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NationalitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nationalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NationalitiesAggregateArgs>(args: Subset<T, NationalitiesAggregateArgs>): Prisma.PrismaPromise<GetNationalitiesAggregateType<T>>

    /**
     * Group by Nationalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nationalitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends nationalitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: nationalitiesGroupByArgs['orderBy'] }
        : { orderBy?: nationalitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, nationalitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNationalitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the nationalities model
   */
  readonly fields: nationalitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for nationalities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__nationalitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the nationalities model
   */
  interface nationalitiesFieldRefs {
    readonly id: FieldRef<"nationalities", 'Int'>
    readonly countryCode: FieldRef<"nationalities", 'String'>
    readonly nationalityName: FieldRef<"nationalities", 'String'>
    readonly currencyCode: FieldRef<"nationalities", 'String'>
    readonly fipsCode: FieldRef<"nationalities", 'String'>
    readonly isoNumeric: FieldRef<"nationalities", 'String'>
    readonly north: FieldRef<"nationalities", 'String'>
    readonly south: FieldRef<"nationalities", 'String'>
    readonly east: FieldRef<"nationalities", 'String'>
    readonly west: FieldRef<"nationalities", 'String'>
    readonly capital: FieldRef<"nationalities", 'String'>
    readonly continentName: FieldRef<"nationalities", 'String'>
    readonly continent: FieldRef<"nationalities", 'String'>
  }
    

  // Custom InputTypes
  /**
   * nationalities findUnique
   */
  export type nationalitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nationalities
     */
    select?: nationalitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nationalities
     */
    omit?: nationalitiesOmit<ExtArgs> | null
    /**
     * Filter, which nationalities to fetch.
     */
    where: nationalitiesWhereUniqueInput
  }

  /**
   * nationalities findUniqueOrThrow
   */
  export type nationalitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nationalities
     */
    select?: nationalitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nationalities
     */
    omit?: nationalitiesOmit<ExtArgs> | null
    /**
     * Filter, which nationalities to fetch.
     */
    where: nationalitiesWhereUniqueInput
  }

  /**
   * nationalities findFirst
   */
  export type nationalitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nationalities
     */
    select?: nationalitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nationalities
     */
    omit?: nationalitiesOmit<ExtArgs> | null
    /**
     * Filter, which nationalities to fetch.
     */
    where?: nationalitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nationalities to fetch.
     */
    orderBy?: nationalitiesOrderByWithRelationInput | nationalitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nationalities.
     */
    cursor?: nationalitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nationalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nationalities.
     */
    distinct?: NationalitiesScalarFieldEnum | NationalitiesScalarFieldEnum[]
  }

  /**
   * nationalities findFirstOrThrow
   */
  export type nationalitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nationalities
     */
    select?: nationalitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nationalities
     */
    omit?: nationalitiesOmit<ExtArgs> | null
    /**
     * Filter, which nationalities to fetch.
     */
    where?: nationalitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nationalities to fetch.
     */
    orderBy?: nationalitiesOrderByWithRelationInput | nationalitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nationalities.
     */
    cursor?: nationalitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nationalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nationalities.
     */
    distinct?: NationalitiesScalarFieldEnum | NationalitiesScalarFieldEnum[]
  }

  /**
   * nationalities findMany
   */
  export type nationalitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nationalities
     */
    select?: nationalitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nationalities
     */
    omit?: nationalitiesOmit<ExtArgs> | null
    /**
     * Filter, which nationalities to fetch.
     */
    where?: nationalitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nationalities to fetch.
     */
    orderBy?: nationalitiesOrderByWithRelationInput | nationalitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing nationalities.
     */
    cursor?: nationalitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nationalities.
     */
    skip?: number
    distinct?: NationalitiesScalarFieldEnum | NationalitiesScalarFieldEnum[]
  }

  /**
   * nationalities create
   */
  export type nationalitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nationalities
     */
    select?: nationalitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nationalities
     */
    omit?: nationalitiesOmit<ExtArgs> | null
    /**
     * The data needed to create a nationalities.
     */
    data?: XOR<nationalitiesCreateInput, nationalitiesUncheckedCreateInput>
  }

  /**
   * nationalities createMany
   */
  export type nationalitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many nationalities.
     */
    data: nationalitiesCreateManyInput | nationalitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * nationalities update
   */
  export type nationalitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nationalities
     */
    select?: nationalitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nationalities
     */
    omit?: nationalitiesOmit<ExtArgs> | null
    /**
     * The data needed to update a nationalities.
     */
    data: XOR<nationalitiesUpdateInput, nationalitiesUncheckedUpdateInput>
    /**
     * Choose, which nationalities to update.
     */
    where: nationalitiesWhereUniqueInput
  }

  /**
   * nationalities updateMany
   */
  export type nationalitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update nationalities.
     */
    data: XOR<nationalitiesUpdateManyMutationInput, nationalitiesUncheckedUpdateManyInput>
    /**
     * Filter which nationalities to update
     */
    where?: nationalitiesWhereInput
    /**
     * Limit how many nationalities to update.
     */
    limit?: number
  }

  /**
   * nationalities upsert
   */
  export type nationalitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nationalities
     */
    select?: nationalitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nationalities
     */
    omit?: nationalitiesOmit<ExtArgs> | null
    /**
     * The filter to search for the nationalities to update in case it exists.
     */
    where: nationalitiesWhereUniqueInput
    /**
     * In case the nationalities found by the `where` argument doesn't exist, create a new nationalities with this data.
     */
    create: XOR<nationalitiesCreateInput, nationalitiesUncheckedCreateInput>
    /**
     * In case the nationalities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<nationalitiesUpdateInput, nationalitiesUncheckedUpdateInput>
  }

  /**
   * nationalities delete
   */
  export type nationalitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nationalities
     */
    select?: nationalitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nationalities
     */
    omit?: nationalitiesOmit<ExtArgs> | null
    /**
     * Filter which nationalities to delete.
     */
    where: nationalitiesWhereUniqueInput
  }

  /**
   * nationalities deleteMany
   */
  export type nationalitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which nationalities to delete
     */
    where?: nationalitiesWhereInput
    /**
     * Limit how many nationalities to delete.
     */
    limit?: number
  }

  /**
   * nationalities without action
   */
  export type nationalitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nationalities
     */
    select?: nationalitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the nationalities
     */
    omit?: nationalitiesOmit<ExtArgs> | null
  }


  /**
   * Model products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    id: number | null
    price_of_product: number | null
  }

  export type ProductsSumAggregateOutputType = {
    id: number | null
    price_of_product: number | null
  }

  export type ProductsMinAggregateOutputType = {
    id: number | null
    product_code: string | null
    type_of_product: string | null
    name_of_product: string | null
    price_of_product: number | null
    date_created: Date | null
    last_touch: string | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: number | null
    product_code: string | null
    type_of_product: string | null
    name_of_product: string | null
    price_of_product: number | null
    date_created: Date | null
    last_touch: string | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    product_code: number
    type_of_product: number
    name_of_product: number
    price_of_product: number
    date_created: number
    last_touch: number
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    id?: true
    price_of_product?: true
  }

  export type ProductsSumAggregateInputType = {
    id?: true
    price_of_product?: true
  }

  export type ProductsMinAggregateInputType = {
    id?: true
    product_code?: true
    type_of_product?: true
    name_of_product?: true
    price_of_product?: true
    date_created?: true
    last_touch?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    product_code?: true
    type_of_product?: true
    name_of_product?: true
    price_of_product?: true
    date_created?: true
    last_touch?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    product_code?: true
    type_of_product?: true
    name_of_product?: true
    price_of_product?: true
    date_created?: true
    last_touch?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to aggregate.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
    orderBy?: productsOrderByWithAggregationInput | productsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: productsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _avg?: ProductsAvgAggregateInputType
    _sum?: ProductsSumAggregateInputType
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    id: number
    product_code: string
    type_of_product: string
    name_of_product: string
    price_of_product: number
    date_created: Date
    last_touch: string
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_code?: boolean
    type_of_product?: boolean
    name_of_product?: boolean
    price_of_product?: boolean
    date_created?: boolean
    last_touch?: boolean
  }, ExtArgs["result"]["products"]>



  export type productsSelectScalar = {
    id?: boolean
    product_code?: boolean
    type_of_product?: boolean
    name_of_product?: boolean
    price_of_product?: boolean
    date_created?: boolean
    last_touch?: boolean
  }

  export type productsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "product_code" | "type_of_product" | "name_of_product" | "price_of_product" | "date_created" | "last_touch", ExtArgs["result"]["products"]>

  export type $productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "products"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      product_code: string
      type_of_product: string
      name_of_product: string
      price_of_product: number
      date_created: Date
      last_touch: string
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type productsGetPayload<S extends boolean | null | undefined | productsDefaultArgs> = $Result.GetResult<Prisma.$productsPayload, S>

  type productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['products'], meta: { name: 'products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {productsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productsFindUniqueArgs>(args: SelectSubset<T, productsFindUniqueArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productsFindUniqueOrThrowArgs>(args: SelectSubset<T, productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productsFindFirstArgs>(args?: SelectSubset<T, productsFindFirstArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productsFindFirstOrThrowArgs>(args?: SelectSubset<T, productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productsFindManyArgs>(args?: SelectSubset<T, productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Products.
     * @param {productsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends productsCreateArgs>(args: SelectSubset<T, productsCreateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {productsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productsCreateManyArgs>(args?: SelectSubset<T, productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Products.
     * @param {productsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends productsDeleteArgs>(args: SelectSubset<T, productsDeleteArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Products.
     * @param {productsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productsUpdateArgs>(args: SelectSubset<T, productsUpdateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productsDeleteManyArgs>(args?: SelectSubset<T, productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productsUpdateManyArgs>(args: SelectSubset<T, productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Products.
     * @param {productsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends productsUpsertArgs>(args: SelectSubset<T, productsUpsertArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productsCountArgs>(
      args?: Subset<T, productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productsGroupByArgs['orderBy'] }
        : { orderBy?: productsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the products model
   */
  readonly fields: productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the products model
   */
  interface productsFieldRefs {
    readonly id: FieldRef<"products", 'Int'>
    readonly product_code: FieldRef<"products", 'String'>
    readonly type_of_product: FieldRef<"products", 'String'>
    readonly name_of_product: FieldRef<"products", 'String'>
    readonly price_of_product: FieldRef<"products", 'Float'>
    readonly date_created: FieldRef<"products", 'DateTime'>
    readonly last_touch: FieldRef<"products", 'String'>
  }
    

  // Custom InputTypes
  /**
   * products findUnique
   */
  export type productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findUniqueOrThrow
   */
  export type productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findFirst
   */
  export type productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findFirstOrThrow
   */
  export type productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findMany
   */
  export type productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products create
   */
  export type productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The data needed to create a products.
     */
    data: XOR<productsCreateInput, productsUncheckedCreateInput>
  }

  /**
   * products createMany
   */
  export type productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * products update
   */
  export type productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The data needed to update a products.
     */
    data: XOR<productsUpdateInput, productsUncheckedUpdateInput>
    /**
     * Choose, which products to update.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products updateMany
   */
  export type productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
  }

  /**
   * products upsert
   */
  export type productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The filter to search for the products to update in case it exists.
     */
    where: productsWhereUniqueInput
    /**
     * In case the products found by the `where` argument doesn't exist, create a new products with this data.
     */
    create: XOR<productsCreateInput, productsUncheckedCreateInput>
    /**
     * In case the products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productsUpdateInput, productsUncheckedUpdateInput>
  }

  /**
   * products delete
   */
  export type productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Filter which products to delete.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products deleteMany
   */
  export type productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productsWhereInput
    /**
     * Limit how many products to delete.
     */
    limit?: number
  }

  /**
   * products without action
   */
  export type productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
  }


  /**
   * Model requests
   */

  export type AggregateRequests = {
    _count: RequestsCountAggregateOutputType | null
    _avg: RequestsAvgAggregateOutputType | null
    _sum: RequestsSumAggregateOutputType | null
    _min: RequestsMinAggregateOutputType | null
    _max: RequestsMaxAggregateOutputType | null
  }

  export type RequestsAvgAggregateOutputType = {
    id: number | null
    rfid: number | null
    approvedby: number | null
    approvedfin: number | null
  }

  export type RequestsSumAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    approvedby: bigint | null
    approvedfin: bigint | null
  }

  export type RequestsMinAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    reqtype: string | null
    reqdate: Date | null
    reqneed: Date | null
    reqdetails: string | null
    approvedby: bigint | null
    approvedate: Date | null
    approvedfin: bigint | null
    approvedfindate: Date | null
    status: string | null
  }

  export type RequestsMaxAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    reqtype: string | null
    reqdate: Date | null
    reqneed: Date | null
    reqdetails: string | null
    approvedby: bigint | null
    approvedate: Date | null
    approvedfin: bigint | null
    approvedfindate: Date | null
    status: string | null
  }

  export type RequestsCountAggregateOutputType = {
    id: number
    rfid: number
    reqtype: number
    reqdate: number
    reqneed: number
    reqdetails: number
    approvedby: number
    approvedate: number
    approvedfin: number
    approvedfindate: number
    status: number
    _all: number
  }


  export type RequestsAvgAggregateInputType = {
    id?: true
    rfid?: true
    approvedby?: true
    approvedfin?: true
  }

  export type RequestsSumAggregateInputType = {
    id?: true
    rfid?: true
    approvedby?: true
    approvedfin?: true
  }

  export type RequestsMinAggregateInputType = {
    id?: true
    rfid?: true
    reqtype?: true
    reqdate?: true
    reqneed?: true
    reqdetails?: true
    approvedby?: true
    approvedate?: true
    approvedfin?: true
    approvedfindate?: true
    status?: true
  }

  export type RequestsMaxAggregateInputType = {
    id?: true
    rfid?: true
    reqtype?: true
    reqdate?: true
    reqneed?: true
    reqdetails?: true
    approvedby?: true
    approvedate?: true
    approvedfin?: true
    approvedfindate?: true
    status?: true
  }

  export type RequestsCountAggregateInputType = {
    id?: true
    rfid?: true
    reqtype?: true
    reqdate?: true
    reqneed?: true
    reqdetails?: true
    approvedby?: true
    approvedate?: true
    approvedfin?: true
    approvedfindate?: true
    status?: true
    _all?: true
  }

  export type RequestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which requests to aggregate.
     */
    where?: requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requests to fetch.
     */
    orderBy?: requestsOrderByWithRelationInput | requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned requests
    **/
    _count?: true | RequestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestsMaxAggregateInputType
  }

  export type GetRequestsAggregateType<T extends RequestsAggregateArgs> = {
        [P in keyof T & keyof AggregateRequests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequests[P]>
      : GetScalarType<T[P], AggregateRequests[P]>
  }




  export type requestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requestsWhereInput
    orderBy?: requestsOrderByWithAggregationInput | requestsOrderByWithAggregationInput[]
    by: RequestsScalarFieldEnum[] | RequestsScalarFieldEnum
    having?: requestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestsCountAggregateInputType | true
    _avg?: RequestsAvgAggregateInputType
    _sum?: RequestsSumAggregateInputType
    _min?: RequestsMinAggregateInputType
    _max?: RequestsMaxAggregateInputType
  }

  export type RequestsGroupByOutputType = {
    id: number
    rfid: bigint
    reqtype: string
    reqdate: Date
    reqneed: Date
    reqdetails: string
    approvedby: bigint
    approvedate: Date
    approvedfin: bigint
    approvedfindate: Date
    status: string
    _count: RequestsCountAggregateOutputType | null
    _avg: RequestsAvgAggregateOutputType | null
    _sum: RequestsSumAggregateOutputType | null
    _min: RequestsMinAggregateOutputType | null
    _max: RequestsMaxAggregateOutputType | null
  }

  type GetRequestsGroupByPayload<T extends requestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestsGroupByOutputType[P]>
            : GetScalarType<T[P], RequestsGroupByOutputType[P]>
        }
      >
    >


  export type requestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfid?: boolean
    reqtype?: boolean
    reqdate?: boolean
    reqneed?: boolean
    reqdetails?: boolean
    approvedby?: boolean
    approvedate?: boolean
    approvedfin?: boolean
    approvedfindate?: boolean
    status?: boolean
  }, ExtArgs["result"]["requests"]>



  export type requestsSelectScalar = {
    id?: boolean
    rfid?: boolean
    reqtype?: boolean
    reqdate?: boolean
    reqneed?: boolean
    reqdetails?: boolean
    approvedby?: boolean
    approvedate?: boolean
    approvedfin?: boolean
    approvedfindate?: boolean
    status?: boolean
  }

  export type requestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rfid" | "reqtype" | "reqdate" | "reqneed" | "reqdetails" | "approvedby" | "approvedate" | "approvedfin" | "approvedfindate" | "status", ExtArgs["result"]["requests"]>

  export type $requestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "requests"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rfid: bigint
      reqtype: string
      reqdate: Date
      reqneed: Date
      reqdetails: string
      approvedby: bigint
      approvedate: Date
      approvedfin: bigint
      approvedfindate: Date
      status: string
    }, ExtArgs["result"]["requests"]>
    composites: {}
  }

  type requestsGetPayload<S extends boolean | null | undefined | requestsDefaultArgs> = $Result.GetResult<Prisma.$requestsPayload, S>

  type requestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<requestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestsCountAggregateInputType | true
    }

  export interface requestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['requests'], meta: { name: 'requests' } }
    /**
     * Find zero or one Requests that matches the filter.
     * @param {requestsFindUniqueArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends requestsFindUniqueArgs>(args: SelectSubset<T, requestsFindUniqueArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Requests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {requestsFindUniqueOrThrowArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends requestsFindUniqueOrThrowArgs>(args: SelectSubset<T, requestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestsFindFirstArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends requestsFindFirstArgs>(args?: SelectSubset<T, requestsFindFirstArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestsFindFirstOrThrowArgs} args - Arguments to find a Requests
     * @example
     * // Get one Requests
     * const requests = await prisma.requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends requestsFindFirstOrThrowArgs>(args?: SelectSubset<T, requestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requests
     * const requests = await prisma.requests.findMany()
     * 
     * // Get first 10 Requests
     * const requests = await prisma.requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestsWithIdOnly = await prisma.requests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends requestsFindManyArgs>(args?: SelectSubset<T, requestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Requests.
     * @param {requestsCreateArgs} args - Arguments to create a Requests.
     * @example
     * // Create one Requests
     * const Requests = await prisma.requests.create({
     *   data: {
     *     // ... data to create a Requests
     *   }
     * })
     * 
     */
    create<T extends requestsCreateArgs>(args: SelectSubset<T, requestsCreateArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requests.
     * @param {requestsCreateManyArgs} args - Arguments to create many Requests.
     * @example
     * // Create many Requests
     * const requests = await prisma.requests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends requestsCreateManyArgs>(args?: SelectSubset<T, requestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Requests.
     * @param {requestsDeleteArgs} args - Arguments to delete one Requests.
     * @example
     * // Delete one Requests
     * const Requests = await prisma.requests.delete({
     *   where: {
     *     // ... filter to delete one Requests
     *   }
     * })
     * 
     */
    delete<T extends requestsDeleteArgs>(args: SelectSubset<T, requestsDeleteArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Requests.
     * @param {requestsUpdateArgs} args - Arguments to update one Requests.
     * @example
     * // Update one Requests
     * const requests = await prisma.requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends requestsUpdateArgs>(args: SelectSubset<T, requestsUpdateArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requests.
     * @param {requestsDeleteManyArgs} args - Arguments to filter Requests to delete.
     * @example
     * // Delete a few Requests
     * const { count } = await prisma.requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends requestsDeleteManyArgs>(args?: SelectSubset<T, requestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requests
     * const requests = await prisma.requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends requestsUpdateManyArgs>(args: SelectSubset<T, requestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Requests.
     * @param {requestsUpsertArgs} args - Arguments to update or create a Requests.
     * @example
     * // Update or create a Requests
     * const requests = await prisma.requests.upsert({
     *   create: {
     *     // ... data to create a Requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requests we want to update
     *   }
     * })
     */
    upsert<T extends requestsUpsertArgs>(args: SelectSubset<T, requestsUpsertArgs<ExtArgs>>): Prisma__requestsClient<$Result.GetResult<Prisma.$requestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestsCountArgs} args - Arguments to filter Requests to count.
     * @example
     * // Count the number of Requests
     * const count = await prisma.requests.count({
     *   where: {
     *     // ... the filter for the Requests we want to count
     *   }
     * })
    **/
    count<T extends requestsCountArgs>(
      args?: Subset<T, requestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestsAggregateArgs>(args: Subset<T, RequestsAggregateArgs>): Prisma.PrismaPromise<GetRequestsAggregateType<T>>

    /**
     * Group by Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends requestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: requestsGroupByArgs['orderBy'] }
        : { orderBy?: requestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, requestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the requests model
   */
  readonly fields: requestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__requestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the requests model
   */
  interface requestsFieldRefs {
    readonly id: FieldRef<"requests", 'Int'>
    readonly rfid: FieldRef<"requests", 'BigInt'>
    readonly reqtype: FieldRef<"requests", 'String'>
    readonly reqdate: FieldRef<"requests", 'DateTime'>
    readonly reqneed: FieldRef<"requests", 'DateTime'>
    readonly reqdetails: FieldRef<"requests", 'String'>
    readonly approvedby: FieldRef<"requests", 'BigInt'>
    readonly approvedate: FieldRef<"requests", 'DateTime'>
    readonly approvedfin: FieldRef<"requests", 'BigInt'>
    readonly approvedfindate: FieldRef<"requests", 'DateTime'>
    readonly status: FieldRef<"requests", 'String'>
  }
    

  // Custom InputTypes
  /**
   * requests findUnique
   */
  export type requestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * Filter, which requests to fetch.
     */
    where: requestsWhereUniqueInput
  }

  /**
   * requests findUniqueOrThrow
   */
  export type requestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * Filter, which requests to fetch.
     */
    where: requestsWhereUniqueInput
  }

  /**
   * requests findFirst
   */
  export type requestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * Filter, which requests to fetch.
     */
    where?: requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requests to fetch.
     */
    orderBy?: requestsOrderByWithRelationInput | requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requests.
     */
    cursor?: requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requests.
     */
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[]
  }

  /**
   * requests findFirstOrThrow
   */
  export type requestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * Filter, which requests to fetch.
     */
    where?: requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requests to fetch.
     */
    orderBy?: requestsOrderByWithRelationInput | requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requests.
     */
    cursor?: requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requests.
     */
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[]
  }

  /**
   * requests findMany
   */
  export type requestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * Filter, which requests to fetch.
     */
    where?: requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requests to fetch.
     */
    orderBy?: requestsOrderByWithRelationInput | requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing requests.
     */
    cursor?: requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requests.
     */
    skip?: number
    distinct?: RequestsScalarFieldEnum | RequestsScalarFieldEnum[]
  }

  /**
   * requests create
   */
  export type requestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * The data needed to create a requests.
     */
    data: XOR<requestsCreateInput, requestsUncheckedCreateInput>
  }

  /**
   * requests createMany
   */
  export type requestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many requests.
     */
    data: requestsCreateManyInput | requestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * requests update
   */
  export type requestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * The data needed to update a requests.
     */
    data: XOR<requestsUpdateInput, requestsUncheckedUpdateInput>
    /**
     * Choose, which requests to update.
     */
    where: requestsWhereUniqueInput
  }

  /**
   * requests updateMany
   */
  export type requestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update requests.
     */
    data: XOR<requestsUpdateManyMutationInput, requestsUncheckedUpdateManyInput>
    /**
     * Filter which requests to update
     */
    where?: requestsWhereInput
    /**
     * Limit how many requests to update.
     */
    limit?: number
  }

  /**
   * requests upsert
   */
  export type requestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * The filter to search for the requests to update in case it exists.
     */
    where: requestsWhereUniqueInput
    /**
     * In case the requests found by the `where` argument doesn't exist, create a new requests with this data.
     */
    create: XOR<requestsCreateInput, requestsUncheckedCreateInput>
    /**
     * In case the requests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<requestsUpdateInput, requestsUncheckedUpdateInput>
  }

  /**
   * requests delete
   */
  export type requestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
    /**
     * Filter which requests to delete.
     */
    where: requestsWhereUniqueInput
  }

  /**
   * requests deleteMany
   */
  export type requestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which requests to delete
     */
    where?: requestsWhereInput
    /**
     * Limit how many requests to delete.
     */
    limit?: number
  }

  /**
   * requests without action
   */
  export type requestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requests
     */
    select?: requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requests
     */
    omit?: requestsOmit<ExtArgs> | null
  }


  /**
   * Model s_activities
   */

  export type AggregateS_activities = {
    _count: S_activitiesCountAggregateOutputType | null
    _avg: S_activitiesAvgAggregateOutputType | null
    _sum: S_activitiesSumAggregateOutputType | null
    _min: S_activitiesMinAggregateOutputType | null
    _max: S_activitiesMaxAggregateOutputType | null
  }

  export type S_activitiesAvgAggregateOutputType = {
    id: number | null
    actlvl: number | null
    acttype: number | null
    actqtr: number | null
    maxscore: number | null
    flag: number | null
  }

  export type S_activitiesSumAggregateOutputType = {
    id: number | null
    actlvl: number | null
    acttype: number | null
    actqtr: number | null
    maxscore: number | null
    flag: number | null
  }

  export type S_activitiesMinAggregateOutputType = {
    id: number | null
    actid: string | null
    subjcode: string | null
    actlvl: number | null
    actsection: string | null
    actdate: Date | null
    actcreate: string | null
    actdesc: string | null
    acttype: number | null
    actqtr: number | null
    maxscore: number | null
    flag: number | null
  }

  export type S_activitiesMaxAggregateOutputType = {
    id: number | null
    actid: string | null
    subjcode: string | null
    actlvl: number | null
    actsection: string | null
    actdate: Date | null
    actcreate: string | null
    actdesc: string | null
    acttype: number | null
    actqtr: number | null
    maxscore: number | null
    flag: number | null
  }

  export type S_activitiesCountAggregateOutputType = {
    id: number
    actid: number
    subjcode: number
    actlvl: number
    actsection: number
    actdate: number
    actcreate: number
    actdesc: number
    acttype: number
    actqtr: number
    maxscore: number
    flag: number
    _all: number
  }


  export type S_activitiesAvgAggregateInputType = {
    id?: true
    actlvl?: true
    acttype?: true
    actqtr?: true
    maxscore?: true
    flag?: true
  }

  export type S_activitiesSumAggregateInputType = {
    id?: true
    actlvl?: true
    acttype?: true
    actqtr?: true
    maxscore?: true
    flag?: true
  }

  export type S_activitiesMinAggregateInputType = {
    id?: true
    actid?: true
    subjcode?: true
    actlvl?: true
    actsection?: true
    actdate?: true
    actcreate?: true
    actdesc?: true
    acttype?: true
    actqtr?: true
    maxscore?: true
    flag?: true
  }

  export type S_activitiesMaxAggregateInputType = {
    id?: true
    actid?: true
    subjcode?: true
    actlvl?: true
    actsection?: true
    actdate?: true
    actcreate?: true
    actdesc?: true
    acttype?: true
    actqtr?: true
    maxscore?: true
    flag?: true
  }

  export type S_activitiesCountAggregateInputType = {
    id?: true
    actid?: true
    subjcode?: true
    actlvl?: true
    actsection?: true
    actdate?: true
    actcreate?: true
    actdesc?: true
    acttype?: true
    actqtr?: true
    maxscore?: true
    flag?: true
    _all?: true
  }

  export type S_activitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_activities to aggregate.
     */
    where?: s_activitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_activities to fetch.
     */
    orderBy?: s_activitiesOrderByWithRelationInput | s_activitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: s_activitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned s_activities
    **/
    _count?: true | S_activitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: S_activitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: S_activitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S_activitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S_activitiesMaxAggregateInputType
  }

  export type GetS_activitiesAggregateType<T extends S_activitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateS_activities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS_activities[P]>
      : GetScalarType<T[P], AggregateS_activities[P]>
  }




  export type s_activitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: s_activitiesWhereInput
    orderBy?: s_activitiesOrderByWithAggregationInput | s_activitiesOrderByWithAggregationInput[]
    by: S_activitiesScalarFieldEnum[] | S_activitiesScalarFieldEnum
    having?: s_activitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S_activitiesCountAggregateInputType | true
    _avg?: S_activitiesAvgAggregateInputType
    _sum?: S_activitiesSumAggregateInputType
    _min?: S_activitiesMinAggregateInputType
    _max?: S_activitiesMaxAggregateInputType
  }

  export type S_activitiesGroupByOutputType = {
    id: number
    actid: string
    subjcode: string
    actlvl: number
    actsection: string
    actdate: Date
    actcreate: string
    actdesc: string
    acttype: number
    actqtr: number
    maxscore: number
    flag: number
    _count: S_activitiesCountAggregateOutputType | null
    _avg: S_activitiesAvgAggregateOutputType | null
    _sum: S_activitiesSumAggregateOutputType | null
    _min: S_activitiesMinAggregateOutputType | null
    _max: S_activitiesMaxAggregateOutputType | null
  }

  type GetS_activitiesGroupByPayload<T extends s_activitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S_activitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S_activitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S_activitiesGroupByOutputType[P]>
            : GetScalarType<T[P], S_activitiesGroupByOutputType[P]>
        }
      >
    >


  export type s_activitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actid?: boolean
    subjcode?: boolean
    actlvl?: boolean
    actsection?: boolean
    actdate?: boolean
    actcreate?: boolean
    actdesc?: boolean
    acttype?: boolean
    actqtr?: boolean
    maxscore?: boolean
    flag?: boolean
  }, ExtArgs["result"]["s_activities"]>



  export type s_activitiesSelectScalar = {
    id?: boolean
    actid?: boolean
    subjcode?: boolean
    actlvl?: boolean
    actsection?: boolean
    actdate?: boolean
    actcreate?: boolean
    actdesc?: boolean
    acttype?: boolean
    actqtr?: boolean
    maxscore?: boolean
    flag?: boolean
  }

  export type s_activitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actid" | "subjcode" | "actlvl" | "actsection" | "actdate" | "actcreate" | "actdesc" | "acttype" | "actqtr" | "maxscore" | "flag", ExtArgs["result"]["s_activities"]>

  export type $s_activitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "s_activities"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      actid: string
      subjcode: string
      actlvl: number
      actsection: string
      actdate: Date
      actcreate: string
      actdesc: string
      acttype: number
      actqtr: number
      maxscore: number
      flag: number
    }, ExtArgs["result"]["s_activities"]>
    composites: {}
  }

  type s_activitiesGetPayload<S extends boolean | null | undefined | s_activitiesDefaultArgs> = $Result.GetResult<Prisma.$s_activitiesPayload, S>

  type s_activitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<s_activitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S_activitiesCountAggregateInputType | true
    }

  export interface s_activitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['s_activities'], meta: { name: 's_activities' } }
    /**
     * Find zero or one S_activities that matches the filter.
     * @param {s_activitiesFindUniqueArgs} args - Arguments to find a S_activities
     * @example
     * // Get one S_activities
     * const s_activities = await prisma.s_activities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends s_activitiesFindUniqueArgs>(args: SelectSubset<T, s_activitiesFindUniqueArgs<ExtArgs>>): Prisma__s_activitiesClient<$Result.GetResult<Prisma.$s_activitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S_activities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {s_activitiesFindUniqueOrThrowArgs} args - Arguments to find a S_activities
     * @example
     * // Get one S_activities
     * const s_activities = await prisma.s_activities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends s_activitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, s_activitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__s_activitiesClient<$Result.GetResult<Prisma.$s_activitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_activitiesFindFirstArgs} args - Arguments to find a S_activities
     * @example
     * // Get one S_activities
     * const s_activities = await prisma.s_activities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends s_activitiesFindFirstArgs>(args?: SelectSubset<T, s_activitiesFindFirstArgs<ExtArgs>>): Prisma__s_activitiesClient<$Result.GetResult<Prisma.$s_activitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_activities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_activitiesFindFirstOrThrowArgs} args - Arguments to find a S_activities
     * @example
     * // Get one S_activities
     * const s_activities = await prisma.s_activities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends s_activitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, s_activitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__s_activitiesClient<$Result.GetResult<Prisma.$s_activitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S_activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_activitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S_activities
     * const s_activities = await prisma.s_activities.findMany()
     * 
     * // Get first 10 S_activities
     * const s_activities = await prisma.s_activities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const s_activitiesWithIdOnly = await prisma.s_activities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends s_activitiesFindManyArgs>(args?: SelectSubset<T, s_activitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$s_activitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S_activities.
     * @param {s_activitiesCreateArgs} args - Arguments to create a S_activities.
     * @example
     * // Create one S_activities
     * const S_activities = await prisma.s_activities.create({
     *   data: {
     *     // ... data to create a S_activities
     *   }
     * })
     * 
     */
    create<T extends s_activitiesCreateArgs>(args: SelectSubset<T, s_activitiesCreateArgs<ExtArgs>>): Prisma__s_activitiesClient<$Result.GetResult<Prisma.$s_activitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S_activities.
     * @param {s_activitiesCreateManyArgs} args - Arguments to create many S_activities.
     * @example
     * // Create many S_activities
     * const s_activities = await prisma.s_activities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends s_activitiesCreateManyArgs>(args?: SelectSubset<T, s_activitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a S_activities.
     * @param {s_activitiesDeleteArgs} args - Arguments to delete one S_activities.
     * @example
     * // Delete one S_activities
     * const S_activities = await prisma.s_activities.delete({
     *   where: {
     *     // ... filter to delete one S_activities
     *   }
     * })
     * 
     */
    delete<T extends s_activitiesDeleteArgs>(args: SelectSubset<T, s_activitiesDeleteArgs<ExtArgs>>): Prisma__s_activitiesClient<$Result.GetResult<Prisma.$s_activitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S_activities.
     * @param {s_activitiesUpdateArgs} args - Arguments to update one S_activities.
     * @example
     * // Update one S_activities
     * const s_activities = await prisma.s_activities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends s_activitiesUpdateArgs>(args: SelectSubset<T, s_activitiesUpdateArgs<ExtArgs>>): Prisma__s_activitiesClient<$Result.GetResult<Prisma.$s_activitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S_activities.
     * @param {s_activitiesDeleteManyArgs} args - Arguments to filter S_activities to delete.
     * @example
     * // Delete a few S_activities
     * const { count } = await prisma.s_activities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends s_activitiesDeleteManyArgs>(args?: SelectSubset<T, s_activitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S_activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_activitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S_activities
     * const s_activities = await prisma.s_activities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends s_activitiesUpdateManyArgs>(args: SelectSubset<T, s_activitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one S_activities.
     * @param {s_activitiesUpsertArgs} args - Arguments to update or create a S_activities.
     * @example
     * // Update or create a S_activities
     * const s_activities = await prisma.s_activities.upsert({
     *   create: {
     *     // ... data to create a S_activities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S_activities we want to update
     *   }
     * })
     */
    upsert<T extends s_activitiesUpsertArgs>(args: SelectSubset<T, s_activitiesUpsertArgs<ExtArgs>>): Prisma__s_activitiesClient<$Result.GetResult<Prisma.$s_activitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S_activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_activitiesCountArgs} args - Arguments to filter S_activities to count.
     * @example
     * // Count the number of S_activities
     * const count = await prisma.s_activities.count({
     *   where: {
     *     // ... the filter for the S_activities we want to count
     *   }
     * })
    **/
    count<T extends s_activitiesCountArgs>(
      args?: Subset<T, s_activitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S_activitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S_activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S_activitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S_activitiesAggregateArgs>(args: Subset<T, S_activitiesAggregateArgs>): Prisma.PrismaPromise<GetS_activitiesAggregateType<T>>

    /**
     * Group by S_activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_activitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends s_activitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: s_activitiesGroupByArgs['orderBy'] }
        : { orderBy?: s_activitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, s_activitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS_activitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the s_activities model
   */
  readonly fields: s_activitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for s_activities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__s_activitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the s_activities model
   */
  interface s_activitiesFieldRefs {
    readonly id: FieldRef<"s_activities", 'Int'>
    readonly actid: FieldRef<"s_activities", 'String'>
    readonly subjcode: FieldRef<"s_activities", 'String'>
    readonly actlvl: FieldRef<"s_activities", 'Int'>
    readonly actsection: FieldRef<"s_activities", 'String'>
    readonly actdate: FieldRef<"s_activities", 'DateTime'>
    readonly actcreate: FieldRef<"s_activities", 'String'>
    readonly actdesc: FieldRef<"s_activities", 'String'>
    readonly acttype: FieldRef<"s_activities", 'Int'>
    readonly actqtr: FieldRef<"s_activities", 'Int'>
    readonly maxscore: FieldRef<"s_activities", 'Int'>
    readonly flag: FieldRef<"s_activities", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * s_activities findUnique
   */
  export type s_activitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_activities
     */
    select?: s_activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_activities
     */
    omit?: s_activitiesOmit<ExtArgs> | null
    /**
     * Filter, which s_activities to fetch.
     */
    where: s_activitiesWhereUniqueInput
  }

  /**
   * s_activities findUniqueOrThrow
   */
  export type s_activitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_activities
     */
    select?: s_activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_activities
     */
    omit?: s_activitiesOmit<ExtArgs> | null
    /**
     * Filter, which s_activities to fetch.
     */
    where: s_activitiesWhereUniqueInput
  }

  /**
   * s_activities findFirst
   */
  export type s_activitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_activities
     */
    select?: s_activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_activities
     */
    omit?: s_activitiesOmit<ExtArgs> | null
    /**
     * Filter, which s_activities to fetch.
     */
    where?: s_activitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_activities to fetch.
     */
    orderBy?: s_activitiesOrderByWithRelationInput | s_activitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_activities.
     */
    cursor?: s_activitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_activities.
     */
    distinct?: S_activitiesScalarFieldEnum | S_activitiesScalarFieldEnum[]
  }

  /**
   * s_activities findFirstOrThrow
   */
  export type s_activitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_activities
     */
    select?: s_activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_activities
     */
    omit?: s_activitiesOmit<ExtArgs> | null
    /**
     * Filter, which s_activities to fetch.
     */
    where?: s_activitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_activities to fetch.
     */
    orderBy?: s_activitiesOrderByWithRelationInput | s_activitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_activities.
     */
    cursor?: s_activitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_activities.
     */
    distinct?: S_activitiesScalarFieldEnum | S_activitiesScalarFieldEnum[]
  }

  /**
   * s_activities findMany
   */
  export type s_activitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_activities
     */
    select?: s_activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_activities
     */
    omit?: s_activitiesOmit<ExtArgs> | null
    /**
     * Filter, which s_activities to fetch.
     */
    where?: s_activitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_activities to fetch.
     */
    orderBy?: s_activitiesOrderByWithRelationInput | s_activitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing s_activities.
     */
    cursor?: s_activitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_activities.
     */
    skip?: number
    distinct?: S_activitiesScalarFieldEnum | S_activitiesScalarFieldEnum[]
  }

  /**
   * s_activities create
   */
  export type s_activitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_activities
     */
    select?: s_activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_activities
     */
    omit?: s_activitiesOmit<ExtArgs> | null
    /**
     * The data needed to create a s_activities.
     */
    data: XOR<s_activitiesCreateInput, s_activitiesUncheckedCreateInput>
  }

  /**
   * s_activities createMany
   */
  export type s_activitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many s_activities.
     */
    data: s_activitiesCreateManyInput | s_activitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * s_activities update
   */
  export type s_activitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_activities
     */
    select?: s_activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_activities
     */
    omit?: s_activitiesOmit<ExtArgs> | null
    /**
     * The data needed to update a s_activities.
     */
    data: XOR<s_activitiesUpdateInput, s_activitiesUncheckedUpdateInput>
    /**
     * Choose, which s_activities to update.
     */
    where: s_activitiesWhereUniqueInput
  }

  /**
   * s_activities updateMany
   */
  export type s_activitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update s_activities.
     */
    data: XOR<s_activitiesUpdateManyMutationInput, s_activitiesUncheckedUpdateManyInput>
    /**
     * Filter which s_activities to update
     */
    where?: s_activitiesWhereInput
    /**
     * Limit how many s_activities to update.
     */
    limit?: number
  }

  /**
   * s_activities upsert
   */
  export type s_activitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_activities
     */
    select?: s_activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_activities
     */
    omit?: s_activitiesOmit<ExtArgs> | null
    /**
     * The filter to search for the s_activities to update in case it exists.
     */
    where: s_activitiesWhereUniqueInput
    /**
     * In case the s_activities found by the `where` argument doesn't exist, create a new s_activities with this data.
     */
    create: XOR<s_activitiesCreateInput, s_activitiesUncheckedCreateInput>
    /**
     * In case the s_activities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<s_activitiesUpdateInput, s_activitiesUncheckedUpdateInput>
  }

  /**
   * s_activities delete
   */
  export type s_activitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_activities
     */
    select?: s_activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_activities
     */
    omit?: s_activitiesOmit<ExtArgs> | null
    /**
     * Filter which s_activities to delete.
     */
    where: s_activitiesWhereUniqueInput
  }

  /**
   * s_activities deleteMany
   */
  export type s_activitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_activities to delete
     */
    where?: s_activitiesWhereInput
    /**
     * Limit how many s_activities to delete.
     */
    limit?: number
  }

  /**
   * s_activities without action
   */
  export type s_activitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_activities
     */
    select?: s_activitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_activities
     */
    omit?: s_activitiesOmit<ExtArgs> | null
  }


  /**
   * Model s_classattendance
   */

  export type AggregateS_classattendance = {
    _count: S_classattendanceCountAggregateOutputType | null
    _avg: S_classattendanceAvgAggregateOutputType | null
    _sum: S_classattendanceSumAggregateOutputType | null
    _min: S_classattendanceMinAggregateOutputType | null
    _max: S_classattendanceMaxAggregateOutputType | null
  }

  export type S_classattendanceAvgAggregateOutputType = {
    id: number | null
    attendance: number | null
  }

  export type S_classattendanceSumAggregateOutputType = {
    id: number | null
    attendance: number | null
  }

  export type S_classattendanceMinAggregateOutputType = {
    id: number | null
    attendance: number | null
    subjid: string | null
    studid: string | null
    adate: Date | null
    tid: string | null
    notes: string | null
  }

  export type S_classattendanceMaxAggregateOutputType = {
    id: number | null
    attendance: number | null
    subjid: string | null
    studid: string | null
    adate: Date | null
    tid: string | null
    notes: string | null
  }

  export type S_classattendanceCountAggregateOutputType = {
    id: number
    attendance: number
    subjid: number
    studid: number
    adate: number
    tid: number
    notes: number
    _all: number
  }


  export type S_classattendanceAvgAggregateInputType = {
    id?: true
    attendance?: true
  }

  export type S_classattendanceSumAggregateInputType = {
    id?: true
    attendance?: true
  }

  export type S_classattendanceMinAggregateInputType = {
    id?: true
    attendance?: true
    subjid?: true
    studid?: true
    adate?: true
    tid?: true
    notes?: true
  }

  export type S_classattendanceMaxAggregateInputType = {
    id?: true
    attendance?: true
    subjid?: true
    studid?: true
    adate?: true
    tid?: true
    notes?: true
  }

  export type S_classattendanceCountAggregateInputType = {
    id?: true
    attendance?: true
    subjid?: true
    studid?: true
    adate?: true
    tid?: true
    notes?: true
    _all?: true
  }

  export type S_classattendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_classattendance to aggregate.
     */
    where?: s_classattendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_classattendances to fetch.
     */
    orderBy?: s_classattendanceOrderByWithRelationInput | s_classattendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: s_classattendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_classattendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_classattendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned s_classattendances
    **/
    _count?: true | S_classattendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: S_classattendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: S_classattendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S_classattendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S_classattendanceMaxAggregateInputType
  }

  export type GetS_classattendanceAggregateType<T extends S_classattendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateS_classattendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS_classattendance[P]>
      : GetScalarType<T[P], AggregateS_classattendance[P]>
  }




  export type s_classattendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: s_classattendanceWhereInput
    orderBy?: s_classattendanceOrderByWithAggregationInput | s_classattendanceOrderByWithAggregationInput[]
    by: S_classattendanceScalarFieldEnum[] | S_classattendanceScalarFieldEnum
    having?: s_classattendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S_classattendanceCountAggregateInputType | true
    _avg?: S_classattendanceAvgAggregateInputType
    _sum?: S_classattendanceSumAggregateInputType
    _min?: S_classattendanceMinAggregateInputType
    _max?: S_classattendanceMaxAggregateInputType
  }

  export type S_classattendanceGroupByOutputType = {
    id: number
    attendance: number
    subjid: string
    studid: string
    adate: Date
    tid: string
    notes: string
    _count: S_classattendanceCountAggregateOutputType | null
    _avg: S_classattendanceAvgAggregateOutputType | null
    _sum: S_classattendanceSumAggregateOutputType | null
    _min: S_classattendanceMinAggregateOutputType | null
    _max: S_classattendanceMaxAggregateOutputType | null
  }

  type GetS_classattendanceGroupByPayload<T extends s_classattendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S_classattendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S_classattendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S_classattendanceGroupByOutputType[P]>
            : GetScalarType<T[P], S_classattendanceGroupByOutputType[P]>
        }
      >
    >


  export type s_classattendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attendance?: boolean
    subjid?: boolean
    studid?: boolean
    adate?: boolean
    tid?: boolean
    notes?: boolean
  }, ExtArgs["result"]["s_classattendance"]>



  export type s_classattendanceSelectScalar = {
    id?: boolean
    attendance?: boolean
    subjid?: boolean
    studid?: boolean
    adate?: boolean
    tid?: boolean
    notes?: boolean
  }

  export type s_classattendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "attendance" | "subjid" | "studid" | "adate" | "tid" | "notes", ExtArgs["result"]["s_classattendance"]>

  export type $s_classattendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "s_classattendance"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      attendance: number
      subjid: string
      studid: string
      adate: Date
      tid: string
      notes: string
    }, ExtArgs["result"]["s_classattendance"]>
    composites: {}
  }

  type s_classattendanceGetPayload<S extends boolean | null | undefined | s_classattendanceDefaultArgs> = $Result.GetResult<Prisma.$s_classattendancePayload, S>

  type s_classattendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<s_classattendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S_classattendanceCountAggregateInputType | true
    }

  export interface s_classattendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['s_classattendance'], meta: { name: 's_classattendance' } }
    /**
     * Find zero or one S_classattendance that matches the filter.
     * @param {s_classattendanceFindUniqueArgs} args - Arguments to find a S_classattendance
     * @example
     * // Get one S_classattendance
     * const s_classattendance = await prisma.s_classattendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends s_classattendanceFindUniqueArgs>(args: SelectSubset<T, s_classattendanceFindUniqueArgs<ExtArgs>>): Prisma__s_classattendanceClient<$Result.GetResult<Prisma.$s_classattendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S_classattendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {s_classattendanceFindUniqueOrThrowArgs} args - Arguments to find a S_classattendance
     * @example
     * // Get one S_classattendance
     * const s_classattendance = await prisma.s_classattendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends s_classattendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, s_classattendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__s_classattendanceClient<$Result.GetResult<Prisma.$s_classattendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_classattendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_classattendanceFindFirstArgs} args - Arguments to find a S_classattendance
     * @example
     * // Get one S_classattendance
     * const s_classattendance = await prisma.s_classattendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends s_classattendanceFindFirstArgs>(args?: SelectSubset<T, s_classattendanceFindFirstArgs<ExtArgs>>): Prisma__s_classattendanceClient<$Result.GetResult<Prisma.$s_classattendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_classattendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_classattendanceFindFirstOrThrowArgs} args - Arguments to find a S_classattendance
     * @example
     * // Get one S_classattendance
     * const s_classattendance = await prisma.s_classattendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends s_classattendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, s_classattendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__s_classattendanceClient<$Result.GetResult<Prisma.$s_classattendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S_classattendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_classattendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S_classattendances
     * const s_classattendances = await prisma.s_classattendance.findMany()
     * 
     * // Get first 10 S_classattendances
     * const s_classattendances = await prisma.s_classattendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const s_classattendanceWithIdOnly = await prisma.s_classattendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends s_classattendanceFindManyArgs>(args?: SelectSubset<T, s_classattendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$s_classattendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S_classattendance.
     * @param {s_classattendanceCreateArgs} args - Arguments to create a S_classattendance.
     * @example
     * // Create one S_classattendance
     * const S_classattendance = await prisma.s_classattendance.create({
     *   data: {
     *     // ... data to create a S_classattendance
     *   }
     * })
     * 
     */
    create<T extends s_classattendanceCreateArgs>(args: SelectSubset<T, s_classattendanceCreateArgs<ExtArgs>>): Prisma__s_classattendanceClient<$Result.GetResult<Prisma.$s_classattendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S_classattendances.
     * @param {s_classattendanceCreateManyArgs} args - Arguments to create many S_classattendances.
     * @example
     * // Create many S_classattendances
     * const s_classattendance = await prisma.s_classattendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends s_classattendanceCreateManyArgs>(args?: SelectSubset<T, s_classattendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a S_classattendance.
     * @param {s_classattendanceDeleteArgs} args - Arguments to delete one S_classattendance.
     * @example
     * // Delete one S_classattendance
     * const S_classattendance = await prisma.s_classattendance.delete({
     *   where: {
     *     // ... filter to delete one S_classattendance
     *   }
     * })
     * 
     */
    delete<T extends s_classattendanceDeleteArgs>(args: SelectSubset<T, s_classattendanceDeleteArgs<ExtArgs>>): Prisma__s_classattendanceClient<$Result.GetResult<Prisma.$s_classattendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S_classattendance.
     * @param {s_classattendanceUpdateArgs} args - Arguments to update one S_classattendance.
     * @example
     * // Update one S_classattendance
     * const s_classattendance = await prisma.s_classattendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends s_classattendanceUpdateArgs>(args: SelectSubset<T, s_classattendanceUpdateArgs<ExtArgs>>): Prisma__s_classattendanceClient<$Result.GetResult<Prisma.$s_classattendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S_classattendances.
     * @param {s_classattendanceDeleteManyArgs} args - Arguments to filter S_classattendances to delete.
     * @example
     * // Delete a few S_classattendances
     * const { count } = await prisma.s_classattendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends s_classattendanceDeleteManyArgs>(args?: SelectSubset<T, s_classattendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S_classattendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_classattendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S_classattendances
     * const s_classattendance = await prisma.s_classattendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends s_classattendanceUpdateManyArgs>(args: SelectSubset<T, s_classattendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one S_classattendance.
     * @param {s_classattendanceUpsertArgs} args - Arguments to update or create a S_classattendance.
     * @example
     * // Update or create a S_classattendance
     * const s_classattendance = await prisma.s_classattendance.upsert({
     *   create: {
     *     // ... data to create a S_classattendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S_classattendance we want to update
     *   }
     * })
     */
    upsert<T extends s_classattendanceUpsertArgs>(args: SelectSubset<T, s_classattendanceUpsertArgs<ExtArgs>>): Prisma__s_classattendanceClient<$Result.GetResult<Prisma.$s_classattendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S_classattendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_classattendanceCountArgs} args - Arguments to filter S_classattendances to count.
     * @example
     * // Count the number of S_classattendances
     * const count = await prisma.s_classattendance.count({
     *   where: {
     *     // ... the filter for the S_classattendances we want to count
     *   }
     * })
    **/
    count<T extends s_classattendanceCountArgs>(
      args?: Subset<T, s_classattendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S_classattendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S_classattendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S_classattendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S_classattendanceAggregateArgs>(args: Subset<T, S_classattendanceAggregateArgs>): Prisma.PrismaPromise<GetS_classattendanceAggregateType<T>>

    /**
     * Group by S_classattendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_classattendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends s_classattendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: s_classattendanceGroupByArgs['orderBy'] }
        : { orderBy?: s_classattendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, s_classattendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS_classattendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the s_classattendance model
   */
  readonly fields: s_classattendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for s_classattendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__s_classattendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the s_classattendance model
   */
  interface s_classattendanceFieldRefs {
    readonly id: FieldRef<"s_classattendance", 'Int'>
    readonly attendance: FieldRef<"s_classattendance", 'Int'>
    readonly subjid: FieldRef<"s_classattendance", 'String'>
    readonly studid: FieldRef<"s_classattendance", 'String'>
    readonly adate: FieldRef<"s_classattendance", 'DateTime'>
    readonly tid: FieldRef<"s_classattendance", 'String'>
    readonly notes: FieldRef<"s_classattendance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * s_classattendance findUnique
   */
  export type s_classattendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_classattendance
     */
    select?: s_classattendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_classattendance
     */
    omit?: s_classattendanceOmit<ExtArgs> | null
    /**
     * Filter, which s_classattendance to fetch.
     */
    where: s_classattendanceWhereUniqueInput
  }

  /**
   * s_classattendance findUniqueOrThrow
   */
  export type s_classattendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_classattendance
     */
    select?: s_classattendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_classattendance
     */
    omit?: s_classattendanceOmit<ExtArgs> | null
    /**
     * Filter, which s_classattendance to fetch.
     */
    where: s_classattendanceWhereUniqueInput
  }

  /**
   * s_classattendance findFirst
   */
  export type s_classattendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_classattendance
     */
    select?: s_classattendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_classattendance
     */
    omit?: s_classattendanceOmit<ExtArgs> | null
    /**
     * Filter, which s_classattendance to fetch.
     */
    where?: s_classattendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_classattendances to fetch.
     */
    orderBy?: s_classattendanceOrderByWithRelationInput | s_classattendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_classattendances.
     */
    cursor?: s_classattendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_classattendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_classattendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_classattendances.
     */
    distinct?: S_classattendanceScalarFieldEnum | S_classattendanceScalarFieldEnum[]
  }

  /**
   * s_classattendance findFirstOrThrow
   */
  export type s_classattendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_classattendance
     */
    select?: s_classattendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_classattendance
     */
    omit?: s_classattendanceOmit<ExtArgs> | null
    /**
     * Filter, which s_classattendance to fetch.
     */
    where?: s_classattendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_classattendances to fetch.
     */
    orderBy?: s_classattendanceOrderByWithRelationInput | s_classattendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_classattendances.
     */
    cursor?: s_classattendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_classattendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_classattendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_classattendances.
     */
    distinct?: S_classattendanceScalarFieldEnum | S_classattendanceScalarFieldEnum[]
  }

  /**
   * s_classattendance findMany
   */
  export type s_classattendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_classattendance
     */
    select?: s_classattendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_classattendance
     */
    omit?: s_classattendanceOmit<ExtArgs> | null
    /**
     * Filter, which s_classattendances to fetch.
     */
    where?: s_classattendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_classattendances to fetch.
     */
    orderBy?: s_classattendanceOrderByWithRelationInput | s_classattendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing s_classattendances.
     */
    cursor?: s_classattendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_classattendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_classattendances.
     */
    skip?: number
    distinct?: S_classattendanceScalarFieldEnum | S_classattendanceScalarFieldEnum[]
  }

  /**
   * s_classattendance create
   */
  export type s_classattendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_classattendance
     */
    select?: s_classattendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_classattendance
     */
    omit?: s_classattendanceOmit<ExtArgs> | null
    /**
     * The data needed to create a s_classattendance.
     */
    data: XOR<s_classattendanceCreateInput, s_classattendanceUncheckedCreateInput>
  }

  /**
   * s_classattendance createMany
   */
  export type s_classattendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many s_classattendances.
     */
    data: s_classattendanceCreateManyInput | s_classattendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * s_classattendance update
   */
  export type s_classattendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_classattendance
     */
    select?: s_classattendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_classattendance
     */
    omit?: s_classattendanceOmit<ExtArgs> | null
    /**
     * The data needed to update a s_classattendance.
     */
    data: XOR<s_classattendanceUpdateInput, s_classattendanceUncheckedUpdateInput>
    /**
     * Choose, which s_classattendance to update.
     */
    where: s_classattendanceWhereUniqueInput
  }

  /**
   * s_classattendance updateMany
   */
  export type s_classattendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update s_classattendances.
     */
    data: XOR<s_classattendanceUpdateManyMutationInput, s_classattendanceUncheckedUpdateManyInput>
    /**
     * Filter which s_classattendances to update
     */
    where?: s_classattendanceWhereInput
    /**
     * Limit how many s_classattendances to update.
     */
    limit?: number
  }

  /**
   * s_classattendance upsert
   */
  export type s_classattendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_classattendance
     */
    select?: s_classattendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_classattendance
     */
    omit?: s_classattendanceOmit<ExtArgs> | null
    /**
     * The filter to search for the s_classattendance to update in case it exists.
     */
    where: s_classattendanceWhereUniqueInput
    /**
     * In case the s_classattendance found by the `where` argument doesn't exist, create a new s_classattendance with this data.
     */
    create: XOR<s_classattendanceCreateInput, s_classattendanceUncheckedCreateInput>
    /**
     * In case the s_classattendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<s_classattendanceUpdateInput, s_classattendanceUncheckedUpdateInput>
  }

  /**
   * s_classattendance delete
   */
  export type s_classattendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_classattendance
     */
    select?: s_classattendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_classattendance
     */
    omit?: s_classattendanceOmit<ExtArgs> | null
    /**
     * Filter which s_classattendance to delete.
     */
    where: s_classattendanceWhereUniqueInput
  }

  /**
   * s_classattendance deleteMany
   */
  export type s_classattendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_classattendances to delete
     */
    where?: s_classattendanceWhereInput
    /**
     * Limit how many s_classattendances to delete.
     */
    limit?: number
  }

  /**
   * s_classattendance without action
   */
  export type s_classattendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_classattendance
     */
    select?: s_classattendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_classattendance
     */
    omit?: s_classattendanceOmit<ExtArgs> | null
  }


  /**
   * Model s_coretable
   */

  export type AggregateS_coretable = {
    _count: S_coretableCountAggregateOutputType | null
    _avg: S_coretableAvgAggregateOutputType | null
    _sum: S_coretableSumAggregateOutputType | null
    _min: S_coretableMinAggregateOutputType | null
    _max: S_coretableMaxAggregateOutputType | null
  }

  export type S_coretableAvgAggregateOutputType = {
    id: number | null
    start: Decimal | null
    end: Decimal | null
  }

  export type S_coretableSumAggregateOutputType = {
    id: number | null
    start: Decimal | null
    end: Decimal | null
  }

  export type S_coretableMinAggregateOutputType = {
    id: number | null
    start: Decimal | null
    end: Decimal | null
    grade: string | null
  }

  export type S_coretableMaxAggregateOutputType = {
    id: number | null
    start: Decimal | null
    end: Decimal | null
    grade: string | null
  }

  export type S_coretableCountAggregateOutputType = {
    id: number
    start: number
    end: number
    grade: number
    _all: number
  }


  export type S_coretableAvgAggregateInputType = {
    id?: true
    start?: true
    end?: true
  }

  export type S_coretableSumAggregateInputType = {
    id?: true
    start?: true
    end?: true
  }

  export type S_coretableMinAggregateInputType = {
    id?: true
    start?: true
    end?: true
    grade?: true
  }

  export type S_coretableMaxAggregateInputType = {
    id?: true
    start?: true
    end?: true
    grade?: true
  }

  export type S_coretableCountAggregateInputType = {
    id?: true
    start?: true
    end?: true
    grade?: true
    _all?: true
  }

  export type S_coretableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_coretable to aggregate.
     */
    where?: s_coretableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_coretables to fetch.
     */
    orderBy?: s_coretableOrderByWithRelationInput | s_coretableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: s_coretableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_coretables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_coretables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned s_coretables
    **/
    _count?: true | S_coretableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: S_coretableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: S_coretableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S_coretableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S_coretableMaxAggregateInputType
  }

  export type GetS_coretableAggregateType<T extends S_coretableAggregateArgs> = {
        [P in keyof T & keyof AggregateS_coretable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS_coretable[P]>
      : GetScalarType<T[P], AggregateS_coretable[P]>
  }




  export type s_coretableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: s_coretableWhereInput
    orderBy?: s_coretableOrderByWithAggregationInput | s_coretableOrderByWithAggregationInput[]
    by: S_coretableScalarFieldEnum[] | S_coretableScalarFieldEnum
    having?: s_coretableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S_coretableCountAggregateInputType | true
    _avg?: S_coretableAvgAggregateInputType
    _sum?: S_coretableSumAggregateInputType
    _min?: S_coretableMinAggregateInputType
    _max?: S_coretableMaxAggregateInputType
  }

  export type S_coretableGroupByOutputType = {
    id: number
    start: Decimal
    end: Decimal
    grade: string
    _count: S_coretableCountAggregateOutputType | null
    _avg: S_coretableAvgAggregateOutputType | null
    _sum: S_coretableSumAggregateOutputType | null
    _min: S_coretableMinAggregateOutputType | null
    _max: S_coretableMaxAggregateOutputType | null
  }

  type GetS_coretableGroupByPayload<T extends s_coretableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S_coretableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S_coretableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S_coretableGroupByOutputType[P]>
            : GetScalarType<T[P], S_coretableGroupByOutputType[P]>
        }
      >
    >


  export type s_coretableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start?: boolean
    end?: boolean
    grade?: boolean
  }, ExtArgs["result"]["s_coretable"]>



  export type s_coretableSelectScalar = {
    id?: boolean
    start?: boolean
    end?: boolean
    grade?: boolean
  }

  export type s_coretableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "start" | "end" | "grade", ExtArgs["result"]["s_coretable"]>

  export type $s_coretablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "s_coretable"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      start: Prisma.Decimal
      end: Prisma.Decimal
      grade: string
    }, ExtArgs["result"]["s_coretable"]>
    composites: {}
  }

  type s_coretableGetPayload<S extends boolean | null | undefined | s_coretableDefaultArgs> = $Result.GetResult<Prisma.$s_coretablePayload, S>

  type s_coretableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<s_coretableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S_coretableCountAggregateInputType | true
    }

  export interface s_coretableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['s_coretable'], meta: { name: 's_coretable' } }
    /**
     * Find zero or one S_coretable that matches the filter.
     * @param {s_coretableFindUniqueArgs} args - Arguments to find a S_coretable
     * @example
     * // Get one S_coretable
     * const s_coretable = await prisma.s_coretable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends s_coretableFindUniqueArgs>(args: SelectSubset<T, s_coretableFindUniqueArgs<ExtArgs>>): Prisma__s_coretableClient<$Result.GetResult<Prisma.$s_coretablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S_coretable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {s_coretableFindUniqueOrThrowArgs} args - Arguments to find a S_coretable
     * @example
     * // Get one S_coretable
     * const s_coretable = await prisma.s_coretable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends s_coretableFindUniqueOrThrowArgs>(args: SelectSubset<T, s_coretableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__s_coretableClient<$Result.GetResult<Prisma.$s_coretablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_coretable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_coretableFindFirstArgs} args - Arguments to find a S_coretable
     * @example
     * // Get one S_coretable
     * const s_coretable = await prisma.s_coretable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends s_coretableFindFirstArgs>(args?: SelectSubset<T, s_coretableFindFirstArgs<ExtArgs>>): Prisma__s_coretableClient<$Result.GetResult<Prisma.$s_coretablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_coretable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_coretableFindFirstOrThrowArgs} args - Arguments to find a S_coretable
     * @example
     * // Get one S_coretable
     * const s_coretable = await prisma.s_coretable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends s_coretableFindFirstOrThrowArgs>(args?: SelectSubset<T, s_coretableFindFirstOrThrowArgs<ExtArgs>>): Prisma__s_coretableClient<$Result.GetResult<Prisma.$s_coretablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S_coretables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_coretableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S_coretables
     * const s_coretables = await prisma.s_coretable.findMany()
     * 
     * // Get first 10 S_coretables
     * const s_coretables = await prisma.s_coretable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const s_coretableWithIdOnly = await prisma.s_coretable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends s_coretableFindManyArgs>(args?: SelectSubset<T, s_coretableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$s_coretablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S_coretable.
     * @param {s_coretableCreateArgs} args - Arguments to create a S_coretable.
     * @example
     * // Create one S_coretable
     * const S_coretable = await prisma.s_coretable.create({
     *   data: {
     *     // ... data to create a S_coretable
     *   }
     * })
     * 
     */
    create<T extends s_coretableCreateArgs>(args: SelectSubset<T, s_coretableCreateArgs<ExtArgs>>): Prisma__s_coretableClient<$Result.GetResult<Prisma.$s_coretablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S_coretables.
     * @param {s_coretableCreateManyArgs} args - Arguments to create many S_coretables.
     * @example
     * // Create many S_coretables
     * const s_coretable = await prisma.s_coretable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends s_coretableCreateManyArgs>(args?: SelectSubset<T, s_coretableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a S_coretable.
     * @param {s_coretableDeleteArgs} args - Arguments to delete one S_coretable.
     * @example
     * // Delete one S_coretable
     * const S_coretable = await prisma.s_coretable.delete({
     *   where: {
     *     // ... filter to delete one S_coretable
     *   }
     * })
     * 
     */
    delete<T extends s_coretableDeleteArgs>(args: SelectSubset<T, s_coretableDeleteArgs<ExtArgs>>): Prisma__s_coretableClient<$Result.GetResult<Prisma.$s_coretablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S_coretable.
     * @param {s_coretableUpdateArgs} args - Arguments to update one S_coretable.
     * @example
     * // Update one S_coretable
     * const s_coretable = await prisma.s_coretable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends s_coretableUpdateArgs>(args: SelectSubset<T, s_coretableUpdateArgs<ExtArgs>>): Prisma__s_coretableClient<$Result.GetResult<Prisma.$s_coretablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S_coretables.
     * @param {s_coretableDeleteManyArgs} args - Arguments to filter S_coretables to delete.
     * @example
     * // Delete a few S_coretables
     * const { count } = await prisma.s_coretable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends s_coretableDeleteManyArgs>(args?: SelectSubset<T, s_coretableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S_coretables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_coretableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S_coretables
     * const s_coretable = await prisma.s_coretable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends s_coretableUpdateManyArgs>(args: SelectSubset<T, s_coretableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one S_coretable.
     * @param {s_coretableUpsertArgs} args - Arguments to update or create a S_coretable.
     * @example
     * // Update or create a S_coretable
     * const s_coretable = await prisma.s_coretable.upsert({
     *   create: {
     *     // ... data to create a S_coretable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S_coretable we want to update
     *   }
     * })
     */
    upsert<T extends s_coretableUpsertArgs>(args: SelectSubset<T, s_coretableUpsertArgs<ExtArgs>>): Prisma__s_coretableClient<$Result.GetResult<Prisma.$s_coretablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S_coretables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_coretableCountArgs} args - Arguments to filter S_coretables to count.
     * @example
     * // Count the number of S_coretables
     * const count = await prisma.s_coretable.count({
     *   where: {
     *     // ... the filter for the S_coretables we want to count
     *   }
     * })
    **/
    count<T extends s_coretableCountArgs>(
      args?: Subset<T, s_coretableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S_coretableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S_coretable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S_coretableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S_coretableAggregateArgs>(args: Subset<T, S_coretableAggregateArgs>): Prisma.PrismaPromise<GetS_coretableAggregateType<T>>

    /**
     * Group by S_coretable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_coretableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends s_coretableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: s_coretableGroupByArgs['orderBy'] }
        : { orderBy?: s_coretableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, s_coretableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS_coretableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the s_coretable model
   */
  readonly fields: s_coretableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for s_coretable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__s_coretableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the s_coretable model
   */
  interface s_coretableFieldRefs {
    readonly id: FieldRef<"s_coretable", 'Int'>
    readonly start: FieldRef<"s_coretable", 'Decimal'>
    readonly end: FieldRef<"s_coretable", 'Decimal'>
    readonly grade: FieldRef<"s_coretable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * s_coretable findUnique
   */
  export type s_coretableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_coretable
     */
    select?: s_coretableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_coretable
     */
    omit?: s_coretableOmit<ExtArgs> | null
    /**
     * Filter, which s_coretable to fetch.
     */
    where: s_coretableWhereUniqueInput
  }

  /**
   * s_coretable findUniqueOrThrow
   */
  export type s_coretableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_coretable
     */
    select?: s_coretableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_coretable
     */
    omit?: s_coretableOmit<ExtArgs> | null
    /**
     * Filter, which s_coretable to fetch.
     */
    where: s_coretableWhereUniqueInput
  }

  /**
   * s_coretable findFirst
   */
  export type s_coretableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_coretable
     */
    select?: s_coretableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_coretable
     */
    omit?: s_coretableOmit<ExtArgs> | null
    /**
     * Filter, which s_coretable to fetch.
     */
    where?: s_coretableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_coretables to fetch.
     */
    orderBy?: s_coretableOrderByWithRelationInput | s_coretableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_coretables.
     */
    cursor?: s_coretableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_coretables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_coretables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_coretables.
     */
    distinct?: S_coretableScalarFieldEnum | S_coretableScalarFieldEnum[]
  }

  /**
   * s_coretable findFirstOrThrow
   */
  export type s_coretableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_coretable
     */
    select?: s_coretableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_coretable
     */
    omit?: s_coretableOmit<ExtArgs> | null
    /**
     * Filter, which s_coretable to fetch.
     */
    where?: s_coretableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_coretables to fetch.
     */
    orderBy?: s_coretableOrderByWithRelationInput | s_coretableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_coretables.
     */
    cursor?: s_coretableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_coretables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_coretables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_coretables.
     */
    distinct?: S_coretableScalarFieldEnum | S_coretableScalarFieldEnum[]
  }

  /**
   * s_coretable findMany
   */
  export type s_coretableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_coretable
     */
    select?: s_coretableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_coretable
     */
    omit?: s_coretableOmit<ExtArgs> | null
    /**
     * Filter, which s_coretables to fetch.
     */
    where?: s_coretableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_coretables to fetch.
     */
    orderBy?: s_coretableOrderByWithRelationInput | s_coretableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing s_coretables.
     */
    cursor?: s_coretableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_coretables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_coretables.
     */
    skip?: number
    distinct?: S_coretableScalarFieldEnum | S_coretableScalarFieldEnum[]
  }

  /**
   * s_coretable create
   */
  export type s_coretableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_coretable
     */
    select?: s_coretableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_coretable
     */
    omit?: s_coretableOmit<ExtArgs> | null
    /**
     * The data needed to create a s_coretable.
     */
    data: XOR<s_coretableCreateInput, s_coretableUncheckedCreateInput>
  }

  /**
   * s_coretable createMany
   */
  export type s_coretableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many s_coretables.
     */
    data: s_coretableCreateManyInput | s_coretableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * s_coretable update
   */
  export type s_coretableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_coretable
     */
    select?: s_coretableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_coretable
     */
    omit?: s_coretableOmit<ExtArgs> | null
    /**
     * The data needed to update a s_coretable.
     */
    data: XOR<s_coretableUpdateInput, s_coretableUncheckedUpdateInput>
    /**
     * Choose, which s_coretable to update.
     */
    where: s_coretableWhereUniqueInput
  }

  /**
   * s_coretable updateMany
   */
  export type s_coretableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update s_coretables.
     */
    data: XOR<s_coretableUpdateManyMutationInput, s_coretableUncheckedUpdateManyInput>
    /**
     * Filter which s_coretables to update
     */
    where?: s_coretableWhereInput
    /**
     * Limit how many s_coretables to update.
     */
    limit?: number
  }

  /**
   * s_coretable upsert
   */
  export type s_coretableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_coretable
     */
    select?: s_coretableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_coretable
     */
    omit?: s_coretableOmit<ExtArgs> | null
    /**
     * The filter to search for the s_coretable to update in case it exists.
     */
    where: s_coretableWhereUniqueInput
    /**
     * In case the s_coretable found by the `where` argument doesn't exist, create a new s_coretable with this data.
     */
    create: XOR<s_coretableCreateInput, s_coretableUncheckedCreateInput>
    /**
     * In case the s_coretable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<s_coretableUpdateInput, s_coretableUncheckedUpdateInput>
  }

  /**
   * s_coretable delete
   */
  export type s_coretableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_coretable
     */
    select?: s_coretableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_coretable
     */
    omit?: s_coretableOmit<ExtArgs> | null
    /**
     * Filter which s_coretable to delete.
     */
    where: s_coretableWhereUniqueInput
  }

  /**
   * s_coretable deleteMany
   */
  export type s_coretableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_coretables to delete
     */
    where?: s_coretableWhereInput
    /**
     * Limit how many s_coretables to delete.
     */
    limit?: number
  }

  /**
   * s_coretable without action
   */
  export type s_coretableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_coretable
     */
    select?: s_coretableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_coretable
     */
    omit?: s_coretableOmit<ExtArgs> | null
  }


  /**
   * Model s_corevalues
   */

  export type AggregateS_corevalues = {
    _count: S_corevaluesCountAggregateOutputType | null
    _avg: S_corevaluesAvgAggregateOutputType | null
    _sum: S_corevaluesSumAggregateOutputType | null
    _min: S_corevaluesMinAggregateOutputType | null
    _max: S_corevaluesMaxAggregateOutputType | null
  }

  export type S_corevaluesAvgAggregateOutputType = {
    id: number | null
  }

  export type S_corevaluesSumAggregateOutputType = {
    id: number | null
  }

  export type S_corevaluesMinAggregateOutputType = {
    id: number | null
    corevalue: string | null
  }

  export type S_corevaluesMaxAggregateOutputType = {
    id: number | null
    corevalue: string | null
  }

  export type S_corevaluesCountAggregateOutputType = {
    id: number
    corevalue: number
    _all: number
  }


  export type S_corevaluesAvgAggregateInputType = {
    id?: true
  }

  export type S_corevaluesSumAggregateInputType = {
    id?: true
  }

  export type S_corevaluesMinAggregateInputType = {
    id?: true
    corevalue?: true
  }

  export type S_corevaluesMaxAggregateInputType = {
    id?: true
    corevalue?: true
  }

  export type S_corevaluesCountAggregateInputType = {
    id?: true
    corevalue?: true
    _all?: true
  }

  export type S_corevaluesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_corevalues to aggregate.
     */
    where?: s_corevaluesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_corevalues to fetch.
     */
    orderBy?: s_corevaluesOrderByWithRelationInput | s_corevaluesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: s_corevaluesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_corevalues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_corevalues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned s_corevalues
    **/
    _count?: true | S_corevaluesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: S_corevaluesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: S_corevaluesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S_corevaluesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S_corevaluesMaxAggregateInputType
  }

  export type GetS_corevaluesAggregateType<T extends S_corevaluesAggregateArgs> = {
        [P in keyof T & keyof AggregateS_corevalues]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS_corevalues[P]>
      : GetScalarType<T[P], AggregateS_corevalues[P]>
  }




  export type s_corevaluesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: s_corevaluesWhereInput
    orderBy?: s_corevaluesOrderByWithAggregationInput | s_corevaluesOrderByWithAggregationInput[]
    by: S_corevaluesScalarFieldEnum[] | S_corevaluesScalarFieldEnum
    having?: s_corevaluesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S_corevaluesCountAggregateInputType | true
    _avg?: S_corevaluesAvgAggregateInputType
    _sum?: S_corevaluesSumAggregateInputType
    _min?: S_corevaluesMinAggregateInputType
    _max?: S_corevaluesMaxAggregateInputType
  }

  export type S_corevaluesGroupByOutputType = {
    id: number
    corevalue: string
    _count: S_corevaluesCountAggregateOutputType | null
    _avg: S_corevaluesAvgAggregateOutputType | null
    _sum: S_corevaluesSumAggregateOutputType | null
    _min: S_corevaluesMinAggregateOutputType | null
    _max: S_corevaluesMaxAggregateOutputType | null
  }

  type GetS_corevaluesGroupByPayload<T extends s_corevaluesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S_corevaluesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S_corevaluesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S_corevaluesGroupByOutputType[P]>
            : GetScalarType<T[P], S_corevaluesGroupByOutputType[P]>
        }
      >
    >


  export type s_corevaluesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    corevalue?: boolean
  }, ExtArgs["result"]["s_corevalues"]>



  export type s_corevaluesSelectScalar = {
    id?: boolean
    corevalue?: boolean
  }

  export type s_corevaluesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "corevalue", ExtArgs["result"]["s_corevalues"]>

  export type $s_corevaluesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "s_corevalues"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      corevalue: string
    }, ExtArgs["result"]["s_corevalues"]>
    composites: {}
  }

  type s_corevaluesGetPayload<S extends boolean | null | undefined | s_corevaluesDefaultArgs> = $Result.GetResult<Prisma.$s_corevaluesPayload, S>

  type s_corevaluesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<s_corevaluesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S_corevaluesCountAggregateInputType | true
    }

  export interface s_corevaluesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['s_corevalues'], meta: { name: 's_corevalues' } }
    /**
     * Find zero or one S_corevalues that matches the filter.
     * @param {s_corevaluesFindUniqueArgs} args - Arguments to find a S_corevalues
     * @example
     * // Get one S_corevalues
     * const s_corevalues = await prisma.s_corevalues.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends s_corevaluesFindUniqueArgs>(args: SelectSubset<T, s_corevaluesFindUniqueArgs<ExtArgs>>): Prisma__s_corevaluesClient<$Result.GetResult<Prisma.$s_corevaluesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S_corevalues that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {s_corevaluesFindUniqueOrThrowArgs} args - Arguments to find a S_corevalues
     * @example
     * // Get one S_corevalues
     * const s_corevalues = await prisma.s_corevalues.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends s_corevaluesFindUniqueOrThrowArgs>(args: SelectSubset<T, s_corevaluesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__s_corevaluesClient<$Result.GetResult<Prisma.$s_corevaluesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_corevalues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_corevaluesFindFirstArgs} args - Arguments to find a S_corevalues
     * @example
     * // Get one S_corevalues
     * const s_corevalues = await prisma.s_corevalues.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends s_corevaluesFindFirstArgs>(args?: SelectSubset<T, s_corevaluesFindFirstArgs<ExtArgs>>): Prisma__s_corevaluesClient<$Result.GetResult<Prisma.$s_corevaluesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_corevalues that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_corevaluesFindFirstOrThrowArgs} args - Arguments to find a S_corevalues
     * @example
     * // Get one S_corevalues
     * const s_corevalues = await prisma.s_corevalues.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends s_corevaluesFindFirstOrThrowArgs>(args?: SelectSubset<T, s_corevaluesFindFirstOrThrowArgs<ExtArgs>>): Prisma__s_corevaluesClient<$Result.GetResult<Prisma.$s_corevaluesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S_corevalues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_corevaluesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S_corevalues
     * const s_corevalues = await prisma.s_corevalues.findMany()
     * 
     * // Get first 10 S_corevalues
     * const s_corevalues = await prisma.s_corevalues.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const s_corevaluesWithIdOnly = await prisma.s_corevalues.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends s_corevaluesFindManyArgs>(args?: SelectSubset<T, s_corevaluesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$s_corevaluesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S_corevalues.
     * @param {s_corevaluesCreateArgs} args - Arguments to create a S_corevalues.
     * @example
     * // Create one S_corevalues
     * const S_corevalues = await prisma.s_corevalues.create({
     *   data: {
     *     // ... data to create a S_corevalues
     *   }
     * })
     * 
     */
    create<T extends s_corevaluesCreateArgs>(args: SelectSubset<T, s_corevaluesCreateArgs<ExtArgs>>): Prisma__s_corevaluesClient<$Result.GetResult<Prisma.$s_corevaluesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S_corevalues.
     * @param {s_corevaluesCreateManyArgs} args - Arguments to create many S_corevalues.
     * @example
     * // Create many S_corevalues
     * const s_corevalues = await prisma.s_corevalues.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends s_corevaluesCreateManyArgs>(args?: SelectSubset<T, s_corevaluesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a S_corevalues.
     * @param {s_corevaluesDeleteArgs} args - Arguments to delete one S_corevalues.
     * @example
     * // Delete one S_corevalues
     * const S_corevalues = await prisma.s_corevalues.delete({
     *   where: {
     *     // ... filter to delete one S_corevalues
     *   }
     * })
     * 
     */
    delete<T extends s_corevaluesDeleteArgs>(args: SelectSubset<T, s_corevaluesDeleteArgs<ExtArgs>>): Prisma__s_corevaluesClient<$Result.GetResult<Prisma.$s_corevaluesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S_corevalues.
     * @param {s_corevaluesUpdateArgs} args - Arguments to update one S_corevalues.
     * @example
     * // Update one S_corevalues
     * const s_corevalues = await prisma.s_corevalues.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends s_corevaluesUpdateArgs>(args: SelectSubset<T, s_corevaluesUpdateArgs<ExtArgs>>): Prisma__s_corevaluesClient<$Result.GetResult<Prisma.$s_corevaluesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S_corevalues.
     * @param {s_corevaluesDeleteManyArgs} args - Arguments to filter S_corevalues to delete.
     * @example
     * // Delete a few S_corevalues
     * const { count } = await prisma.s_corevalues.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends s_corevaluesDeleteManyArgs>(args?: SelectSubset<T, s_corevaluesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S_corevalues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_corevaluesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S_corevalues
     * const s_corevalues = await prisma.s_corevalues.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends s_corevaluesUpdateManyArgs>(args: SelectSubset<T, s_corevaluesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one S_corevalues.
     * @param {s_corevaluesUpsertArgs} args - Arguments to update or create a S_corevalues.
     * @example
     * // Update or create a S_corevalues
     * const s_corevalues = await prisma.s_corevalues.upsert({
     *   create: {
     *     // ... data to create a S_corevalues
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S_corevalues we want to update
     *   }
     * })
     */
    upsert<T extends s_corevaluesUpsertArgs>(args: SelectSubset<T, s_corevaluesUpsertArgs<ExtArgs>>): Prisma__s_corevaluesClient<$Result.GetResult<Prisma.$s_corevaluesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S_corevalues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_corevaluesCountArgs} args - Arguments to filter S_corevalues to count.
     * @example
     * // Count the number of S_corevalues
     * const count = await prisma.s_corevalues.count({
     *   where: {
     *     // ... the filter for the S_corevalues we want to count
     *   }
     * })
    **/
    count<T extends s_corevaluesCountArgs>(
      args?: Subset<T, s_corevaluesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S_corevaluesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S_corevalues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S_corevaluesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S_corevaluesAggregateArgs>(args: Subset<T, S_corevaluesAggregateArgs>): Prisma.PrismaPromise<GetS_corevaluesAggregateType<T>>

    /**
     * Group by S_corevalues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_corevaluesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends s_corevaluesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: s_corevaluesGroupByArgs['orderBy'] }
        : { orderBy?: s_corevaluesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, s_corevaluesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS_corevaluesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the s_corevalues model
   */
  readonly fields: s_corevaluesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for s_corevalues.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__s_corevaluesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the s_corevalues model
   */
  interface s_corevaluesFieldRefs {
    readonly id: FieldRef<"s_corevalues", 'Int'>
    readonly corevalue: FieldRef<"s_corevalues", 'String'>
  }
    

  // Custom InputTypes
  /**
   * s_corevalues findUnique
   */
  export type s_corevaluesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_corevalues
     */
    select?: s_corevaluesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_corevalues
     */
    omit?: s_corevaluesOmit<ExtArgs> | null
    /**
     * Filter, which s_corevalues to fetch.
     */
    where: s_corevaluesWhereUniqueInput
  }

  /**
   * s_corevalues findUniqueOrThrow
   */
  export type s_corevaluesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_corevalues
     */
    select?: s_corevaluesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_corevalues
     */
    omit?: s_corevaluesOmit<ExtArgs> | null
    /**
     * Filter, which s_corevalues to fetch.
     */
    where: s_corevaluesWhereUniqueInput
  }

  /**
   * s_corevalues findFirst
   */
  export type s_corevaluesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_corevalues
     */
    select?: s_corevaluesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_corevalues
     */
    omit?: s_corevaluesOmit<ExtArgs> | null
    /**
     * Filter, which s_corevalues to fetch.
     */
    where?: s_corevaluesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_corevalues to fetch.
     */
    orderBy?: s_corevaluesOrderByWithRelationInput | s_corevaluesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_corevalues.
     */
    cursor?: s_corevaluesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_corevalues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_corevalues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_corevalues.
     */
    distinct?: S_corevaluesScalarFieldEnum | S_corevaluesScalarFieldEnum[]
  }

  /**
   * s_corevalues findFirstOrThrow
   */
  export type s_corevaluesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_corevalues
     */
    select?: s_corevaluesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_corevalues
     */
    omit?: s_corevaluesOmit<ExtArgs> | null
    /**
     * Filter, which s_corevalues to fetch.
     */
    where?: s_corevaluesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_corevalues to fetch.
     */
    orderBy?: s_corevaluesOrderByWithRelationInput | s_corevaluesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_corevalues.
     */
    cursor?: s_corevaluesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_corevalues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_corevalues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_corevalues.
     */
    distinct?: S_corevaluesScalarFieldEnum | S_corevaluesScalarFieldEnum[]
  }

  /**
   * s_corevalues findMany
   */
  export type s_corevaluesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_corevalues
     */
    select?: s_corevaluesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_corevalues
     */
    omit?: s_corevaluesOmit<ExtArgs> | null
    /**
     * Filter, which s_corevalues to fetch.
     */
    where?: s_corevaluesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_corevalues to fetch.
     */
    orderBy?: s_corevaluesOrderByWithRelationInput | s_corevaluesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing s_corevalues.
     */
    cursor?: s_corevaluesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_corevalues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_corevalues.
     */
    skip?: number
    distinct?: S_corevaluesScalarFieldEnum | S_corevaluesScalarFieldEnum[]
  }

  /**
   * s_corevalues create
   */
  export type s_corevaluesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_corevalues
     */
    select?: s_corevaluesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_corevalues
     */
    omit?: s_corevaluesOmit<ExtArgs> | null
    /**
     * The data needed to create a s_corevalues.
     */
    data: XOR<s_corevaluesCreateInput, s_corevaluesUncheckedCreateInput>
  }

  /**
   * s_corevalues createMany
   */
  export type s_corevaluesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many s_corevalues.
     */
    data: s_corevaluesCreateManyInput | s_corevaluesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * s_corevalues update
   */
  export type s_corevaluesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_corevalues
     */
    select?: s_corevaluesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_corevalues
     */
    omit?: s_corevaluesOmit<ExtArgs> | null
    /**
     * The data needed to update a s_corevalues.
     */
    data: XOR<s_corevaluesUpdateInput, s_corevaluesUncheckedUpdateInput>
    /**
     * Choose, which s_corevalues to update.
     */
    where: s_corevaluesWhereUniqueInput
  }

  /**
   * s_corevalues updateMany
   */
  export type s_corevaluesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update s_corevalues.
     */
    data: XOR<s_corevaluesUpdateManyMutationInput, s_corevaluesUncheckedUpdateManyInput>
    /**
     * Filter which s_corevalues to update
     */
    where?: s_corevaluesWhereInput
    /**
     * Limit how many s_corevalues to update.
     */
    limit?: number
  }

  /**
   * s_corevalues upsert
   */
  export type s_corevaluesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_corevalues
     */
    select?: s_corevaluesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_corevalues
     */
    omit?: s_corevaluesOmit<ExtArgs> | null
    /**
     * The filter to search for the s_corevalues to update in case it exists.
     */
    where: s_corevaluesWhereUniqueInput
    /**
     * In case the s_corevalues found by the `where` argument doesn't exist, create a new s_corevalues with this data.
     */
    create: XOR<s_corevaluesCreateInput, s_corevaluesUncheckedCreateInput>
    /**
     * In case the s_corevalues was found with the provided `where` argument, update it with this data.
     */
    update: XOR<s_corevaluesUpdateInput, s_corevaluesUncheckedUpdateInput>
  }

  /**
   * s_corevalues delete
   */
  export type s_corevaluesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_corevalues
     */
    select?: s_corevaluesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_corevalues
     */
    omit?: s_corevaluesOmit<ExtArgs> | null
    /**
     * Filter which s_corevalues to delete.
     */
    where: s_corevaluesWhereUniqueInput
  }

  /**
   * s_corevalues deleteMany
   */
  export type s_corevaluesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_corevalues to delete
     */
    where?: s_corevaluesWhereInput
    /**
     * Limit how many s_corevalues to delete.
     */
    limit?: number
  }

  /**
   * s_corevalues without action
   */
  export type s_corevaluesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_corevalues
     */
    select?: s_corevaluesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_corevalues
     */
    omit?: s_corevaluesOmit<ExtArgs> | null
  }


  /**
   * Model s_payables
   */

  export type AggregateS_payables = {
    _count: S_payablesCountAggregateOutputType | null
    _avg: S_payablesAvgAggregateOutputType | null
    _sum: S_payablesSumAggregateOutputType | null
    _min: S_payablesMinAggregateOutputType | null
    _max: S_payablesMaxAggregateOutputType | null
  }

  export type S_payablesAvgAggregateOutputType = {
    id: number | null
    reservation_fee: number | null
    tuition_fee: number | null
    other_fee: number | null
    assessment_fee: number | null
    registration_fee: number | null
    special_permit: number | null
    international_fee_old: number | null
    international_fee_new: number | null
    pta: number | null
  }

  export type S_payablesSumAggregateOutputType = {
    id: number | null
    reservation_fee: number | null
    tuition_fee: number | null
    other_fee: number | null
    assessment_fee: number | null
    registration_fee: number | null
    special_permit: number | null
    international_fee_old: number | null
    international_fee_new: number | null
    pta: number | null
  }

  export type S_payablesMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    reservation_fee: number | null
    tuition_fee: number | null
    other_fee: number | null
    assessment_fee: number | null
    registration_fee: number | null
    special_permit: number | null
    international_fee_old: number | null
    international_fee_new: number | null
    pta: number | null
  }

  export type S_payablesMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    reservation_fee: number | null
    tuition_fee: number | null
    other_fee: number | null
    assessment_fee: number | null
    registration_fee: number | null
    special_permit: number | null
    international_fee_old: number | null
    international_fee_new: number | null
    pta: number | null
  }

  export type S_payablesCountAggregateOutputType = {
    id: number
    user_id: number
    reservation_fee: number
    tuition_fee: number
    other_fee: number
    assessment_fee: number
    registration_fee: number
    special_permit: number
    international_fee_old: number
    international_fee_new: number
    pta: number
    _all: number
  }


  export type S_payablesAvgAggregateInputType = {
    id?: true
    reservation_fee?: true
    tuition_fee?: true
    other_fee?: true
    assessment_fee?: true
    registration_fee?: true
    special_permit?: true
    international_fee_old?: true
    international_fee_new?: true
    pta?: true
  }

  export type S_payablesSumAggregateInputType = {
    id?: true
    reservation_fee?: true
    tuition_fee?: true
    other_fee?: true
    assessment_fee?: true
    registration_fee?: true
    special_permit?: true
    international_fee_old?: true
    international_fee_new?: true
    pta?: true
  }

  export type S_payablesMinAggregateInputType = {
    id?: true
    user_id?: true
    reservation_fee?: true
    tuition_fee?: true
    other_fee?: true
    assessment_fee?: true
    registration_fee?: true
    special_permit?: true
    international_fee_old?: true
    international_fee_new?: true
    pta?: true
  }

  export type S_payablesMaxAggregateInputType = {
    id?: true
    user_id?: true
    reservation_fee?: true
    tuition_fee?: true
    other_fee?: true
    assessment_fee?: true
    registration_fee?: true
    special_permit?: true
    international_fee_old?: true
    international_fee_new?: true
    pta?: true
  }

  export type S_payablesCountAggregateInputType = {
    id?: true
    user_id?: true
    reservation_fee?: true
    tuition_fee?: true
    other_fee?: true
    assessment_fee?: true
    registration_fee?: true
    special_permit?: true
    international_fee_old?: true
    international_fee_new?: true
    pta?: true
    _all?: true
  }

  export type S_payablesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_payables to aggregate.
     */
    where?: s_payablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_payables to fetch.
     */
    orderBy?: s_payablesOrderByWithRelationInput | s_payablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: s_payablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_payables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_payables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned s_payables
    **/
    _count?: true | S_payablesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: S_payablesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: S_payablesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S_payablesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S_payablesMaxAggregateInputType
  }

  export type GetS_payablesAggregateType<T extends S_payablesAggregateArgs> = {
        [P in keyof T & keyof AggregateS_payables]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS_payables[P]>
      : GetScalarType<T[P], AggregateS_payables[P]>
  }




  export type s_payablesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: s_payablesWhereInput
    orderBy?: s_payablesOrderByWithAggregationInput | s_payablesOrderByWithAggregationInput[]
    by: S_payablesScalarFieldEnum[] | S_payablesScalarFieldEnum
    having?: s_payablesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S_payablesCountAggregateInputType | true
    _avg?: S_payablesAvgAggregateInputType
    _sum?: S_payablesSumAggregateInputType
    _min?: S_payablesMinAggregateInputType
    _max?: S_payablesMaxAggregateInputType
  }

  export type S_payablesGroupByOutputType = {
    id: number
    user_id: string
    reservation_fee: number | null
    tuition_fee: number | null
    other_fee: number | null
    assessment_fee: number | null
    registration_fee: number | null
    special_permit: number | null
    international_fee_old: number | null
    international_fee_new: number | null
    pta: number | null
    _count: S_payablesCountAggregateOutputType | null
    _avg: S_payablesAvgAggregateOutputType | null
    _sum: S_payablesSumAggregateOutputType | null
    _min: S_payablesMinAggregateOutputType | null
    _max: S_payablesMaxAggregateOutputType | null
  }

  type GetS_payablesGroupByPayload<T extends s_payablesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S_payablesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S_payablesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S_payablesGroupByOutputType[P]>
            : GetScalarType<T[P], S_payablesGroupByOutputType[P]>
        }
      >
    >


  export type s_payablesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    reservation_fee?: boolean
    tuition_fee?: boolean
    other_fee?: boolean
    assessment_fee?: boolean
    registration_fee?: boolean
    special_permit?: boolean
    international_fee_old?: boolean
    international_fee_new?: boolean
    pta?: boolean
  }, ExtArgs["result"]["s_payables"]>



  export type s_payablesSelectScalar = {
    id?: boolean
    user_id?: boolean
    reservation_fee?: boolean
    tuition_fee?: boolean
    other_fee?: boolean
    assessment_fee?: boolean
    registration_fee?: boolean
    special_permit?: boolean
    international_fee_old?: boolean
    international_fee_new?: boolean
    pta?: boolean
  }

  export type s_payablesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "reservation_fee" | "tuition_fee" | "other_fee" | "assessment_fee" | "registration_fee" | "special_permit" | "international_fee_old" | "international_fee_new" | "pta", ExtArgs["result"]["s_payables"]>

  export type $s_payablesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "s_payables"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      reservation_fee: number | null
      tuition_fee: number | null
      other_fee: number | null
      assessment_fee: number | null
      registration_fee: number | null
      special_permit: number | null
      international_fee_old: number | null
      international_fee_new: number | null
      pta: number | null
    }, ExtArgs["result"]["s_payables"]>
    composites: {}
  }

  type s_payablesGetPayload<S extends boolean | null | undefined | s_payablesDefaultArgs> = $Result.GetResult<Prisma.$s_payablesPayload, S>

  type s_payablesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<s_payablesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S_payablesCountAggregateInputType | true
    }

  export interface s_payablesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['s_payables'], meta: { name: 's_payables' } }
    /**
     * Find zero or one S_payables that matches the filter.
     * @param {s_payablesFindUniqueArgs} args - Arguments to find a S_payables
     * @example
     * // Get one S_payables
     * const s_payables = await prisma.s_payables.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends s_payablesFindUniqueArgs>(args: SelectSubset<T, s_payablesFindUniqueArgs<ExtArgs>>): Prisma__s_payablesClient<$Result.GetResult<Prisma.$s_payablesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S_payables that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {s_payablesFindUniqueOrThrowArgs} args - Arguments to find a S_payables
     * @example
     * // Get one S_payables
     * const s_payables = await prisma.s_payables.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends s_payablesFindUniqueOrThrowArgs>(args: SelectSubset<T, s_payablesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__s_payablesClient<$Result.GetResult<Prisma.$s_payablesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_payables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_payablesFindFirstArgs} args - Arguments to find a S_payables
     * @example
     * // Get one S_payables
     * const s_payables = await prisma.s_payables.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends s_payablesFindFirstArgs>(args?: SelectSubset<T, s_payablesFindFirstArgs<ExtArgs>>): Prisma__s_payablesClient<$Result.GetResult<Prisma.$s_payablesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_payables that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_payablesFindFirstOrThrowArgs} args - Arguments to find a S_payables
     * @example
     * // Get one S_payables
     * const s_payables = await prisma.s_payables.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends s_payablesFindFirstOrThrowArgs>(args?: SelectSubset<T, s_payablesFindFirstOrThrowArgs<ExtArgs>>): Prisma__s_payablesClient<$Result.GetResult<Prisma.$s_payablesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S_payables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_payablesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S_payables
     * const s_payables = await prisma.s_payables.findMany()
     * 
     * // Get first 10 S_payables
     * const s_payables = await prisma.s_payables.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const s_payablesWithIdOnly = await prisma.s_payables.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends s_payablesFindManyArgs>(args?: SelectSubset<T, s_payablesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$s_payablesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S_payables.
     * @param {s_payablesCreateArgs} args - Arguments to create a S_payables.
     * @example
     * // Create one S_payables
     * const S_payables = await prisma.s_payables.create({
     *   data: {
     *     // ... data to create a S_payables
     *   }
     * })
     * 
     */
    create<T extends s_payablesCreateArgs>(args: SelectSubset<T, s_payablesCreateArgs<ExtArgs>>): Prisma__s_payablesClient<$Result.GetResult<Prisma.$s_payablesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S_payables.
     * @param {s_payablesCreateManyArgs} args - Arguments to create many S_payables.
     * @example
     * // Create many S_payables
     * const s_payables = await prisma.s_payables.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends s_payablesCreateManyArgs>(args?: SelectSubset<T, s_payablesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a S_payables.
     * @param {s_payablesDeleteArgs} args - Arguments to delete one S_payables.
     * @example
     * // Delete one S_payables
     * const S_payables = await prisma.s_payables.delete({
     *   where: {
     *     // ... filter to delete one S_payables
     *   }
     * })
     * 
     */
    delete<T extends s_payablesDeleteArgs>(args: SelectSubset<T, s_payablesDeleteArgs<ExtArgs>>): Prisma__s_payablesClient<$Result.GetResult<Prisma.$s_payablesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S_payables.
     * @param {s_payablesUpdateArgs} args - Arguments to update one S_payables.
     * @example
     * // Update one S_payables
     * const s_payables = await prisma.s_payables.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends s_payablesUpdateArgs>(args: SelectSubset<T, s_payablesUpdateArgs<ExtArgs>>): Prisma__s_payablesClient<$Result.GetResult<Prisma.$s_payablesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S_payables.
     * @param {s_payablesDeleteManyArgs} args - Arguments to filter S_payables to delete.
     * @example
     * // Delete a few S_payables
     * const { count } = await prisma.s_payables.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends s_payablesDeleteManyArgs>(args?: SelectSubset<T, s_payablesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S_payables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_payablesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S_payables
     * const s_payables = await prisma.s_payables.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends s_payablesUpdateManyArgs>(args: SelectSubset<T, s_payablesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one S_payables.
     * @param {s_payablesUpsertArgs} args - Arguments to update or create a S_payables.
     * @example
     * // Update or create a S_payables
     * const s_payables = await prisma.s_payables.upsert({
     *   create: {
     *     // ... data to create a S_payables
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S_payables we want to update
     *   }
     * })
     */
    upsert<T extends s_payablesUpsertArgs>(args: SelectSubset<T, s_payablesUpsertArgs<ExtArgs>>): Prisma__s_payablesClient<$Result.GetResult<Prisma.$s_payablesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S_payables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_payablesCountArgs} args - Arguments to filter S_payables to count.
     * @example
     * // Count the number of S_payables
     * const count = await prisma.s_payables.count({
     *   where: {
     *     // ... the filter for the S_payables we want to count
     *   }
     * })
    **/
    count<T extends s_payablesCountArgs>(
      args?: Subset<T, s_payablesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S_payablesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S_payables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S_payablesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S_payablesAggregateArgs>(args: Subset<T, S_payablesAggregateArgs>): Prisma.PrismaPromise<GetS_payablesAggregateType<T>>

    /**
     * Group by S_payables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_payablesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends s_payablesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: s_payablesGroupByArgs['orderBy'] }
        : { orderBy?: s_payablesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, s_payablesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS_payablesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the s_payables model
   */
  readonly fields: s_payablesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for s_payables.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__s_payablesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the s_payables model
   */
  interface s_payablesFieldRefs {
    readonly id: FieldRef<"s_payables", 'Int'>
    readonly user_id: FieldRef<"s_payables", 'String'>
    readonly reservation_fee: FieldRef<"s_payables", 'Int'>
    readonly tuition_fee: FieldRef<"s_payables", 'Int'>
    readonly other_fee: FieldRef<"s_payables", 'Int'>
    readonly assessment_fee: FieldRef<"s_payables", 'Int'>
    readonly registration_fee: FieldRef<"s_payables", 'Int'>
    readonly special_permit: FieldRef<"s_payables", 'Int'>
    readonly international_fee_old: FieldRef<"s_payables", 'Int'>
    readonly international_fee_new: FieldRef<"s_payables", 'Int'>
    readonly pta: FieldRef<"s_payables", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * s_payables findUnique
   */
  export type s_payablesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_payables
     */
    select?: s_payablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_payables
     */
    omit?: s_payablesOmit<ExtArgs> | null
    /**
     * Filter, which s_payables to fetch.
     */
    where: s_payablesWhereUniqueInput
  }

  /**
   * s_payables findUniqueOrThrow
   */
  export type s_payablesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_payables
     */
    select?: s_payablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_payables
     */
    omit?: s_payablesOmit<ExtArgs> | null
    /**
     * Filter, which s_payables to fetch.
     */
    where: s_payablesWhereUniqueInput
  }

  /**
   * s_payables findFirst
   */
  export type s_payablesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_payables
     */
    select?: s_payablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_payables
     */
    omit?: s_payablesOmit<ExtArgs> | null
    /**
     * Filter, which s_payables to fetch.
     */
    where?: s_payablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_payables to fetch.
     */
    orderBy?: s_payablesOrderByWithRelationInput | s_payablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_payables.
     */
    cursor?: s_payablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_payables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_payables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_payables.
     */
    distinct?: S_payablesScalarFieldEnum | S_payablesScalarFieldEnum[]
  }

  /**
   * s_payables findFirstOrThrow
   */
  export type s_payablesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_payables
     */
    select?: s_payablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_payables
     */
    omit?: s_payablesOmit<ExtArgs> | null
    /**
     * Filter, which s_payables to fetch.
     */
    where?: s_payablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_payables to fetch.
     */
    orderBy?: s_payablesOrderByWithRelationInput | s_payablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_payables.
     */
    cursor?: s_payablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_payables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_payables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_payables.
     */
    distinct?: S_payablesScalarFieldEnum | S_payablesScalarFieldEnum[]
  }

  /**
   * s_payables findMany
   */
  export type s_payablesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_payables
     */
    select?: s_payablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_payables
     */
    omit?: s_payablesOmit<ExtArgs> | null
    /**
     * Filter, which s_payables to fetch.
     */
    where?: s_payablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_payables to fetch.
     */
    orderBy?: s_payablesOrderByWithRelationInput | s_payablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing s_payables.
     */
    cursor?: s_payablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_payables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_payables.
     */
    skip?: number
    distinct?: S_payablesScalarFieldEnum | S_payablesScalarFieldEnum[]
  }

  /**
   * s_payables create
   */
  export type s_payablesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_payables
     */
    select?: s_payablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_payables
     */
    omit?: s_payablesOmit<ExtArgs> | null
    /**
     * The data needed to create a s_payables.
     */
    data: XOR<s_payablesCreateInput, s_payablesUncheckedCreateInput>
  }

  /**
   * s_payables createMany
   */
  export type s_payablesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many s_payables.
     */
    data: s_payablesCreateManyInput | s_payablesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * s_payables update
   */
  export type s_payablesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_payables
     */
    select?: s_payablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_payables
     */
    omit?: s_payablesOmit<ExtArgs> | null
    /**
     * The data needed to update a s_payables.
     */
    data: XOR<s_payablesUpdateInput, s_payablesUncheckedUpdateInput>
    /**
     * Choose, which s_payables to update.
     */
    where: s_payablesWhereUniqueInput
  }

  /**
   * s_payables updateMany
   */
  export type s_payablesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update s_payables.
     */
    data: XOR<s_payablesUpdateManyMutationInput, s_payablesUncheckedUpdateManyInput>
    /**
     * Filter which s_payables to update
     */
    where?: s_payablesWhereInput
    /**
     * Limit how many s_payables to update.
     */
    limit?: number
  }

  /**
   * s_payables upsert
   */
  export type s_payablesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_payables
     */
    select?: s_payablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_payables
     */
    omit?: s_payablesOmit<ExtArgs> | null
    /**
     * The filter to search for the s_payables to update in case it exists.
     */
    where: s_payablesWhereUniqueInput
    /**
     * In case the s_payables found by the `where` argument doesn't exist, create a new s_payables with this data.
     */
    create: XOR<s_payablesCreateInput, s_payablesUncheckedCreateInput>
    /**
     * In case the s_payables was found with the provided `where` argument, update it with this data.
     */
    update: XOR<s_payablesUpdateInput, s_payablesUncheckedUpdateInput>
  }

  /**
   * s_payables delete
   */
  export type s_payablesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_payables
     */
    select?: s_payablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_payables
     */
    omit?: s_payablesOmit<ExtArgs> | null
    /**
     * Filter which s_payables to delete.
     */
    where: s_payablesWhereUniqueInput
  }

  /**
   * s_payables deleteMany
   */
  export type s_payablesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_payables to delete
     */
    where?: s_payablesWhereInput
    /**
     * Limit how many s_payables to delete.
     */
    limit?: number
  }

  /**
   * s_payables without action
   */
  export type s_payablesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_payables
     */
    select?: s_payablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_payables
     */
    omit?: s_payablesOmit<ExtArgs> | null
  }


  /**
   * Model s_recommendations
   */

  export type AggregateS_recommendations = {
    _count: S_recommendationsCountAggregateOutputType | null
    _avg: S_recommendationsAvgAggregateOutputType | null
    _sum: S_recommendationsSumAggregateOutputType | null
    _min: S_recommendationsMinAggregateOutputType | null
    _max: S_recommendationsMaxAggregateOutputType | null
  }

  export type S_recommendationsAvgAggregateOutputType = {
    id: number | null
    esl: number | null
    star: number | null
    completion: number | null
  }

  export type S_recommendationsSumAggregateOutputType = {
    id: number | null
    esl: number | null
    star: number | null
    completion: number | null
  }

  export type S_recommendationsMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    esl: number | null
    star: number | null
    completion: number | null
  }

  export type S_recommendationsMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    esl: number | null
    star: number | null
    completion: number | null
  }

  export type S_recommendationsCountAggregateOutputType = {
    id: number
    user_id: number
    esl: number
    star: number
    completion: number
    _all: number
  }


  export type S_recommendationsAvgAggregateInputType = {
    id?: true
    esl?: true
    star?: true
    completion?: true
  }

  export type S_recommendationsSumAggregateInputType = {
    id?: true
    esl?: true
    star?: true
    completion?: true
  }

  export type S_recommendationsMinAggregateInputType = {
    id?: true
    user_id?: true
    esl?: true
    star?: true
    completion?: true
  }

  export type S_recommendationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    esl?: true
    star?: true
    completion?: true
  }

  export type S_recommendationsCountAggregateInputType = {
    id?: true
    user_id?: true
    esl?: true
    star?: true
    completion?: true
    _all?: true
  }

  export type S_recommendationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_recommendations to aggregate.
     */
    where?: s_recommendationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_recommendations to fetch.
     */
    orderBy?: s_recommendationsOrderByWithRelationInput | s_recommendationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: s_recommendationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned s_recommendations
    **/
    _count?: true | S_recommendationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: S_recommendationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: S_recommendationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S_recommendationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S_recommendationsMaxAggregateInputType
  }

  export type GetS_recommendationsAggregateType<T extends S_recommendationsAggregateArgs> = {
        [P in keyof T & keyof AggregateS_recommendations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS_recommendations[P]>
      : GetScalarType<T[P], AggregateS_recommendations[P]>
  }




  export type s_recommendationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: s_recommendationsWhereInput
    orderBy?: s_recommendationsOrderByWithAggregationInput | s_recommendationsOrderByWithAggregationInput[]
    by: S_recommendationsScalarFieldEnum[] | S_recommendationsScalarFieldEnum
    having?: s_recommendationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S_recommendationsCountAggregateInputType | true
    _avg?: S_recommendationsAvgAggregateInputType
    _sum?: S_recommendationsSumAggregateInputType
    _min?: S_recommendationsMinAggregateInputType
    _max?: S_recommendationsMaxAggregateInputType
  }

  export type S_recommendationsGroupByOutputType = {
    id: number
    user_id: string
    esl: number | null
    star: number | null
    completion: number | null
    _count: S_recommendationsCountAggregateOutputType | null
    _avg: S_recommendationsAvgAggregateOutputType | null
    _sum: S_recommendationsSumAggregateOutputType | null
    _min: S_recommendationsMinAggregateOutputType | null
    _max: S_recommendationsMaxAggregateOutputType | null
  }

  type GetS_recommendationsGroupByPayload<T extends s_recommendationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S_recommendationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S_recommendationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S_recommendationsGroupByOutputType[P]>
            : GetScalarType<T[P], S_recommendationsGroupByOutputType[P]>
        }
      >
    >


  export type s_recommendationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    esl?: boolean
    star?: boolean
    completion?: boolean
  }, ExtArgs["result"]["s_recommendations"]>



  export type s_recommendationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    esl?: boolean
    star?: boolean
    completion?: boolean
  }

  export type s_recommendationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "esl" | "star" | "completion", ExtArgs["result"]["s_recommendations"]>

  export type $s_recommendationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "s_recommendations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      esl: number | null
      star: number | null
      completion: number | null
    }, ExtArgs["result"]["s_recommendations"]>
    composites: {}
  }

  type s_recommendationsGetPayload<S extends boolean | null | undefined | s_recommendationsDefaultArgs> = $Result.GetResult<Prisma.$s_recommendationsPayload, S>

  type s_recommendationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<s_recommendationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S_recommendationsCountAggregateInputType | true
    }

  export interface s_recommendationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['s_recommendations'], meta: { name: 's_recommendations' } }
    /**
     * Find zero or one S_recommendations that matches the filter.
     * @param {s_recommendationsFindUniqueArgs} args - Arguments to find a S_recommendations
     * @example
     * // Get one S_recommendations
     * const s_recommendations = await prisma.s_recommendations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends s_recommendationsFindUniqueArgs>(args: SelectSubset<T, s_recommendationsFindUniqueArgs<ExtArgs>>): Prisma__s_recommendationsClient<$Result.GetResult<Prisma.$s_recommendationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S_recommendations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {s_recommendationsFindUniqueOrThrowArgs} args - Arguments to find a S_recommendations
     * @example
     * // Get one S_recommendations
     * const s_recommendations = await prisma.s_recommendations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends s_recommendationsFindUniqueOrThrowArgs>(args: SelectSubset<T, s_recommendationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__s_recommendationsClient<$Result.GetResult<Prisma.$s_recommendationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_recommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_recommendationsFindFirstArgs} args - Arguments to find a S_recommendations
     * @example
     * // Get one S_recommendations
     * const s_recommendations = await prisma.s_recommendations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends s_recommendationsFindFirstArgs>(args?: SelectSubset<T, s_recommendationsFindFirstArgs<ExtArgs>>): Prisma__s_recommendationsClient<$Result.GetResult<Prisma.$s_recommendationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_recommendations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_recommendationsFindFirstOrThrowArgs} args - Arguments to find a S_recommendations
     * @example
     * // Get one S_recommendations
     * const s_recommendations = await prisma.s_recommendations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends s_recommendationsFindFirstOrThrowArgs>(args?: SelectSubset<T, s_recommendationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__s_recommendationsClient<$Result.GetResult<Prisma.$s_recommendationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S_recommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_recommendationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S_recommendations
     * const s_recommendations = await prisma.s_recommendations.findMany()
     * 
     * // Get first 10 S_recommendations
     * const s_recommendations = await prisma.s_recommendations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const s_recommendationsWithIdOnly = await prisma.s_recommendations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends s_recommendationsFindManyArgs>(args?: SelectSubset<T, s_recommendationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$s_recommendationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S_recommendations.
     * @param {s_recommendationsCreateArgs} args - Arguments to create a S_recommendations.
     * @example
     * // Create one S_recommendations
     * const S_recommendations = await prisma.s_recommendations.create({
     *   data: {
     *     // ... data to create a S_recommendations
     *   }
     * })
     * 
     */
    create<T extends s_recommendationsCreateArgs>(args: SelectSubset<T, s_recommendationsCreateArgs<ExtArgs>>): Prisma__s_recommendationsClient<$Result.GetResult<Prisma.$s_recommendationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S_recommendations.
     * @param {s_recommendationsCreateManyArgs} args - Arguments to create many S_recommendations.
     * @example
     * // Create many S_recommendations
     * const s_recommendations = await prisma.s_recommendations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends s_recommendationsCreateManyArgs>(args?: SelectSubset<T, s_recommendationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a S_recommendations.
     * @param {s_recommendationsDeleteArgs} args - Arguments to delete one S_recommendations.
     * @example
     * // Delete one S_recommendations
     * const S_recommendations = await prisma.s_recommendations.delete({
     *   where: {
     *     // ... filter to delete one S_recommendations
     *   }
     * })
     * 
     */
    delete<T extends s_recommendationsDeleteArgs>(args: SelectSubset<T, s_recommendationsDeleteArgs<ExtArgs>>): Prisma__s_recommendationsClient<$Result.GetResult<Prisma.$s_recommendationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S_recommendations.
     * @param {s_recommendationsUpdateArgs} args - Arguments to update one S_recommendations.
     * @example
     * // Update one S_recommendations
     * const s_recommendations = await prisma.s_recommendations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends s_recommendationsUpdateArgs>(args: SelectSubset<T, s_recommendationsUpdateArgs<ExtArgs>>): Prisma__s_recommendationsClient<$Result.GetResult<Prisma.$s_recommendationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S_recommendations.
     * @param {s_recommendationsDeleteManyArgs} args - Arguments to filter S_recommendations to delete.
     * @example
     * // Delete a few S_recommendations
     * const { count } = await prisma.s_recommendations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends s_recommendationsDeleteManyArgs>(args?: SelectSubset<T, s_recommendationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S_recommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_recommendationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S_recommendations
     * const s_recommendations = await prisma.s_recommendations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends s_recommendationsUpdateManyArgs>(args: SelectSubset<T, s_recommendationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one S_recommendations.
     * @param {s_recommendationsUpsertArgs} args - Arguments to update or create a S_recommendations.
     * @example
     * // Update or create a S_recommendations
     * const s_recommendations = await prisma.s_recommendations.upsert({
     *   create: {
     *     // ... data to create a S_recommendations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S_recommendations we want to update
     *   }
     * })
     */
    upsert<T extends s_recommendationsUpsertArgs>(args: SelectSubset<T, s_recommendationsUpsertArgs<ExtArgs>>): Prisma__s_recommendationsClient<$Result.GetResult<Prisma.$s_recommendationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S_recommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_recommendationsCountArgs} args - Arguments to filter S_recommendations to count.
     * @example
     * // Count the number of S_recommendations
     * const count = await prisma.s_recommendations.count({
     *   where: {
     *     // ... the filter for the S_recommendations we want to count
     *   }
     * })
    **/
    count<T extends s_recommendationsCountArgs>(
      args?: Subset<T, s_recommendationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S_recommendationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S_recommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S_recommendationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S_recommendationsAggregateArgs>(args: Subset<T, S_recommendationsAggregateArgs>): Prisma.PrismaPromise<GetS_recommendationsAggregateType<T>>

    /**
     * Group by S_recommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_recommendationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends s_recommendationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: s_recommendationsGroupByArgs['orderBy'] }
        : { orderBy?: s_recommendationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, s_recommendationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS_recommendationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the s_recommendations model
   */
  readonly fields: s_recommendationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for s_recommendations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__s_recommendationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the s_recommendations model
   */
  interface s_recommendationsFieldRefs {
    readonly id: FieldRef<"s_recommendations", 'Int'>
    readonly user_id: FieldRef<"s_recommendations", 'String'>
    readonly esl: FieldRef<"s_recommendations", 'Int'>
    readonly star: FieldRef<"s_recommendations", 'Int'>
    readonly completion: FieldRef<"s_recommendations", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * s_recommendations findUnique
   */
  export type s_recommendationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_recommendations
     */
    select?: s_recommendationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_recommendations
     */
    omit?: s_recommendationsOmit<ExtArgs> | null
    /**
     * Filter, which s_recommendations to fetch.
     */
    where: s_recommendationsWhereUniqueInput
  }

  /**
   * s_recommendations findUniqueOrThrow
   */
  export type s_recommendationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_recommendations
     */
    select?: s_recommendationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_recommendations
     */
    omit?: s_recommendationsOmit<ExtArgs> | null
    /**
     * Filter, which s_recommendations to fetch.
     */
    where: s_recommendationsWhereUniqueInput
  }

  /**
   * s_recommendations findFirst
   */
  export type s_recommendationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_recommendations
     */
    select?: s_recommendationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_recommendations
     */
    omit?: s_recommendationsOmit<ExtArgs> | null
    /**
     * Filter, which s_recommendations to fetch.
     */
    where?: s_recommendationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_recommendations to fetch.
     */
    orderBy?: s_recommendationsOrderByWithRelationInput | s_recommendationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_recommendations.
     */
    cursor?: s_recommendationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_recommendations.
     */
    distinct?: S_recommendationsScalarFieldEnum | S_recommendationsScalarFieldEnum[]
  }

  /**
   * s_recommendations findFirstOrThrow
   */
  export type s_recommendationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_recommendations
     */
    select?: s_recommendationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_recommendations
     */
    omit?: s_recommendationsOmit<ExtArgs> | null
    /**
     * Filter, which s_recommendations to fetch.
     */
    where?: s_recommendationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_recommendations to fetch.
     */
    orderBy?: s_recommendationsOrderByWithRelationInput | s_recommendationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_recommendations.
     */
    cursor?: s_recommendationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_recommendations.
     */
    distinct?: S_recommendationsScalarFieldEnum | S_recommendationsScalarFieldEnum[]
  }

  /**
   * s_recommendations findMany
   */
  export type s_recommendationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_recommendations
     */
    select?: s_recommendationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_recommendations
     */
    omit?: s_recommendationsOmit<ExtArgs> | null
    /**
     * Filter, which s_recommendations to fetch.
     */
    where?: s_recommendationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_recommendations to fetch.
     */
    orderBy?: s_recommendationsOrderByWithRelationInput | s_recommendationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing s_recommendations.
     */
    cursor?: s_recommendationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_recommendations.
     */
    skip?: number
    distinct?: S_recommendationsScalarFieldEnum | S_recommendationsScalarFieldEnum[]
  }

  /**
   * s_recommendations create
   */
  export type s_recommendationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_recommendations
     */
    select?: s_recommendationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_recommendations
     */
    omit?: s_recommendationsOmit<ExtArgs> | null
    /**
     * The data needed to create a s_recommendations.
     */
    data: XOR<s_recommendationsCreateInput, s_recommendationsUncheckedCreateInput>
  }

  /**
   * s_recommendations createMany
   */
  export type s_recommendationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many s_recommendations.
     */
    data: s_recommendationsCreateManyInput | s_recommendationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * s_recommendations update
   */
  export type s_recommendationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_recommendations
     */
    select?: s_recommendationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_recommendations
     */
    omit?: s_recommendationsOmit<ExtArgs> | null
    /**
     * The data needed to update a s_recommendations.
     */
    data: XOR<s_recommendationsUpdateInput, s_recommendationsUncheckedUpdateInput>
    /**
     * Choose, which s_recommendations to update.
     */
    where: s_recommendationsWhereUniqueInput
  }

  /**
   * s_recommendations updateMany
   */
  export type s_recommendationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update s_recommendations.
     */
    data: XOR<s_recommendationsUpdateManyMutationInput, s_recommendationsUncheckedUpdateManyInput>
    /**
     * Filter which s_recommendations to update
     */
    where?: s_recommendationsWhereInput
    /**
     * Limit how many s_recommendations to update.
     */
    limit?: number
  }

  /**
   * s_recommendations upsert
   */
  export type s_recommendationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_recommendations
     */
    select?: s_recommendationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_recommendations
     */
    omit?: s_recommendationsOmit<ExtArgs> | null
    /**
     * The filter to search for the s_recommendations to update in case it exists.
     */
    where: s_recommendationsWhereUniqueInput
    /**
     * In case the s_recommendations found by the `where` argument doesn't exist, create a new s_recommendations with this data.
     */
    create: XOR<s_recommendationsCreateInput, s_recommendationsUncheckedCreateInput>
    /**
     * In case the s_recommendations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<s_recommendationsUpdateInput, s_recommendationsUncheckedUpdateInput>
  }

  /**
   * s_recommendations delete
   */
  export type s_recommendationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_recommendations
     */
    select?: s_recommendationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_recommendations
     */
    omit?: s_recommendationsOmit<ExtArgs> | null
    /**
     * Filter which s_recommendations to delete.
     */
    where: s_recommendationsWhereUniqueInput
  }

  /**
   * s_recommendations deleteMany
   */
  export type s_recommendationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_recommendations to delete
     */
    where?: s_recommendationsWhereInput
    /**
     * Limit how many s_recommendations to delete.
     */
    limit?: number
  }

  /**
   * s_recommendations without action
   */
  export type s_recommendationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_recommendations
     */
    select?: s_recommendationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_recommendations
     */
    omit?: s_recommendationsOmit<ExtArgs> | null
  }


  /**
   * Model s_scores
   */

  export type AggregateS_scores = {
    _count: S_scoresCountAggregateOutputType | null
    _avg: S_scoresAvgAggregateOutputType | null
    _sum: S_scoresSumAggregateOutputType | null
    _min: S_scoresMinAggregateOutputType | null
    _max: S_scoresMaxAggregateOutputType | null
  }

  export type S_scoresAvgAggregateOutputType = {
    id: number | null
    acttype: number | null
    score: number | null
    maxscore: number | null
    qtr: number | null
    flag: number | null
  }

  export type S_scoresSumAggregateOutputType = {
    id: number | null
    acttype: number | null
    score: number | null
    maxscore: number | null
    qtr: number | null
    flag: number | null
  }

  export type S_scoresMinAggregateOutputType = {
    id: number | null
    subjcode: string | null
    actid: string | null
    acttype: number | null
    sid: string | null
    score: number | null
    maxscore: number | null
    qtr: number | null
    flag: number | null
  }

  export type S_scoresMaxAggregateOutputType = {
    id: number | null
    subjcode: string | null
    actid: string | null
    acttype: number | null
    sid: string | null
    score: number | null
    maxscore: number | null
    qtr: number | null
    flag: number | null
  }

  export type S_scoresCountAggregateOutputType = {
    id: number
    subjcode: number
    actid: number
    acttype: number
    sid: number
    score: number
    maxscore: number
    qtr: number
    flag: number
    _all: number
  }


  export type S_scoresAvgAggregateInputType = {
    id?: true
    acttype?: true
    score?: true
    maxscore?: true
    qtr?: true
    flag?: true
  }

  export type S_scoresSumAggregateInputType = {
    id?: true
    acttype?: true
    score?: true
    maxscore?: true
    qtr?: true
    flag?: true
  }

  export type S_scoresMinAggregateInputType = {
    id?: true
    subjcode?: true
    actid?: true
    acttype?: true
    sid?: true
    score?: true
    maxscore?: true
    qtr?: true
    flag?: true
  }

  export type S_scoresMaxAggregateInputType = {
    id?: true
    subjcode?: true
    actid?: true
    acttype?: true
    sid?: true
    score?: true
    maxscore?: true
    qtr?: true
    flag?: true
  }

  export type S_scoresCountAggregateInputType = {
    id?: true
    subjcode?: true
    actid?: true
    acttype?: true
    sid?: true
    score?: true
    maxscore?: true
    qtr?: true
    flag?: true
    _all?: true
  }

  export type S_scoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_scores to aggregate.
     */
    where?: s_scoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_scores to fetch.
     */
    orderBy?: s_scoresOrderByWithRelationInput | s_scoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: s_scoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned s_scores
    **/
    _count?: true | S_scoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: S_scoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: S_scoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S_scoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S_scoresMaxAggregateInputType
  }

  export type GetS_scoresAggregateType<T extends S_scoresAggregateArgs> = {
        [P in keyof T & keyof AggregateS_scores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS_scores[P]>
      : GetScalarType<T[P], AggregateS_scores[P]>
  }




  export type s_scoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: s_scoresWhereInput
    orderBy?: s_scoresOrderByWithAggregationInput | s_scoresOrderByWithAggregationInput[]
    by: S_scoresScalarFieldEnum[] | S_scoresScalarFieldEnum
    having?: s_scoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S_scoresCountAggregateInputType | true
    _avg?: S_scoresAvgAggregateInputType
    _sum?: S_scoresSumAggregateInputType
    _min?: S_scoresMinAggregateInputType
    _max?: S_scoresMaxAggregateInputType
  }

  export type S_scoresGroupByOutputType = {
    id: number
    subjcode: string
    actid: string
    acttype: number
    sid: string
    score: number
    maxscore: number
    qtr: number
    flag: number
    _count: S_scoresCountAggregateOutputType | null
    _avg: S_scoresAvgAggregateOutputType | null
    _sum: S_scoresSumAggregateOutputType | null
    _min: S_scoresMinAggregateOutputType | null
    _max: S_scoresMaxAggregateOutputType | null
  }

  type GetS_scoresGroupByPayload<T extends s_scoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S_scoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S_scoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S_scoresGroupByOutputType[P]>
            : GetScalarType<T[P], S_scoresGroupByOutputType[P]>
        }
      >
    >


  export type s_scoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subjcode?: boolean
    actid?: boolean
    acttype?: boolean
    sid?: boolean
    score?: boolean
    maxscore?: boolean
    qtr?: boolean
    flag?: boolean
  }, ExtArgs["result"]["s_scores"]>



  export type s_scoresSelectScalar = {
    id?: boolean
    subjcode?: boolean
    actid?: boolean
    acttype?: boolean
    sid?: boolean
    score?: boolean
    maxscore?: boolean
    qtr?: boolean
    flag?: boolean
  }

  export type s_scoresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subjcode" | "actid" | "acttype" | "sid" | "score" | "maxscore" | "qtr" | "flag", ExtArgs["result"]["s_scores"]>

  export type $s_scoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "s_scores"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      subjcode: string
      actid: string
      acttype: number
      sid: string
      score: number
      maxscore: number
      qtr: number
      flag: number
    }, ExtArgs["result"]["s_scores"]>
    composites: {}
  }

  type s_scoresGetPayload<S extends boolean | null | undefined | s_scoresDefaultArgs> = $Result.GetResult<Prisma.$s_scoresPayload, S>

  type s_scoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<s_scoresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S_scoresCountAggregateInputType | true
    }

  export interface s_scoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['s_scores'], meta: { name: 's_scores' } }
    /**
     * Find zero or one S_scores that matches the filter.
     * @param {s_scoresFindUniqueArgs} args - Arguments to find a S_scores
     * @example
     * // Get one S_scores
     * const s_scores = await prisma.s_scores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends s_scoresFindUniqueArgs>(args: SelectSubset<T, s_scoresFindUniqueArgs<ExtArgs>>): Prisma__s_scoresClient<$Result.GetResult<Prisma.$s_scoresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S_scores that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {s_scoresFindUniqueOrThrowArgs} args - Arguments to find a S_scores
     * @example
     * // Get one S_scores
     * const s_scores = await prisma.s_scores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends s_scoresFindUniqueOrThrowArgs>(args: SelectSubset<T, s_scoresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__s_scoresClient<$Result.GetResult<Prisma.$s_scoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_scores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_scoresFindFirstArgs} args - Arguments to find a S_scores
     * @example
     * // Get one S_scores
     * const s_scores = await prisma.s_scores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends s_scoresFindFirstArgs>(args?: SelectSubset<T, s_scoresFindFirstArgs<ExtArgs>>): Prisma__s_scoresClient<$Result.GetResult<Prisma.$s_scoresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_scores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_scoresFindFirstOrThrowArgs} args - Arguments to find a S_scores
     * @example
     * // Get one S_scores
     * const s_scores = await prisma.s_scores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends s_scoresFindFirstOrThrowArgs>(args?: SelectSubset<T, s_scoresFindFirstOrThrowArgs<ExtArgs>>): Prisma__s_scoresClient<$Result.GetResult<Prisma.$s_scoresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S_scores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_scoresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S_scores
     * const s_scores = await prisma.s_scores.findMany()
     * 
     * // Get first 10 S_scores
     * const s_scores = await prisma.s_scores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const s_scoresWithIdOnly = await prisma.s_scores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends s_scoresFindManyArgs>(args?: SelectSubset<T, s_scoresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$s_scoresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S_scores.
     * @param {s_scoresCreateArgs} args - Arguments to create a S_scores.
     * @example
     * // Create one S_scores
     * const S_scores = await prisma.s_scores.create({
     *   data: {
     *     // ... data to create a S_scores
     *   }
     * })
     * 
     */
    create<T extends s_scoresCreateArgs>(args: SelectSubset<T, s_scoresCreateArgs<ExtArgs>>): Prisma__s_scoresClient<$Result.GetResult<Prisma.$s_scoresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S_scores.
     * @param {s_scoresCreateManyArgs} args - Arguments to create many S_scores.
     * @example
     * // Create many S_scores
     * const s_scores = await prisma.s_scores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends s_scoresCreateManyArgs>(args?: SelectSubset<T, s_scoresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a S_scores.
     * @param {s_scoresDeleteArgs} args - Arguments to delete one S_scores.
     * @example
     * // Delete one S_scores
     * const S_scores = await prisma.s_scores.delete({
     *   where: {
     *     // ... filter to delete one S_scores
     *   }
     * })
     * 
     */
    delete<T extends s_scoresDeleteArgs>(args: SelectSubset<T, s_scoresDeleteArgs<ExtArgs>>): Prisma__s_scoresClient<$Result.GetResult<Prisma.$s_scoresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S_scores.
     * @param {s_scoresUpdateArgs} args - Arguments to update one S_scores.
     * @example
     * // Update one S_scores
     * const s_scores = await prisma.s_scores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends s_scoresUpdateArgs>(args: SelectSubset<T, s_scoresUpdateArgs<ExtArgs>>): Prisma__s_scoresClient<$Result.GetResult<Prisma.$s_scoresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S_scores.
     * @param {s_scoresDeleteManyArgs} args - Arguments to filter S_scores to delete.
     * @example
     * // Delete a few S_scores
     * const { count } = await prisma.s_scores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends s_scoresDeleteManyArgs>(args?: SelectSubset<T, s_scoresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S_scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_scoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S_scores
     * const s_scores = await prisma.s_scores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends s_scoresUpdateManyArgs>(args: SelectSubset<T, s_scoresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one S_scores.
     * @param {s_scoresUpsertArgs} args - Arguments to update or create a S_scores.
     * @example
     * // Update or create a S_scores
     * const s_scores = await prisma.s_scores.upsert({
     *   create: {
     *     // ... data to create a S_scores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S_scores we want to update
     *   }
     * })
     */
    upsert<T extends s_scoresUpsertArgs>(args: SelectSubset<T, s_scoresUpsertArgs<ExtArgs>>): Prisma__s_scoresClient<$Result.GetResult<Prisma.$s_scoresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S_scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_scoresCountArgs} args - Arguments to filter S_scores to count.
     * @example
     * // Count the number of S_scores
     * const count = await prisma.s_scores.count({
     *   where: {
     *     // ... the filter for the S_scores we want to count
     *   }
     * })
    **/
    count<T extends s_scoresCountArgs>(
      args?: Subset<T, s_scoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S_scoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S_scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S_scoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S_scoresAggregateArgs>(args: Subset<T, S_scoresAggregateArgs>): Prisma.PrismaPromise<GetS_scoresAggregateType<T>>

    /**
     * Group by S_scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_scoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends s_scoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: s_scoresGroupByArgs['orderBy'] }
        : { orderBy?: s_scoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, s_scoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS_scoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the s_scores model
   */
  readonly fields: s_scoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for s_scores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__s_scoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the s_scores model
   */
  interface s_scoresFieldRefs {
    readonly id: FieldRef<"s_scores", 'Int'>
    readonly subjcode: FieldRef<"s_scores", 'String'>
    readonly actid: FieldRef<"s_scores", 'String'>
    readonly acttype: FieldRef<"s_scores", 'Int'>
    readonly sid: FieldRef<"s_scores", 'String'>
    readonly score: FieldRef<"s_scores", 'Int'>
    readonly maxscore: FieldRef<"s_scores", 'Int'>
    readonly qtr: FieldRef<"s_scores", 'Int'>
    readonly flag: FieldRef<"s_scores", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * s_scores findUnique
   */
  export type s_scoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_scores
     */
    select?: s_scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_scores
     */
    omit?: s_scoresOmit<ExtArgs> | null
    /**
     * Filter, which s_scores to fetch.
     */
    where: s_scoresWhereUniqueInput
  }

  /**
   * s_scores findUniqueOrThrow
   */
  export type s_scoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_scores
     */
    select?: s_scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_scores
     */
    omit?: s_scoresOmit<ExtArgs> | null
    /**
     * Filter, which s_scores to fetch.
     */
    where: s_scoresWhereUniqueInput
  }

  /**
   * s_scores findFirst
   */
  export type s_scoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_scores
     */
    select?: s_scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_scores
     */
    omit?: s_scoresOmit<ExtArgs> | null
    /**
     * Filter, which s_scores to fetch.
     */
    where?: s_scoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_scores to fetch.
     */
    orderBy?: s_scoresOrderByWithRelationInput | s_scoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_scores.
     */
    cursor?: s_scoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_scores.
     */
    distinct?: S_scoresScalarFieldEnum | S_scoresScalarFieldEnum[]
  }

  /**
   * s_scores findFirstOrThrow
   */
  export type s_scoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_scores
     */
    select?: s_scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_scores
     */
    omit?: s_scoresOmit<ExtArgs> | null
    /**
     * Filter, which s_scores to fetch.
     */
    where?: s_scoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_scores to fetch.
     */
    orderBy?: s_scoresOrderByWithRelationInput | s_scoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_scores.
     */
    cursor?: s_scoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_scores.
     */
    distinct?: S_scoresScalarFieldEnum | S_scoresScalarFieldEnum[]
  }

  /**
   * s_scores findMany
   */
  export type s_scoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_scores
     */
    select?: s_scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_scores
     */
    omit?: s_scoresOmit<ExtArgs> | null
    /**
     * Filter, which s_scores to fetch.
     */
    where?: s_scoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_scores to fetch.
     */
    orderBy?: s_scoresOrderByWithRelationInput | s_scoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing s_scores.
     */
    cursor?: s_scoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_scores.
     */
    skip?: number
    distinct?: S_scoresScalarFieldEnum | S_scoresScalarFieldEnum[]
  }

  /**
   * s_scores create
   */
  export type s_scoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_scores
     */
    select?: s_scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_scores
     */
    omit?: s_scoresOmit<ExtArgs> | null
    /**
     * The data needed to create a s_scores.
     */
    data: XOR<s_scoresCreateInput, s_scoresUncheckedCreateInput>
  }

  /**
   * s_scores createMany
   */
  export type s_scoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many s_scores.
     */
    data: s_scoresCreateManyInput | s_scoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * s_scores update
   */
  export type s_scoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_scores
     */
    select?: s_scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_scores
     */
    omit?: s_scoresOmit<ExtArgs> | null
    /**
     * The data needed to update a s_scores.
     */
    data: XOR<s_scoresUpdateInput, s_scoresUncheckedUpdateInput>
    /**
     * Choose, which s_scores to update.
     */
    where: s_scoresWhereUniqueInput
  }

  /**
   * s_scores updateMany
   */
  export type s_scoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update s_scores.
     */
    data: XOR<s_scoresUpdateManyMutationInput, s_scoresUncheckedUpdateManyInput>
    /**
     * Filter which s_scores to update
     */
    where?: s_scoresWhereInput
    /**
     * Limit how many s_scores to update.
     */
    limit?: number
  }

  /**
   * s_scores upsert
   */
  export type s_scoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_scores
     */
    select?: s_scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_scores
     */
    omit?: s_scoresOmit<ExtArgs> | null
    /**
     * The filter to search for the s_scores to update in case it exists.
     */
    where: s_scoresWhereUniqueInput
    /**
     * In case the s_scores found by the `where` argument doesn't exist, create a new s_scores with this data.
     */
    create: XOR<s_scoresCreateInput, s_scoresUncheckedCreateInput>
    /**
     * In case the s_scores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<s_scoresUpdateInput, s_scoresUncheckedUpdateInput>
  }

  /**
   * s_scores delete
   */
  export type s_scoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_scores
     */
    select?: s_scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_scores
     */
    omit?: s_scoresOmit<ExtArgs> | null
    /**
     * Filter which s_scores to delete.
     */
    where: s_scoresWhereUniqueInput
  }

  /**
   * s_scores deleteMany
   */
  export type s_scoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_scores to delete
     */
    where?: s_scoresWhereInput
    /**
     * Limit how many s_scores to delete.
     */
    limit?: number
  }

  /**
   * s_scores without action
   */
  export type s_scoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_scores
     */
    select?: s_scoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_scores
     */
    omit?: s_scoresOmit<ExtArgs> | null
  }


  /**
   * Model s_studentcv
   */

  export type AggregateS_studentcv = {
    _count: S_studentcvCountAggregateOutputType | null
    _avg: S_studentcvAvgAggregateOutputType | null
    _sum: S_studentcvSumAggregateOutputType | null
    _min: S_studentcvMinAggregateOutputType | null
    _max: S_studentcvMaxAggregateOutputType | null
  }

  export type S_studentcvAvgAggregateOutputType = {
    id: number | null
    qtr: number | null
    independence: Decimal | null
    confidence: Decimal | null
    respect: Decimal | null
    empathy: Decimal | null
    appreciation: Decimal | null
    tolerance: Decimal | null
    enthusiasm: Decimal | null
    conduct: Decimal | null
  }

  export type S_studentcvSumAggregateOutputType = {
    id: number | null
    qtr: number | null
    independence: Decimal | null
    confidence: Decimal | null
    respect: Decimal | null
    empathy: Decimal | null
    appreciation: Decimal | null
    tolerance: Decimal | null
    enthusiasm: Decimal | null
    conduct: Decimal | null
  }

  export type S_studentcvMinAggregateOutputType = {
    id: number | null
    sid: string | null
    tid: string | null
    subjid: string | null
    qtr: number | null
    independence: Decimal | null
    confidence: Decimal | null
    respect: Decimal | null
    empathy: Decimal | null
    appreciation: Decimal | null
    tolerance: Decimal | null
    enthusiasm: Decimal | null
    conduct: Decimal | null
  }

  export type S_studentcvMaxAggregateOutputType = {
    id: number | null
    sid: string | null
    tid: string | null
    subjid: string | null
    qtr: number | null
    independence: Decimal | null
    confidence: Decimal | null
    respect: Decimal | null
    empathy: Decimal | null
    appreciation: Decimal | null
    tolerance: Decimal | null
    enthusiasm: Decimal | null
    conduct: Decimal | null
  }

  export type S_studentcvCountAggregateOutputType = {
    id: number
    sid: number
    tid: number
    subjid: number
    qtr: number
    independence: number
    confidence: number
    respect: number
    empathy: number
    appreciation: number
    tolerance: number
    enthusiasm: number
    conduct: number
    _all: number
  }


  export type S_studentcvAvgAggregateInputType = {
    id?: true
    qtr?: true
    independence?: true
    confidence?: true
    respect?: true
    empathy?: true
    appreciation?: true
    tolerance?: true
    enthusiasm?: true
    conduct?: true
  }

  export type S_studentcvSumAggregateInputType = {
    id?: true
    qtr?: true
    independence?: true
    confidence?: true
    respect?: true
    empathy?: true
    appreciation?: true
    tolerance?: true
    enthusiasm?: true
    conduct?: true
  }

  export type S_studentcvMinAggregateInputType = {
    id?: true
    sid?: true
    tid?: true
    subjid?: true
    qtr?: true
    independence?: true
    confidence?: true
    respect?: true
    empathy?: true
    appreciation?: true
    tolerance?: true
    enthusiasm?: true
    conduct?: true
  }

  export type S_studentcvMaxAggregateInputType = {
    id?: true
    sid?: true
    tid?: true
    subjid?: true
    qtr?: true
    independence?: true
    confidence?: true
    respect?: true
    empathy?: true
    appreciation?: true
    tolerance?: true
    enthusiasm?: true
    conduct?: true
  }

  export type S_studentcvCountAggregateInputType = {
    id?: true
    sid?: true
    tid?: true
    subjid?: true
    qtr?: true
    independence?: true
    confidence?: true
    respect?: true
    empathy?: true
    appreciation?: true
    tolerance?: true
    enthusiasm?: true
    conduct?: true
    _all?: true
  }

  export type S_studentcvAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_studentcv to aggregate.
     */
    where?: s_studentcvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_studentcvs to fetch.
     */
    orderBy?: s_studentcvOrderByWithRelationInput | s_studentcvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: s_studentcvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_studentcvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_studentcvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned s_studentcvs
    **/
    _count?: true | S_studentcvCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: S_studentcvAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: S_studentcvSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S_studentcvMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S_studentcvMaxAggregateInputType
  }

  export type GetS_studentcvAggregateType<T extends S_studentcvAggregateArgs> = {
        [P in keyof T & keyof AggregateS_studentcv]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS_studentcv[P]>
      : GetScalarType<T[P], AggregateS_studentcv[P]>
  }




  export type s_studentcvGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: s_studentcvWhereInput
    orderBy?: s_studentcvOrderByWithAggregationInput | s_studentcvOrderByWithAggregationInput[]
    by: S_studentcvScalarFieldEnum[] | S_studentcvScalarFieldEnum
    having?: s_studentcvScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S_studentcvCountAggregateInputType | true
    _avg?: S_studentcvAvgAggregateInputType
    _sum?: S_studentcvSumAggregateInputType
    _min?: S_studentcvMinAggregateInputType
    _max?: S_studentcvMaxAggregateInputType
  }

  export type S_studentcvGroupByOutputType = {
    id: number
    sid: string
    tid: string
    subjid: string
    qtr: number
    independence: Decimal
    confidence: Decimal
    respect: Decimal
    empathy: Decimal
    appreciation: Decimal
    tolerance: Decimal
    enthusiasm: Decimal
    conduct: Decimal
    _count: S_studentcvCountAggregateOutputType | null
    _avg: S_studentcvAvgAggregateOutputType | null
    _sum: S_studentcvSumAggregateOutputType | null
    _min: S_studentcvMinAggregateOutputType | null
    _max: S_studentcvMaxAggregateOutputType | null
  }

  type GetS_studentcvGroupByPayload<T extends s_studentcvGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S_studentcvGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S_studentcvGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S_studentcvGroupByOutputType[P]>
            : GetScalarType<T[P], S_studentcvGroupByOutputType[P]>
        }
      >
    >


  export type s_studentcvSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sid?: boolean
    tid?: boolean
    subjid?: boolean
    qtr?: boolean
    independence?: boolean
    confidence?: boolean
    respect?: boolean
    empathy?: boolean
    appreciation?: boolean
    tolerance?: boolean
    enthusiasm?: boolean
    conduct?: boolean
  }, ExtArgs["result"]["s_studentcv"]>



  export type s_studentcvSelectScalar = {
    id?: boolean
    sid?: boolean
    tid?: boolean
    subjid?: boolean
    qtr?: boolean
    independence?: boolean
    confidence?: boolean
    respect?: boolean
    empathy?: boolean
    appreciation?: boolean
    tolerance?: boolean
    enthusiasm?: boolean
    conduct?: boolean
  }

  export type s_studentcvOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sid" | "tid" | "subjid" | "qtr" | "independence" | "confidence" | "respect" | "empathy" | "appreciation" | "tolerance" | "enthusiasm" | "conduct", ExtArgs["result"]["s_studentcv"]>

  export type $s_studentcvPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "s_studentcv"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sid: string
      tid: string
      subjid: string
      qtr: number
      independence: Prisma.Decimal
      confidence: Prisma.Decimal
      respect: Prisma.Decimal
      empathy: Prisma.Decimal
      appreciation: Prisma.Decimal
      tolerance: Prisma.Decimal
      enthusiasm: Prisma.Decimal
      conduct: Prisma.Decimal
    }, ExtArgs["result"]["s_studentcv"]>
    composites: {}
  }

  type s_studentcvGetPayload<S extends boolean | null | undefined | s_studentcvDefaultArgs> = $Result.GetResult<Prisma.$s_studentcvPayload, S>

  type s_studentcvCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<s_studentcvFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S_studentcvCountAggregateInputType | true
    }

  export interface s_studentcvDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['s_studentcv'], meta: { name: 's_studentcv' } }
    /**
     * Find zero or one S_studentcv that matches the filter.
     * @param {s_studentcvFindUniqueArgs} args - Arguments to find a S_studentcv
     * @example
     * // Get one S_studentcv
     * const s_studentcv = await prisma.s_studentcv.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends s_studentcvFindUniqueArgs>(args: SelectSubset<T, s_studentcvFindUniqueArgs<ExtArgs>>): Prisma__s_studentcvClient<$Result.GetResult<Prisma.$s_studentcvPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S_studentcv that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {s_studentcvFindUniqueOrThrowArgs} args - Arguments to find a S_studentcv
     * @example
     * // Get one S_studentcv
     * const s_studentcv = await prisma.s_studentcv.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends s_studentcvFindUniqueOrThrowArgs>(args: SelectSubset<T, s_studentcvFindUniqueOrThrowArgs<ExtArgs>>): Prisma__s_studentcvClient<$Result.GetResult<Prisma.$s_studentcvPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_studentcv that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_studentcvFindFirstArgs} args - Arguments to find a S_studentcv
     * @example
     * // Get one S_studentcv
     * const s_studentcv = await prisma.s_studentcv.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends s_studentcvFindFirstArgs>(args?: SelectSubset<T, s_studentcvFindFirstArgs<ExtArgs>>): Prisma__s_studentcvClient<$Result.GetResult<Prisma.$s_studentcvPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_studentcv that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_studentcvFindFirstOrThrowArgs} args - Arguments to find a S_studentcv
     * @example
     * // Get one S_studentcv
     * const s_studentcv = await prisma.s_studentcv.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends s_studentcvFindFirstOrThrowArgs>(args?: SelectSubset<T, s_studentcvFindFirstOrThrowArgs<ExtArgs>>): Prisma__s_studentcvClient<$Result.GetResult<Prisma.$s_studentcvPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S_studentcvs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_studentcvFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S_studentcvs
     * const s_studentcvs = await prisma.s_studentcv.findMany()
     * 
     * // Get first 10 S_studentcvs
     * const s_studentcvs = await prisma.s_studentcv.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const s_studentcvWithIdOnly = await prisma.s_studentcv.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends s_studentcvFindManyArgs>(args?: SelectSubset<T, s_studentcvFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$s_studentcvPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S_studentcv.
     * @param {s_studentcvCreateArgs} args - Arguments to create a S_studentcv.
     * @example
     * // Create one S_studentcv
     * const S_studentcv = await prisma.s_studentcv.create({
     *   data: {
     *     // ... data to create a S_studentcv
     *   }
     * })
     * 
     */
    create<T extends s_studentcvCreateArgs>(args: SelectSubset<T, s_studentcvCreateArgs<ExtArgs>>): Prisma__s_studentcvClient<$Result.GetResult<Prisma.$s_studentcvPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S_studentcvs.
     * @param {s_studentcvCreateManyArgs} args - Arguments to create many S_studentcvs.
     * @example
     * // Create many S_studentcvs
     * const s_studentcv = await prisma.s_studentcv.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends s_studentcvCreateManyArgs>(args?: SelectSubset<T, s_studentcvCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a S_studentcv.
     * @param {s_studentcvDeleteArgs} args - Arguments to delete one S_studentcv.
     * @example
     * // Delete one S_studentcv
     * const S_studentcv = await prisma.s_studentcv.delete({
     *   where: {
     *     // ... filter to delete one S_studentcv
     *   }
     * })
     * 
     */
    delete<T extends s_studentcvDeleteArgs>(args: SelectSubset<T, s_studentcvDeleteArgs<ExtArgs>>): Prisma__s_studentcvClient<$Result.GetResult<Prisma.$s_studentcvPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S_studentcv.
     * @param {s_studentcvUpdateArgs} args - Arguments to update one S_studentcv.
     * @example
     * // Update one S_studentcv
     * const s_studentcv = await prisma.s_studentcv.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends s_studentcvUpdateArgs>(args: SelectSubset<T, s_studentcvUpdateArgs<ExtArgs>>): Prisma__s_studentcvClient<$Result.GetResult<Prisma.$s_studentcvPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S_studentcvs.
     * @param {s_studentcvDeleteManyArgs} args - Arguments to filter S_studentcvs to delete.
     * @example
     * // Delete a few S_studentcvs
     * const { count } = await prisma.s_studentcv.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends s_studentcvDeleteManyArgs>(args?: SelectSubset<T, s_studentcvDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S_studentcvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_studentcvUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S_studentcvs
     * const s_studentcv = await prisma.s_studentcv.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends s_studentcvUpdateManyArgs>(args: SelectSubset<T, s_studentcvUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one S_studentcv.
     * @param {s_studentcvUpsertArgs} args - Arguments to update or create a S_studentcv.
     * @example
     * // Update or create a S_studentcv
     * const s_studentcv = await prisma.s_studentcv.upsert({
     *   create: {
     *     // ... data to create a S_studentcv
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S_studentcv we want to update
     *   }
     * })
     */
    upsert<T extends s_studentcvUpsertArgs>(args: SelectSubset<T, s_studentcvUpsertArgs<ExtArgs>>): Prisma__s_studentcvClient<$Result.GetResult<Prisma.$s_studentcvPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S_studentcvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_studentcvCountArgs} args - Arguments to filter S_studentcvs to count.
     * @example
     * // Count the number of S_studentcvs
     * const count = await prisma.s_studentcv.count({
     *   where: {
     *     // ... the filter for the S_studentcvs we want to count
     *   }
     * })
    **/
    count<T extends s_studentcvCountArgs>(
      args?: Subset<T, s_studentcvCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S_studentcvCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S_studentcv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S_studentcvAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S_studentcvAggregateArgs>(args: Subset<T, S_studentcvAggregateArgs>): Prisma.PrismaPromise<GetS_studentcvAggregateType<T>>

    /**
     * Group by S_studentcv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_studentcvGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends s_studentcvGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: s_studentcvGroupByArgs['orderBy'] }
        : { orderBy?: s_studentcvGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, s_studentcvGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS_studentcvGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the s_studentcv model
   */
  readonly fields: s_studentcvFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for s_studentcv.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__s_studentcvClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the s_studentcv model
   */
  interface s_studentcvFieldRefs {
    readonly id: FieldRef<"s_studentcv", 'Int'>
    readonly sid: FieldRef<"s_studentcv", 'String'>
    readonly tid: FieldRef<"s_studentcv", 'String'>
    readonly subjid: FieldRef<"s_studentcv", 'String'>
    readonly qtr: FieldRef<"s_studentcv", 'Int'>
    readonly independence: FieldRef<"s_studentcv", 'Decimal'>
    readonly confidence: FieldRef<"s_studentcv", 'Decimal'>
    readonly respect: FieldRef<"s_studentcv", 'Decimal'>
    readonly empathy: FieldRef<"s_studentcv", 'Decimal'>
    readonly appreciation: FieldRef<"s_studentcv", 'Decimal'>
    readonly tolerance: FieldRef<"s_studentcv", 'Decimal'>
    readonly enthusiasm: FieldRef<"s_studentcv", 'Decimal'>
    readonly conduct: FieldRef<"s_studentcv", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * s_studentcv findUnique
   */
  export type s_studentcvFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_studentcv
     */
    select?: s_studentcvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_studentcv
     */
    omit?: s_studentcvOmit<ExtArgs> | null
    /**
     * Filter, which s_studentcv to fetch.
     */
    where: s_studentcvWhereUniqueInput
  }

  /**
   * s_studentcv findUniqueOrThrow
   */
  export type s_studentcvFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_studentcv
     */
    select?: s_studentcvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_studentcv
     */
    omit?: s_studentcvOmit<ExtArgs> | null
    /**
     * Filter, which s_studentcv to fetch.
     */
    where: s_studentcvWhereUniqueInput
  }

  /**
   * s_studentcv findFirst
   */
  export type s_studentcvFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_studentcv
     */
    select?: s_studentcvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_studentcv
     */
    omit?: s_studentcvOmit<ExtArgs> | null
    /**
     * Filter, which s_studentcv to fetch.
     */
    where?: s_studentcvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_studentcvs to fetch.
     */
    orderBy?: s_studentcvOrderByWithRelationInput | s_studentcvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_studentcvs.
     */
    cursor?: s_studentcvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_studentcvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_studentcvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_studentcvs.
     */
    distinct?: S_studentcvScalarFieldEnum | S_studentcvScalarFieldEnum[]
  }

  /**
   * s_studentcv findFirstOrThrow
   */
  export type s_studentcvFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_studentcv
     */
    select?: s_studentcvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_studentcv
     */
    omit?: s_studentcvOmit<ExtArgs> | null
    /**
     * Filter, which s_studentcv to fetch.
     */
    where?: s_studentcvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_studentcvs to fetch.
     */
    orderBy?: s_studentcvOrderByWithRelationInput | s_studentcvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_studentcvs.
     */
    cursor?: s_studentcvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_studentcvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_studentcvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_studentcvs.
     */
    distinct?: S_studentcvScalarFieldEnum | S_studentcvScalarFieldEnum[]
  }

  /**
   * s_studentcv findMany
   */
  export type s_studentcvFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_studentcv
     */
    select?: s_studentcvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_studentcv
     */
    omit?: s_studentcvOmit<ExtArgs> | null
    /**
     * Filter, which s_studentcvs to fetch.
     */
    where?: s_studentcvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_studentcvs to fetch.
     */
    orderBy?: s_studentcvOrderByWithRelationInput | s_studentcvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing s_studentcvs.
     */
    cursor?: s_studentcvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_studentcvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_studentcvs.
     */
    skip?: number
    distinct?: S_studentcvScalarFieldEnum | S_studentcvScalarFieldEnum[]
  }

  /**
   * s_studentcv create
   */
  export type s_studentcvCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_studentcv
     */
    select?: s_studentcvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_studentcv
     */
    omit?: s_studentcvOmit<ExtArgs> | null
    /**
     * The data needed to create a s_studentcv.
     */
    data: XOR<s_studentcvCreateInput, s_studentcvUncheckedCreateInput>
  }

  /**
   * s_studentcv createMany
   */
  export type s_studentcvCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many s_studentcvs.
     */
    data: s_studentcvCreateManyInput | s_studentcvCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * s_studentcv update
   */
  export type s_studentcvUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_studentcv
     */
    select?: s_studentcvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_studentcv
     */
    omit?: s_studentcvOmit<ExtArgs> | null
    /**
     * The data needed to update a s_studentcv.
     */
    data: XOR<s_studentcvUpdateInput, s_studentcvUncheckedUpdateInput>
    /**
     * Choose, which s_studentcv to update.
     */
    where: s_studentcvWhereUniqueInput
  }

  /**
   * s_studentcv updateMany
   */
  export type s_studentcvUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update s_studentcvs.
     */
    data: XOR<s_studentcvUpdateManyMutationInput, s_studentcvUncheckedUpdateManyInput>
    /**
     * Filter which s_studentcvs to update
     */
    where?: s_studentcvWhereInput
    /**
     * Limit how many s_studentcvs to update.
     */
    limit?: number
  }

  /**
   * s_studentcv upsert
   */
  export type s_studentcvUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_studentcv
     */
    select?: s_studentcvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_studentcv
     */
    omit?: s_studentcvOmit<ExtArgs> | null
    /**
     * The filter to search for the s_studentcv to update in case it exists.
     */
    where: s_studentcvWhereUniqueInput
    /**
     * In case the s_studentcv found by the `where` argument doesn't exist, create a new s_studentcv with this data.
     */
    create: XOR<s_studentcvCreateInput, s_studentcvUncheckedCreateInput>
    /**
     * In case the s_studentcv was found with the provided `where` argument, update it with this data.
     */
    update: XOR<s_studentcvUpdateInput, s_studentcvUncheckedUpdateInput>
  }

  /**
   * s_studentcv delete
   */
  export type s_studentcvDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_studentcv
     */
    select?: s_studentcvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_studentcv
     */
    omit?: s_studentcvOmit<ExtArgs> | null
    /**
     * Filter which s_studentcv to delete.
     */
    where: s_studentcvWhereUniqueInput
  }

  /**
   * s_studentcv deleteMany
   */
  export type s_studentcvDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_studentcvs to delete
     */
    where?: s_studentcvWhereInput
    /**
     * Limit how many s_studentcvs to delete.
     */
    limit?: number
  }

  /**
   * s_studentcv without action
   */
  export type s_studentcvDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_studentcv
     */
    select?: s_studentcvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_studentcv
     */
    omit?: s_studentcvOmit<ExtArgs> | null
  }


  /**
   * Model s_subjects
   */

  export type AggregateS_subjects = {
    _count: S_subjectsCountAggregateOutputType | null
    _avg: S_subjectsAvgAggregateOutputType | null
    _sum: S_subjectsSumAggregateOutputType | null
    _min: S_subjectsMinAggregateOutputType | null
    _max: S_subjectsMaxAggregateOutputType | null
  }

  export type S_subjectsAvgAggregateOutputType = {
    id: number | null
    percentww: number | null
    percentpt: number | null
    percentqt: number | null
  }

  export type S_subjectsSumAggregateOutputType = {
    id: number | null
    percentww: number | null
    percentpt: number | null
    percentqt: number | null
  }

  export type S_subjectsMinAggregateOutputType = {
    id: number | null
    code: string | null
    tid: string | null
    subjdesc: string | null
    subjlevel: string | null
    subjsection: string | null
    assignedby: string | null
    assigndate: Date | null
    percentww: number | null
    percentpt: number | null
    percentqt: number | null
  }

  export type S_subjectsMaxAggregateOutputType = {
    id: number | null
    code: string | null
    tid: string | null
    subjdesc: string | null
    subjlevel: string | null
    subjsection: string | null
    assignedby: string | null
    assigndate: Date | null
    percentww: number | null
    percentpt: number | null
    percentqt: number | null
  }

  export type S_subjectsCountAggregateOutputType = {
    id: number
    code: number
    tid: number
    subjdesc: number
    subjlevel: number
    subjsection: number
    assignedby: number
    assigndate: number
    percentww: number
    percentpt: number
    percentqt: number
    _all: number
  }


  export type S_subjectsAvgAggregateInputType = {
    id?: true
    percentww?: true
    percentpt?: true
    percentqt?: true
  }

  export type S_subjectsSumAggregateInputType = {
    id?: true
    percentww?: true
    percentpt?: true
    percentqt?: true
  }

  export type S_subjectsMinAggregateInputType = {
    id?: true
    code?: true
    tid?: true
    subjdesc?: true
    subjlevel?: true
    subjsection?: true
    assignedby?: true
    assigndate?: true
    percentww?: true
    percentpt?: true
    percentqt?: true
  }

  export type S_subjectsMaxAggregateInputType = {
    id?: true
    code?: true
    tid?: true
    subjdesc?: true
    subjlevel?: true
    subjsection?: true
    assignedby?: true
    assigndate?: true
    percentww?: true
    percentpt?: true
    percentqt?: true
  }

  export type S_subjectsCountAggregateInputType = {
    id?: true
    code?: true
    tid?: true
    subjdesc?: true
    subjlevel?: true
    subjsection?: true
    assignedby?: true
    assigndate?: true
    percentww?: true
    percentpt?: true
    percentqt?: true
    _all?: true
  }

  export type S_subjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_subjects to aggregate.
     */
    where?: s_subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_subjects to fetch.
     */
    orderBy?: s_subjectsOrderByWithRelationInput | s_subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: s_subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned s_subjects
    **/
    _count?: true | S_subjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: S_subjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: S_subjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S_subjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S_subjectsMaxAggregateInputType
  }

  export type GetS_subjectsAggregateType<T extends S_subjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateS_subjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS_subjects[P]>
      : GetScalarType<T[P], AggregateS_subjects[P]>
  }




  export type s_subjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: s_subjectsWhereInput
    orderBy?: s_subjectsOrderByWithAggregationInput | s_subjectsOrderByWithAggregationInput[]
    by: S_subjectsScalarFieldEnum[] | S_subjectsScalarFieldEnum
    having?: s_subjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S_subjectsCountAggregateInputType | true
    _avg?: S_subjectsAvgAggregateInputType
    _sum?: S_subjectsSumAggregateInputType
    _min?: S_subjectsMinAggregateInputType
    _max?: S_subjectsMaxAggregateInputType
  }

  export type S_subjectsGroupByOutputType = {
    id: number
    code: string
    tid: string
    subjdesc: string
    subjlevel: string
    subjsection: string
    assignedby: string
    assigndate: Date
    percentww: number
    percentpt: number
    percentqt: number
    _count: S_subjectsCountAggregateOutputType | null
    _avg: S_subjectsAvgAggregateOutputType | null
    _sum: S_subjectsSumAggregateOutputType | null
    _min: S_subjectsMinAggregateOutputType | null
    _max: S_subjectsMaxAggregateOutputType | null
  }

  type GetS_subjectsGroupByPayload<T extends s_subjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S_subjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S_subjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S_subjectsGroupByOutputType[P]>
            : GetScalarType<T[P], S_subjectsGroupByOutputType[P]>
        }
      >
    >


  export type s_subjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    tid?: boolean
    subjdesc?: boolean
    subjlevel?: boolean
    subjsection?: boolean
    assignedby?: boolean
    assigndate?: boolean
    percentww?: boolean
    percentpt?: boolean
    percentqt?: boolean
  }, ExtArgs["result"]["s_subjects"]>



  export type s_subjectsSelectScalar = {
    id?: boolean
    code?: boolean
    tid?: boolean
    subjdesc?: boolean
    subjlevel?: boolean
    subjsection?: boolean
    assignedby?: boolean
    assigndate?: boolean
    percentww?: boolean
    percentpt?: boolean
    percentqt?: boolean
  }

  export type s_subjectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "tid" | "subjdesc" | "subjlevel" | "subjsection" | "assignedby" | "assigndate" | "percentww" | "percentpt" | "percentqt", ExtArgs["result"]["s_subjects"]>

  export type $s_subjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "s_subjects"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      tid: string
      subjdesc: string
      subjlevel: string
      subjsection: string
      assignedby: string
      assigndate: Date
      percentww: number
      percentpt: number
      percentqt: number
    }, ExtArgs["result"]["s_subjects"]>
    composites: {}
  }

  type s_subjectsGetPayload<S extends boolean | null | undefined | s_subjectsDefaultArgs> = $Result.GetResult<Prisma.$s_subjectsPayload, S>

  type s_subjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<s_subjectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S_subjectsCountAggregateInputType | true
    }

  export interface s_subjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['s_subjects'], meta: { name: 's_subjects' } }
    /**
     * Find zero or one S_subjects that matches the filter.
     * @param {s_subjectsFindUniqueArgs} args - Arguments to find a S_subjects
     * @example
     * // Get one S_subjects
     * const s_subjects = await prisma.s_subjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends s_subjectsFindUniqueArgs>(args: SelectSubset<T, s_subjectsFindUniqueArgs<ExtArgs>>): Prisma__s_subjectsClient<$Result.GetResult<Prisma.$s_subjectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S_subjects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {s_subjectsFindUniqueOrThrowArgs} args - Arguments to find a S_subjects
     * @example
     * // Get one S_subjects
     * const s_subjects = await prisma.s_subjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends s_subjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, s_subjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__s_subjectsClient<$Result.GetResult<Prisma.$s_subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_subjectsFindFirstArgs} args - Arguments to find a S_subjects
     * @example
     * // Get one S_subjects
     * const s_subjects = await prisma.s_subjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends s_subjectsFindFirstArgs>(args?: SelectSubset<T, s_subjectsFindFirstArgs<ExtArgs>>): Prisma__s_subjectsClient<$Result.GetResult<Prisma.$s_subjectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_subjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_subjectsFindFirstOrThrowArgs} args - Arguments to find a S_subjects
     * @example
     * // Get one S_subjects
     * const s_subjects = await prisma.s_subjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends s_subjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, s_subjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__s_subjectsClient<$Result.GetResult<Prisma.$s_subjectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S_subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_subjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S_subjects
     * const s_subjects = await prisma.s_subjects.findMany()
     * 
     * // Get first 10 S_subjects
     * const s_subjects = await prisma.s_subjects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const s_subjectsWithIdOnly = await prisma.s_subjects.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends s_subjectsFindManyArgs>(args?: SelectSubset<T, s_subjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$s_subjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S_subjects.
     * @param {s_subjectsCreateArgs} args - Arguments to create a S_subjects.
     * @example
     * // Create one S_subjects
     * const S_subjects = await prisma.s_subjects.create({
     *   data: {
     *     // ... data to create a S_subjects
     *   }
     * })
     * 
     */
    create<T extends s_subjectsCreateArgs>(args: SelectSubset<T, s_subjectsCreateArgs<ExtArgs>>): Prisma__s_subjectsClient<$Result.GetResult<Prisma.$s_subjectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S_subjects.
     * @param {s_subjectsCreateManyArgs} args - Arguments to create many S_subjects.
     * @example
     * // Create many S_subjects
     * const s_subjects = await prisma.s_subjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends s_subjectsCreateManyArgs>(args?: SelectSubset<T, s_subjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a S_subjects.
     * @param {s_subjectsDeleteArgs} args - Arguments to delete one S_subjects.
     * @example
     * // Delete one S_subjects
     * const S_subjects = await prisma.s_subjects.delete({
     *   where: {
     *     // ... filter to delete one S_subjects
     *   }
     * })
     * 
     */
    delete<T extends s_subjectsDeleteArgs>(args: SelectSubset<T, s_subjectsDeleteArgs<ExtArgs>>): Prisma__s_subjectsClient<$Result.GetResult<Prisma.$s_subjectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S_subjects.
     * @param {s_subjectsUpdateArgs} args - Arguments to update one S_subjects.
     * @example
     * // Update one S_subjects
     * const s_subjects = await prisma.s_subjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends s_subjectsUpdateArgs>(args: SelectSubset<T, s_subjectsUpdateArgs<ExtArgs>>): Prisma__s_subjectsClient<$Result.GetResult<Prisma.$s_subjectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S_subjects.
     * @param {s_subjectsDeleteManyArgs} args - Arguments to filter S_subjects to delete.
     * @example
     * // Delete a few S_subjects
     * const { count } = await prisma.s_subjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends s_subjectsDeleteManyArgs>(args?: SelectSubset<T, s_subjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S_subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_subjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S_subjects
     * const s_subjects = await prisma.s_subjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends s_subjectsUpdateManyArgs>(args: SelectSubset<T, s_subjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one S_subjects.
     * @param {s_subjectsUpsertArgs} args - Arguments to update or create a S_subjects.
     * @example
     * // Update or create a S_subjects
     * const s_subjects = await prisma.s_subjects.upsert({
     *   create: {
     *     // ... data to create a S_subjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S_subjects we want to update
     *   }
     * })
     */
    upsert<T extends s_subjectsUpsertArgs>(args: SelectSubset<T, s_subjectsUpsertArgs<ExtArgs>>): Prisma__s_subjectsClient<$Result.GetResult<Prisma.$s_subjectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S_subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_subjectsCountArgs} args - Arguments to filter S_subjects to count.
     * @example
     * // Count the number of S_subjects
     * const count = await prisma.s_subjects.count({
     *   where: {
     *     // ... the filter for the S_subjects we want to count
     *   }
     * })
    **/
    count<T extends s_subjectsCountArgs>(
      args?: Subset<T, s_subjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S_subjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S_subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S_subjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S_subjectsAggregateArgs>(args: Subset<T, S_subjectsAggregateArgs>): Prisma.PrismaPromise<GetS_subjectsAggregateType<T>>

    /**
     * Group by S_subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_subjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends s_subjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: s_subjectsGroupByArgs['orderBy'] }
        : { orderBy?: s_subjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, s_subjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS_subjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the s_subjects model
   */
  readonly fields: s_subjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for s_subjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__s_subjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the s_subjects model
   */
  interface s_subjectsFieldRefs {
    readonly id: FieldRef<"s_subjects", 'Int'>
    readonly code: FieldRef<"s_subjects", 'String'>
    readonly tid: FieldRef<"s_subjects", 'String'>
    readonly subjdesc: FieldRef<"s_subjects", 'String'>
    readonly subjlevel: FieldRef<"s_subjects", 'String'>
    readonly subjsection: FieldRef<"s_subjects", 'String'>
    readonly assignedby: FieldRef<"s_subjects", 'String'>
    readonly assigndate: FieldRef<"s_subjects", 'DateTime'>
    readonly percentww: FieldRef<"s_subjects", 'Float'>
    readonly percentpt: FieldRef<"s_subjects", 'Float'>
    readonly percentqt: FieldRef<"s_subjects", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * s_subjects findUnique
   */
  export type s_subjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_subjects
     */
    select?: s_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_subjects
     */
    omit?: s_subjectsOmit<ExtArgs> | null
    /**
     * Filter, which s_subjects to fetch.
     */
    where: s_subjectsWhereUniqueInput
  }

  /**
   * s_subjects findUniqueOrThrow
   */
  export type s_subjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_subjects
     */
    select?: s_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_subjects
     */
    omit?: s_subjectsOmit<ExtArgs> | null
    /**
     * Filter, which s_subjects to fetch.
     */
    where: s_subjectsWhereUniqueInput
  }

  /**
   * s_subjects findFirst
   */
  export type s_subjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_subjects
     */
    select?: s_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_subjects
     */
    omit?: s_subjectsOmit<ExtArgs> | null
    /**
     * Filter, which s_subjects to fetch.
     */
    where?: s_subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_subjects to fetch.
     */
    orderBy?: s_subjectsOrderByWithRelationInput | s_subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_subjects.
     */
    cursor?: s_subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_subjects.
     */
    distinct?: S_subjectsScalarFieldEnum | S_subjectsScalarFieldEnum[]
  }

  /**
   * s_subjects findFirstOrThrow
   */
  export type s_subjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_subjects
     */
    select?: s_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_subjects
     */
    omit?: s_subjectsOmit<ExtArgs> | null
    /**
     * Filter, which s_subjects to fetch.
     */
    where?: s_subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_subjects to fetch.
     */
    orderBy?: s_subjectsOrderByWithRelationInput | s_subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_subjects.
     */
    cursor?: s_subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_subjects.
     */
    distinct?: S_subjectsScalarFieldEnum | S_subjectsScalarFieldEnum[]
  }

  /**
   * s_subjects findMany
   */
  export type s_subjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_subjects
     */
    select?: s_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_subjects
     */
    omit?: s_subjectsOmit<ExtArgs> | null
    /**
     * Filter, which s_subjects to fetch.
     */
    where?: s_subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_subjects to fetch.
     */
    orderBy?: s_subjectsOrderByWithRelationInput | s_subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing s_subjects.
     */
    cursor?: s_subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_subjects.
     */
    skip?: number
    distinct?: S_subjectsScalarFieldEnum | S_subjectsScalarFieldEnum[]
  }

  /**
   * s_subjects create
   */
  export type s_subjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_subjects
     */
    select?: s_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_subjects
     */
    omit?: s_subjectsOmit<ExtArgs> | null
    /**
     * The data needed to create a s_subjects.
     */
    data: XOR<s_subjectsCreateInput, s_subjectsUncheckedCreateInput>
  }

  /**
   * s_subjects createMany
   */
  export type s_subjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many s_subjects.
     */
    data: s_subjectsCreateManyInput | s_subjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * s_subjects update
   */
  export type s_subjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_subjects
     */
    select?: s_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_subjects
     */
    omit?: s_subjectsOmit<ExtArgs> | null
    /**
     * The data needed to update a s_subjects.
     */
    data: XOR<s_subjectsUpdateInput, s_subjectsUncheckedUpdateInput>
    /**
     * Choose, which s_subjects to update.
     */
    where: s_subjectsWhereUniqueInput
  }

  /**
   * s_subjects updateMany
   */
  export type s_subjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update s_subjects.
     */
    data: XOR<s_subjectsUpdateManyMutationInput, s_subjectsUncheckedUpdateManyInput>
    /**
     * Filter which s_subjects to update
     */
    where?: s_subjectsWhereInput
    /**
     * Limit how many s_subjects to update.
     */
    limit?: number
  }

  /**
   * s_subjects upsert
   */
  export type s_subjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_subjects
     */
    select?: s_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_subjects
     */
    omit?: s_subjectsOmit<ExtArgs> | null
    /**
     * The filter to search for the s_subjects to update in case it exists.
     */
    where: s_subjectsWhereUniqueInput
    /**
     * In case the s_subjects found by the `where` argument doesn't exist, create a new s_subjects with this data.
     */
    create: XOR<s_subjectsCreateInput, s_subjectsUncheckedCreateInput>
    /**
     * In case the s_subjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<s_subjectsUpdateInput, s_subjectsUncheckedUpdateInput>
  }

  /**
   * s_subjects delete
   */
  export type s_subjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_subjects
     */
    select?: s_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_subjects
     */
    omit?: s_subjectsOmit<ExtArgs> | null
    /**
     * Filter which s_subjects to delete.
     */
    where: s_subjectsWhereUniqueInput
  }

  /**
   * s_subjects deleteMany
   */
  export type s_subjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_subjects to delete
     */
    where?: s_subjectsWhereInput
    /**
     * Limit how many s_subjects to delete.
     */
    limit?: number
  }

  /**
   * s_subjects without action
   */
  export type s_subjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_subjects
     */
    select?: s_subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_subjects
     */
    omit?: s_subjectsOmit<ExtArgs> | null
  }


  /**
   * Model s_transmute
   */

  export type AggregateS_transmute = {
    _count: S_transmuteCountAggregateOutputType | null
    _avg: S_transmuteAvgAggregateOutputType | null
    _sum: S_transmuteSumAggregateOutputType | null
    _min: S_transmuteMinAggregateOutputType | null
    _max: S_transmuteMaxAggregateOutputType | null
  }

  export type S_transmuteAvgAggregateOutputType = {
    id: number | null
    lowerl: number | null
    upperl: number | null
    transmuted: number | null
  }

  export type S_transmuteSumAggregateOutputType = {
    id: number | null
    lowerl: number | null
    upperl: number | null
    transmuted: number | null
  }

  export type S_transmuteMinAggregateOutputType = {
    id: number | null
    lowerl: number | null
    upperl: number | null
    transmuted: number | null
  }

  export type S_transmuteMaxAggregateOutputType = {
    id: number | null
    lowerl: number | null
    upperl: number | null
    transmuted: number | null
  }

  export type S_transmuteCountAggregateOutputType = {
    id: number
    lowerl: number
    upperl: number
    transmuted: number
    _all: number
  }


  export type S_transmuteAvgAggregateInputType = {
    id?: true
    lowerl?: true
    upperl?: true
    transmuted?: true
  }

  export type S_transmuteSumAggregateInputType = {
    id?: true
    lowerl?: true
    upperl?: true
    transmuted?: true
  }

  export type S_transmuteMinAggregateInputType = {
    id?: true
    lowerl?: true
    upperl?: true
    transmuted?: true
  }

  export type S_transmuteMaxAggregateInputType = {
    id?: true
    lowerl?: true
    upperl?: true
    transmuted?: true
  }

  export type S_transmuteCountAggregateInputType = {
    id?: true
    lowerl?: true
    upperl?: true
    transmuted?: true
    _all?: true
  }

  export type S_transmuteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_transmute to aggregate.
     */
    where?: s_transmuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_transmutes to fetch.
     */
    orderBy?: s_transmuteOrderByWithRelationInput | s_transmuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: s_transmuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_transmutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_transmutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned s_transmutes
    **/
    _count?: true | S_transmuteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: S_transmuteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: S_transmuteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S_transmuteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S_transmuteMaxAggregateInputType
  }

  export type GetS_transmuteAggregateType<T extends S_transmuteAggregateArgs> = {
        [P in keyof T & keyof AggregateS_transmute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS_transmute[P]>
      : GetScalarType<T[P], AggregateS_transmute[P]>
  }




  export type s_transmuteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: s_transmuteWhereInput
    orderBy?: s_transmuteOrderByWithAggregationInput | s_transmuteOrderByWithAggregationInput[]
    by: S_transmuteScalarFieldEnum[] | S_transmuteScalarFieldEnum
    having?: s_transmuteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S_transmuteCountAggregateInputType | true
    _avg?: S_transmuteAvgAggregateInputType
    _sum?: S_transmuteSumAggregateInputType
    _min?: S_transmuteMinAggregateInputType
    _max?: S_transmuteMaxAggregateInputType
  }

  export type S_transmuteGroupByOutputType = {
    id: number
    lowerl: number
    upperl: number
    transmuted: number
    _count: S_transmuteCountAggregateOutputType | null
    _avg: S_transmuteAvgAggregateOutputType | null
    _sum: S_transmuteSumAggregateOutputType | null
    _min: S_transmuteMinAggregateOutputType | null
    _max: S_transmuteMaxAggregateOutputType | null
  }

  type GetS_transmuteGroupByPayload<T extends s_transmuteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S_transmuteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S_transmuteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S_transmuteGroupByOutputType[P]>
            : GetScalarType<T[P], S_transmuteGroupByOutputType[P]>
        }
      >
    >


  export type s_transmuteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lowerl?: boolean
    upperl?: boolean
    transmuted?: boolean
  }, ExtArgs["result"]["s_transmute"]>



  export type s_transmuteSelectScalar = {
    id?: boolean
    lowerl?: boolean
    upperl?: boolean
    transmuted?: boolean
  }

  export type s_transmuteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lowerl" | "upperl" | "transmuted", ExtArgs["result"]["s_transmute"]>

  export type $s_transmutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "s_transmute"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lowerl: number
      upperl: number
      transmuted: number
    }, ExtArgs["result"]["s_transmute"]>
    composites: {}
  }

  type s_transmuteGetPayload<S extends boolean | null | undefined | s_transmuteDefaultArgs> = $Result.GetResult<Prisma.$s_transmutePayload, S>

  type s_transmuteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<s_transmuteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S_transmuteCountAggregateInputType | true
    }

  export interface s_transmuteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['s_transmute'], meta: { name: 's_transmute' } }
    /**
     * Find zero or one S_transmute that matches the filter.
     * @param {s_transmuteFindUniqueArgs} args - Arguments to find a S_transmute
     * @example
     * // Get one S_transmute
     * const s_transmute = await prisma.s_transmute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends s_transmuteFindUniqueArgs>(args: SelectSubset<T, s_transmuteFindUniqueArgs<ExtArgs>>): Prisma__s_transmuteClient<$Result.GetResult<Prisma.$s_transmutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S_transmute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {s_transmuteFindUniqueOrThrowArgs} args - Arguments to find a S_transmute
     * @example
     * // Get one S_transmute
     * const s_transmute = await prisma.s_transmute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends s_transmuteFindUniqueOrThrowArgs>(args: SelectSubset<T, s_transmuteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__s_transmuteClient<$Result.GetResult<Prisma.$s_transmutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_transmute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_transmuteFindFirstArgs} args - Arguments to find a S_transmute
     * @example
     * // Get one S_transmute
     * const s_transmute = await prisma.s_transmute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends s_transmuteFindFirstArgs>(args?: SelectSubset<T, s_transmuteFindFirstArgs<ExtArgs>>): Prisma__s_transmuteClient<$Result.GetResult<Prisma.$s_transmutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_transmute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_transmuteFindFirstOrThrowArgs} args - Arguments to find a S_transmute
     * @example
     * // Get one S_transmute
     * const s_transmute = await prisma.s_transmute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends s_transmuteFindFirstOrThrowArgs>(args?: SelectSubset<T, s_transmuteFindFirstOrThrowArgs<ExtArgs>>): Prisma__s_transmuteClient<$Result.GetResult<Prisma.$s_transmutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S_transmutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_transmuteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S_transmutes
     * const s_transmutes = await prisma.s_transmute.findMany()
     * 
     * // Get first 10 S_transmutes
     * const s_transmutes = await prisma.s_transmute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const s_transmuteWithIdOnly = await prisma.s_transmute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends s_transmuteFindManyArgs>(args?: SelectSubset<T, s_transmuteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$s_transmutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S_transmute.
     * @param {s_transmuteCreateArgs} args - Arguments to create a S_transmute.
     * @example
     * // Create one S_transmute
     * const S_transmute = await prisma.s_transmute.create({
     *   data: {
     *     // ... data to create a S_transmute
     *   }
     * })
     * 
     */
    create<T extends s_transmuteCreateArgs>(args: SelectSubset<T, s_transmuteCreateArgs<ExtArgs>>): Prisma__s_transmuteClient<$Result.GetResult<Prisma.$s_transmutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S_transmutes.
     * @param {s_transmuteCreateManyArgs} args - Arguments to create many S_transmutes.
     * @example
     * // Create many S_transmutes
     * const s_transmute = await prisma.s_transmute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends s_transmuteCreateManyArgs>(args?: SelectSubset<T, s_transmuteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a S_transmute.
     * @param {s_transmuteDeleteArgs} args - Arguments to delete one S_transmute.
     * @example
     * // Delete one S_transmute
     * const S_transmute = await prisma.s_transmute.delete({
     *   where: {
     *     // ... filter to delete one S_transmute
     *   }
     * })
     * 
     */
    delete<T extends s_transmuteDeleteArgs>(args: SelectSubset<T, s_transmuteDeleteArgs<ExtArgs>>): Prisma__s_transmuteClient<$Result.GetResult<Prisma.$s_transmutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S_transmute.
     * @param {s_transmuteUpdateArgs} args - Arguments to update one S_transmute.
     * @example
     * // Update one S_transmute
     * const s_transmute = await prisma.s_transmute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends s_transmuteUpdateArgs>(args: SelectSubset<T, s_transmuteUpdateArgs<ExtArgs>>): Prisma__s_transmuteClient<$Result.GetResult<Prisma.$s_transmutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S_transmutes.
     * @param {s_transmuteDeleteManyArgs} args - Arguments to filter S_transmutes to delete.
     * @example
     * // Delete a few S_transmutes
     * const { count } = await prisma.s_transmute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends s_transmuteDeleteManyArgs>(args?: SelectSubset<T, s_transmuteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S_transmutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_transmuteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S_transmutes
     * const s_transmute = await prisma.s_transmute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends s_transmuteUpdateManyArgs>(args: SelectSubset<T, s_transmuteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one S_transmute.
     * @param {s_transmuteUpsertArgs} args - Arguments to update or create a S_transmute.
     * @example
     * // Update or create a S_transmute
     * const s_transmute = await prisma.s_transmute.upsert({
     *   create: {
     *     // ... data to create a S_transmute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S_transmute we want to update
     *   }
     * })
     */
    upsert<T extends s_transmuteUpsertArgs>(args: SelectSubset<T, s_transmuteUpsertArgs<ExtArgs>>): Prisma__s_transmuteClient<$Result.GetResult<Prisma.$s_transmutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S_transmutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_transmuteCountArgs} args - Arguments to filter S_transmutes to count.
     * @example
     * // Count the number of S_transmutes
     * const count = await prisma.s_transmute.count({
     *   where: {
     *     // ... the filter for the S_transmutes we want to count
     *   }
     * })
    **/
    count<T extends s_transmuteCountArgs>(
      args?: Subset<T, s_transmuteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S_transmuteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S_transmute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S_transmuteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S_transmuteAggregateArgs>(args: Subset<T, S_transmuteAggregateArgs>): Prisma.PrismaPromise<GetS_transmuteAggregateType<T>>

    /**
     * Group by S_transmute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_transmuteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends s_transmuteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: s_transmuteGroupByArgs['orderBy'] }
        : { orderBy?: s_transmuteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, s_transmuteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS_transmuteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the s_transmute model
   */
  readonly fields: s_transmuteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for s_transmute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__s_transmuteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the s_transmute model
   */
  interface s_transmuteFieldRefs {
    readonly id: FieldRef<"s_transmute", 'Int'>
    readonly lowerl: FieldRef<"s_transmute", 'Float'>
    readonly upperl: FieldRef<"s_transmute", 'Float'>
    readonly transmuted: FieldRef<"s_transmute", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * s_transmute findUnique
   */
  export type s_transmuteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_transmute
     */
    select?: s_transmuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_transmute
     */
    omit?: s_transmuteOmit<ExtArgs> | null
    /**
     * Filter, which s_transmute to fetch.
     */
    where: s_transmuteWhereUniqueInput
  }

  /**
   * s_transmute findUniqueOrThrow
   */
  export type s_transmuteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_transmute
     */
    select?: s_transmuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_transmute
     */
    omit?: s_transmuteOmit<ExtArgs> | null
    /**
     * Filter, which s_transmute to fetch.
     */
    where: s_transmuteWhereUniqueInput
  }

  /**
   * s_transmute findFirst
   */
  export type s_transmuteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_transmute
     */
    select?: s_transmuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_transmute
     */
    omit?: s_transmuteOmit<ExtArgs> | null
    /**
     * Filter, which s_transmute to fetch.
     */
    where?: s_transmuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_transmutes to fetch.
     */
    orderBy?: s_transmuteOrderByWithRelationInput | s_transmuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_transmutes.
     */
    cursor?: s_transmuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_transmutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_transmutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_transmutes.
     */
    distinct?: S_transmuteScalarFieldEnum | S_transmuteScalarFieldEnum[]
  }

  /**
   * s_transmute findFirstOrThrow
   */
  export type s_transmuteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_transmute
     */
    select?: s_transmuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_transmute
     */
    omit?: s_transmuteOmit<ExtArgs> | null
    /**
     * Filter, which s_transmute to fetch.
     */
    where?: s_transmuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_transmutes to fetch.
     */
    orderBy?: s_transmuteOrderByWithRelationInput | s_transmuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_transmutes.
     */
    cursor?: s_transmuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_transmutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_transmutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_transmutes.
     */
    distinct?: S_transmuteScalarFieldEnum | S_transmuteScalarFieldEnum[]
  }

  /**
   * s_transmute findMany
   */
  export type s_transmuteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_transmute
     */
    select?: s_transmuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_transmute
     */
    omit?: s_transmuteOmit<ExtArgs> | null
    /**
     * Filter, which s_transmutes to fetch.
     */
    where?: s_transmuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_transmutes to fetch.
     */
    orderBy?: s_transmuteOrderByWithRelationInput | s_transmuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing s_transmutes.
     */
    cursor?: s_transmuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_transmutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_transmutes.
     */
    skip?: number
    distinct?: S_transmuteScalarFieldEnum | S_transmuteScalarFieldEnum[]
  }

  /**
   * s_transmute create
   */
  export type s_transmuteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_transmute
     */
    select?: s_transmuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_transmute
     */
    omit?: s_transmuteOmit<ExtArgs> | null
    /**
     * The data needed to create a s_transmute.
     */
    data: XOR<s_transmuteCreateInput, s_transmuteUncheckedCreateInput>
  }

  /**
   * s_transmute createMany
   */
  export type s_transmuteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many s_transmutes.
     */
    data: s_transmuteCreateManyInput | s_transmuteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * s_transmute update
   */
  export type s_transmuteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_transmute
     */
    select?: s_transmuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_transmute
     */
    omit?: s_transmuteOmit<ExtArgs> | null
    /**
     * The data needed to update a s_transmute.
     */
    data: XOR<s_transmuteUpdateInput, s_transmuteUncheckedUpdateInput>
    /**
     * Choose, which s_transmute to update.
     */
    where: s_transmuteWhereUniqueInput
  }

  /**
   * s_transmute updateMany
   */
  export type s_transmuteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update s_transmutes.
     */
    data: XOR<s_transmuteUpdateManyMutationInput, s_transmuteUncheckedUpdateManyInput>
    /**
     * Filter which s_transmutes to update
     */
    where?: s_transmuteWhereInput
    /**
     * Limit how many s_transmutes to update.
     */
    limit?: number
  }

  /**
   * s_transmute upsert
   */
  export type s_transmuteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_transmute
     */
    select?: s_transmuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_transmute
     */
    omit?: s_transmuteOmit<ExtArgs> | null
    /**
     * The filter to search for the s_transmute to update in case it exists.
     */
    where: s_transmuteWhereUniqueInput
    /**
     * In case the s_transmute found by the `where` argument doesn't exist, create a new s_transmute with this data.
     */
    create: XOR<s_transmuteCreateInput, s_transmuteUncheckedCreateInput>
    /**
     * In case the s_transmute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<s_transmuteUpdateInput, s_transmuteUncheckedUpdateInput>
  }

  /**
   * s_transmute delete
   */
  export type s_transmuteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_transmute
     */
    select?: s_transmuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_transmute
     */
    omit?: s_transmuteOmit<ExtArgs> | null
    /**
     * Filter which s_transmute to delete.
     */
    where: s_transmuteWhereUniqueInput
  }

  /**
   * s_transmute deleteMany
   */
  export type s_transmuteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_transmutes to delete
     */
    where?: s_transmuteWhereInput
    /**
     * Limit how many s_transmutes to delete.
     */
    limit?: number
  }

  /**
   * s_transmute without action
   */
  export type s_transmuteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_transmute
     */
    select?: s_transmuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_transmute
     */
    omit?: s_transmuteOmit<ExtArgs> | null
  }


  /**
   * Model s_verifications
   */

  export type AggregateS_verifications = {
    _count: S_verificationsCountAggregateOutputType | null
    _avg: S_verificationsAvgAggregateOutputType | null
    _sum: S_verificationsSumAggregateOutputType | null
    _min: S_verificationsMinAggregateOutputType | null
    _max: S_verificationsMaxAggregateOutputType | null
  }

  export type S_verificationsAvgAggregateOutputType = {
    id: number | null
    grade: number | null
    request_unlock: number | null
    flag: number | null
  }

  export type S_verificationsSumAggregateOutputType = {
    id: number | null
    grade: number | null
    request_unlock: number | null
    flag: number | null
  }

  export type S_verificationsMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    section: string | null
    grade: number | null
    subject: string | null
    request_unlock: number | null
    flag: number | null
    created_at: Date | null
  }

  export type S_verificationsMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    section: string | null
    grade: number | null
    subject: string | null
    request_unlock: number | null
    flag: number | null
    created_at: Date | null
  }

  export type S_verificationsCountAggregateOutputType = {
    id: number
    user_id: number
    section: number
    grade: number
    subject: number
    request_unlock: number
    flag: number
    created_at: number
    _all: number
  }


  export type S_verificationsAvgAggregateInputType = {
    id?: true
    grade?: true
    request_unlock?: true
    flag?: true
  }

  export type S_verificationsSumAggregateInputType = {
    id?: true
    grade?: true
    request_unlock?: true
    flag?: true
  }

  export type S_verificationsMinAggregateInputType = {
    id?: true
    user_id?: true
    section?: true
    grade?: true
    subject?: true
    request_unlock?: true
    flag?: true
    created_at?: true
  }

  export type S_verificationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    section?: true
    grade?: true
    subject?: true
    request_unlock?: true
    flag?: true
    created_at?: true
  }

  export type S_verificationsCountAggregateInputType = {
    id?: true
    user_id?: true
    section?: true
    grade?: true
    subject?: true
    request_unlock?: true
    flag?: true
    created_at?: true
    _all?: true
  }

  export type S_verificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_verifications to aggregate.
     */
    where?: s_verificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_verifications to fetch.
     */
    orderBy?: s_verificationsOrderByWithRelationInput | s_verificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: s_verificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned s_verifications
    **/
    _count?: true | S_verificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: S_verificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: S_verificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S_verificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S_verificationsMaxAggregateInputType
  }

  export type GetS_verificationsAggregateType<T extends S_verificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateS_verifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS_verifications[P]>
      : GetScalarType<T[P], AggregateS_verifications[P]>
  }




  export type s_verificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: s_verificationsWhereInput
    orderBy?: s_verificationsOrderByWithAggregationInput | s_verificationsOrderByWithAggregationInput[]
    by: S_verificationsScalarFieldEnum[] | S_verificationsScalarFieldEnum
    having?: s_verificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S_verificationsCountAggregateInputType | true
    _avg?: S_verificationsAvgAggregateInputType
    _sum?: S_verificationsSumAggregateInputType
    _min?: S_verificationsMinAggregateInputType
    _max?: S_verificationsMaxAggregateInputType
  }

  export type S_verificationsGroupByOutputType = {
    id: number
    user_id: string
    section: string
    grade: number
    subject: string | null
    request_unlock: number | null
    flag: number | null
    created_at: Date
    _count: S_verificationsCountAggregateOutputType | null
    _avg: S_verificationsAvgAggregateOutputType | null
    _sum: S_verificationsSumAggregateOutputType | null
    _min: S_verificationsMinAggregateOutputType | null
    _max: S_verificationsMaxAggregateOutputType | null
  }

  type GetS_verificationsGroupByPayload<T extends s_verificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S_verificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S_verificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S_verificationsGroupByOutputType[P]>
            : GetScalarType<T[P], S_verificationsGroupByOutputType[P]>
        }
      >
    >


  export type s_verificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    section?: boolean
    grade?: boolean
    subject?: boolean
    request_unlock?: boolean
    flag?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["s_verifications"]>



  export type s_verificationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    section?: boolean
    grade?: boolean
    subject?: boolean
    request_unlock?: boolean
    flag?: boolean
    created_at?: boolean
  }

  export type s_verificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "section" | "grade" | "subject" | "request_unlock" | "flag" | "created_at", ExtArgs["result"]["s_verifications"]>

  export type $s_verificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "s_verifications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      section: string
      grade: number
      subject: string | null
      request_unlock: number | null
      flag: number | null
      created_at: Date
    }, ExtArgs["result"]["s_verifications"]>
    composites: {}
  }

  type s_verificationsGetPayload<S extends boolean | null | undefined | s_verificationsDefaultArgs> = $Result.GetResult<Prisma.$s_verificationsPayload, S>

  type s_verificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<s_verificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S_verificationsCountAggregateInputType | true
    }

  export interface s_verificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['s_verifications'], meta: { name: 's_verifications' } }
    /**
     * Find zero or one S_verifications that matches the filter.
     * @param {s_verificationsFindUniqueArgs} args - Arguments to find a S_verifications
     * @example
     * // Get one S_verifications
     * const s_verifications = await prisma.s_verifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends s_verificationsFindUniqueArgs>(args: SelectSubset<T, s_verificationsFindUniqueArgs<ExtArgs>>): Prisma__s_verificationsClient<$Result.GetResult<Prisma.$s_verificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S_verifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {s_verificationsFindUniqueOrThrowArgs} args - Arguments to find a S_verifications
     * @example
     * // Get one S_verifications
     * const s_verifications = await prisma.s_verifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends s_verificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, s_verificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__s_verificationsClient<$Result.GetResult<Prisma.$s_verificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_verificationsFindFirstArgs} args - Arguments to find a S_verifications
     * @example
     * // Get one S_verifications
     * const s_verifications = await prisma.s_verifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends s_verificationsFindFirstArgs>(args?: SelectSubset<T, s_verificationsFindFirstArgs<ExtArgs>>): Prisma__s_verificationsClient<$Result.GetResult<Prisma.$s_verificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S_verifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_verificationsFindFirstOrThrowArgs} args - Arguments to find a S_verifications
     * @example
     * // Get one S_verifications
     * const s_verifications = await prisma.s_verifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends s_verificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, s_verificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__s_verificationsClient<$Result.GetResult<Prisma.$s_verificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S_verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_verificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S_verifications
     * const s_verifications = await prisma.s_verifications.findMany()
     * 
     * // Get first 10 S_verifications
     * const s_verifications = await prisma.s_verifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const s_verificationsWithIdOnly = await prisma.s_verifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends s_verificationsFindManyArgs>(args?: SelectSubset<T, s_verificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$s_verificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S_verifications.
     * @param {s_verificationsCreateArgs} args - Arguments to create a S_verifications.
     * @example
     * // Create one S_verifications
     * const S_verifications = await prisma.s_verifications.create({
     *   data: {
     *     // ... data to create a S_verifications
     *   }
     * })
     * 
     */
    create<T extends s_verificationsCreateArgs>(args: SelectSubset<T, s_verificationsCreateArgs<ExtArgs>>): Prisma__s_verificationsClient<$Result.GetResult<Prisma.$s_verificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S_verifications.
     * @param {s_verificationsCreateManyArgs} args - Arguments to create many S_verifications.
     * @example
     * // Create many S_verifications
     * const s_verifications = await prisma.s_verifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends s_verificationsCreateManyArgs>(args?: SelectSubset<T, s_verificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a S_verifications.
     * @param {s_verificationsDeleteArgs} args - Arguments to delete one S_verifications.
     * @example
     * // Delete one S_verifications
     * const S_verifications = await prisma.s_verifications.delete({
     *   where: {
     *     // ... filter to delete one S_verifications
     *   }
     * })
     * 
     */
    delete<T extends s_verificationsDeleteArgs>(args: SelectSubset<T, s_verificationsDeleteArgs<ExtArgs>>): Prisma__s_verificationsClient<$Result.GetResult<Prisma.$s_verificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S_verifications.
     * @param {s_verificationsUpdateArgs} args - Arguments to update one S_verifications.
     * @example
     * // Update one S_verifications
     * const s_verifications = await prisma.s_verifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends s_verificationsUpdateArgs>(args: SelectSubset<T, s_verificationsUpdateArgs<ExtArgs>>): Prisma__s_verificationsClient<$Result.GetResult<Prisma.$s_verificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S_verifications.
     * @param {s_verificationsDeleteManyArgs} args - Arguments to filter S_verifications to delete.
     * @example
     * // Delete a few S_verifications
     * const { count } = await prisma.s_verifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends s_verificationsDeleteManyArgs>(args?: SelectSubset<T, s_verificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S_verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_verificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S_verifications
     * const s_verifications = await prisma.s_verifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends s_verificationsUpdateManyArgs>(args: SelectSubset<T, s_verificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one S_verifications.
     * @param {s_verificationsUpsertArgs} args - Arguments to update or create a S_verifications.
     * @example
     * // Update or create a S_verifications
     * const s_verifications = await prisma.s_verifications.upsert({
     *   create: {
     *     // ... data to create a S_verifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S_verifications we want to update
     *   }
     * })
     */
    upsert<T extends s_verificationsUpsertArgs>(args: SelectSubset<T, s_verificationsUpsertArgs<ExtArgs>>): Prisma__s_verificationsClient<$Result.GetResult<Prisma.$s_verificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S_verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_verificationsCountArgs} args - Arguments to filter S_verifications to count.
     * @example
     * // Count the number of S_verifications
     * const count = await prisma.s_verifications.count({
     *   where: {
     *     // ... the filter for the S_verifications we want to count
     *   }
     * })
    **/
    count<T extends s_verificationsCountArgs>(
      args?: Subset<T, s_verificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S_verificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S_verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S_verificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S_verificationsAggregateArgs>(args: Subset<T, S_verificationsAggregateArgs>): Prisma.PrismaPromise<GetS_verificationsAggregateType<T>>

    /**
     * Group by S_verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {s_verificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends s_verificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: s_verificationsGroupByArgs['orderBy'] }
        : { orderBy?: s_verificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, s_verificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS_verificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the s_verifications model
   */
  readonly fields: s_verificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for s_verifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__s_verificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the s_verifications model
   */
  interface s_verificationsFieldRefs {
    readonly id: FieldRef<"s_verifications", 'Int'>
    readonly user_id: FieldRef<"s_verifications", 'String'>
    readonly section: FieldRef<"s_verifications", 'String'>
    readonly grade: FieldRef<"s_verifications", 'Int'>
    readonly subject: FieldRef<"s_verifications", 'String'>
    readonly request_unlock: FieldRef<"s_verifications", 'Int'>
    readonly flag: FieldRef<"s_verifications", 'Int'>
    readonly created_at: FieldRef<"s_verifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * s_verifications findUnique
   */
  export type s_verificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_verifications
     */
    select?: s_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_verifications
     */
    omit?: s_verificationsOmit<ExtArgs> | null
    /**
     * Filter, which s_verifications to fetch.
     */
    where: s_verificationsWhereUniqueInput
  }

  /**
   * s_verifications findUniqueOrThrow
   */
  export type s_verificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_verifications
     */
    select?: s_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_verifications
     */
    omit?: s_verificationsOmit<ExtArgs> | null
    /**
     * Filter, which s_verifications to fetch.
     */
    where: s_verificationsWhereUniqueInput
  }

  /**
   * s_verifications findFirst
   */
  export type s_verificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_verifications
     */
    select?: s_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_verifications
     */
    omit?: s_verificationsOmit<ExtArgs> | null
    /**
     * Filter, which s_verifications to fetch.
     */
    where?: s_verificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_verifications to fetch.
     */
    orderBy?: s_verificationsOrderByWithRelationInput | s_verificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_verifications.
     */
    cursor?: s_verificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_verifications.
     */
    distinct?: S_verificationsScalarFieldEnum | S_verificationsScalarFieldEnum[]
  }

  /**
   * s_verifications findFirstOrThrow
   */
  export type s_verificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_verifications
     */
    select?: s_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_verifications
     */
    omit?: s_verificationsOmit<ExtArgs> | null
    /**
     * Filter, which s_verifications to fetch.
     */
    where?: s_verificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_verifications to fetch.
     */
    orderBy?: s_verificationsOrderByWithRelationInput | s_verificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for s_verifications.
     */
    cursor?: s_verificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of s_verifications.
     */
    distinct?: S_verificationsScalarFieldEnum | S_verificationsScalarFieldEnum[]
  }

  /**
   * s_verifications findMany
   */
  export type s_verificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_verifications
     */
    select?: s_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_verifications
     */
    omit?: s_verificationsOmit<ExtArgs> | null
    /**
     * Filter, which s_verifications to fetch.
     */
    where?: s_verificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of s_verifications to fetch.
     */
    orderBy?: s_verificationsOrderByWithRelationInput | s_verificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing s_verifications.
     */
    cursor?: s_verificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` s_verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` s_verifications.
     */
    skip?: number
    distinct?: S_verificationsScalarFieldEnum | S_verificationsScalarFieldEnum[]
  }

  /**
   * s_verifications create
   */
  export type s_verificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_verifications
     */
    select?: s_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_verifications
     */
    omit?: s_verificationsOmit<ExtArgs> | null
    /**
     * The data needed to create a s_verifications.
     */
    data: XOR<s_verificationsCreateInput, s_verificationsUncheckedCreateInput>
  }

  /**
   * s_verifications createMany
   */
  export type s_verificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many s_verifications.
     */
    data: s_verificationsCreateManyInput | s_verificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * s_verifications update
   */
  export type s_verificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_verifications
     */
    select?: s_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_verifications
     */
    omit?: s_verificationsOmit<ExtArgs> | null
    /**
     * The data needed to update a s_verifications.
     */
    data: XOR<s_verificationsUpdateInput, s_verificationsUncheckedUpdateInput>
    /**
     * Choose, which s_verifications to update.
     */
    where: s_verificationsWhereUniqueInput
  }

  /**
   * s_verifications updateMany
   */
  export type s_verificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update s_verifications.
     */
    data: XOR<s_verificationsUpdateManyMutationInput, s_verificationsUncheckedUpdateManyInput>
    /**
     * Filter which s_verifications to update
     */
    where?: s_verificationsWhereInput
    /**
     * Limit how many s_verifications to update.
     */
    limit?: number
  }

  /**
   * s_verifications upsert
   */
  export type s_verificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_verifications
     */
    select?: s_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_verifications
     */
    omit?: s_verificationsOmit<ExtArgs> | null
    /**
     * The filter to search for the s_verifications to update in case it exists.
     */
    where: s_verificationsWhereUniqueInput
    /**
     * In case the s_verifications found by the `where` argument doesn't exist, create a new s_verifications with this data.
     */
    create: XOR<s_verificationsCreateInput, s_verificationsUncheckedCreateInput>
    /**
     * In case the s_verifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<s_verificationsUpdateInput, s_verificationsUncheckedUpdateInput>
  }

  /**
   * s_verifications delete
   */
  export type s_verificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_verifications
     */
    select?: s_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_verifications
     */
    omit?: s_verificationsOmit<ExtArgs> | null
    /**
     * Filter which s_verifications to delete.
     */
    where: s_verificationsWhereUniqueInput
  }

  /**
   * s_verifications deleteMany
   */
  export type s_verificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which s_verifications to delete
     */
    where?: s_verificationsWhereInput
    /**
     * Limit how many s_verifications to delete.
     */
    limit?: number
  }

  /**
   * s_verifications without action
   */
  export type s_verificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the s_verifications
     */
    select?: s_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the s_verifications
     */
    omit?: s_verificationsOmit<ExtArgs> | null
  }


  /**
   * Model sales_history
   */

  export type AggregateSales_history = {
    _count: Sales_historyCountAggregateOutputType | null
    _avg: Sales_historyAvgAggregateOutputType | null
    _sum: Sales_historySumAggregateOutputType | null
    _min: Sales_historyMinAggregateOutputType | null
    _max: Sales_historyMaxAggregateOutputType | null
  }

  export type Sales_historyAvgAggregateOutputType = {
    sale_id: number | null
    buyer_id: number | null
    quantity: number | null
    rfid: number | null
  }

  export type Sales_historySumAggregateOutputType = {
    sale_id: number | null
    buyer_id: number | null
    quantity: number | null
    rfid: bigint | null
  }

  export type Sales_historyMinAggregateOutputType = {
    sale_id: number | null
    buyer_id: number | null
    product_name: string | null
    quantity: number | null
    sale_date: Date | null
    rfid: bigint | null
  }

  export type Sales_historyMaxAggregateOutputType = {
    sale_id: number | null
    buyer_id: number | null
    product_name: string | null
    quantity: number | null
    sale_date: Date | null
    rfid: bigint | null
  }

  export type Sales_historyCountAggregateOutputType = {
    sale_id: number
    buyer_id: number
    product_name: number
    quantity: number
    sale_date: number
    rfid: number
    _all: number
  }


  export type Sales_historyAvgAggregateInputType = {
    sale_id?: true
    buyer_id?: true
    quantity?: true
    rfid?: true
  }

  export type Sales_historySumAggregateInputType = {
    sale_id?: true
    buyer_id?: true
    quantity?: true
    rfid?: true
  }

  export type Sales_historyMinAggregateInputType = {
    sale_id?: true
    buyer_id?: true
    product_name?: true
    quantity?: true
    sale_date?: true
    rfid?: true
  }

  export type Sales_historyMaxAggregateInputType = {
    sale_id?: true
    buyer_id?: true
    product_name?: true
    quantity?: true
    sale_date?: true
    rfid?: true
  }

  export type Sales_historyCountAggregateInputType = {
    sale_id?: true
    buyer_id?: true
    product_name?: true
    quantity?: true
    sale_date?: true
    rfid?: true
    _all?: true
  }

  export type Sales_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sales_history to aggregate.
     */
    where?: sales_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales_histories to fetch.
     */
    orderBy?: sales_historyOrderByWithRelationInput | sales_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sales_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sales_histories
    **/
    _count?: true | Sales_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sales_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sales_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sales_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sales_historyMaxAggregateInputType
  }

  export type GetSales_historyAggregateType<T extends Sales_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateSales_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSales_history[P]>
      : GetScalarType<T[P], AggregateSales_history[P]>
  }




  export type sales_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sales_historyWhereInput
    orderBy?: sales_historyOrderByWithAggregationInput | sales_historyOrderByWithAggregationInput[]
    by: Sales_historyScalarFieldEnum[] | Sales_historyScalarFieldEnum
    having?: sales_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sales_historyCountAggregateInputType | true
    _avg?: Sales_historyAvgAggregateInputType
    _sum?: Sales_historySumAggregateInputType
    _min?: Sales_historyMinAggregateInputType
    _max?: Sales_historyMaxAggregateInputType
  }

  export type Sales_historyGroupByOutputType = {
    sale_id: number
    buyer_id: number | null
    product_name: string
    quantity: number
    sale_date: Date | null
    rfid: bigint | null
    _count: Sales_historyCountAggregateOutputType | null
    _avg: Sales_historyAvgAggregateOutputType | null
    _sum: Sales_historySumAggregateOutputType | null
    _min: Sales_historyMinAggregateOutputType | null
    _max: Sales_historyMaxAggregateOutputType | null
  }

  type GetSales_historyGroupByPayload<T extends sales_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sales_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sales_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sales_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Sales_historyGroupByOutputType[P]>
        }
      >
    >


  export type sales_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sale_id?: boolean
    buyer_id?: boolean
    product_name?: boolean
    quantity?: boolean
    sale_date?: boolean
    rfid?: boolean
  }, ExtArgs["result"]["sales_history"]>



  export type sales_historySelectScalar = {
    sale_id?: boolean
    buyer_id?: boolean
    product_name?: boolean
    quantity?: boolean
    sale_date?: boolean
    rfid?: boolean
  }

  export type sales_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sale_id" | "buyer_id" | "product_name" | "quantity" | "sale_date" | "rfid", ExtArgs["result"]["sales_history"]>

  export type $sales_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sales_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      sale_id: number
      buyer_id: number | null
      product_name: string
      quantity: number
      sale_date: Date | null
      rfid: bigint | null
    }, ExtArgs["result"]["sales_history"]>
    composites: {}
  }

  type sales_historyGetPayload<S extends boolean | null | undefined | sales_historyDefaultArgs> = $Result.GetResult<Prisma.$sales_historyPayload, S>

  type sales_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sales_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sales_historyCountAggregateInputType | true
    }

  export interface sales_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sales_history'], meta: { name: 'sales_history' } }
    /**
     * Find zero or one Sales_history that matches the filter.
     * @param {sales_historyFindUniqueArgs} args - Arguments to find a Sales_history
     * @example
     * // Get one Sales_history
     * const sales_history = await prisma.sales_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sales_historyFindUniqueArgs>(args: SelectSubset<T, sales_historyFindUniqueArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sales_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sales_historyFindUniqueOrThrowArgs} args - Arguments to find a Sales_history
     * @example
     * // Get one Sales_history
     * const sales_history = await prisma.sales_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sales_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, sales_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sales_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_historyFindFirstArgs} args - Arguments to find a Sales_history
     * @example
     * // Get one Sales_history
     * const sales_history = await prisma.sales_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sales_historyFindFirstArgs>(args?: SelectSubset<T, sales_historyFindFirstArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sales_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_historyFindFirstOrThrowArgs} args - Arguments to find a Sales_history
     * @example
     * // Get one Sales_history
     * const sales_history = await prisma.sales_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sales_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, sales_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales_histories
     * const sales_histories = await prisma.sales_history.findMany()
     * 
     * // Get first 10 Sales_histories
     * const sales_histories = await prisma.sales_history.findMany({ take: 10 })
     * 
     * // Only select the `sale_id`
     * const sales_historyWithSale_idOnly = await prisma.sales_history.findMany({ select: { sale_id: true } })
     * 
     */
    findMany<T extends sales_historyFindManyArgs>(args?: SelectSubset<T, sales_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sales_history.
     * @param {sales_historyCreateArgs} args - Arguments to create a Sales_history.
     * @example
     * // Create one Sales_history
     * const Sales_history = await prisma.sales_history.create({
     *   data: {
     *     // ... data to create a Sales_history
     *   }
     * })
     * 
     */
    create<T extends sales_historyCreateArgs>(args: SelectSubset<T, sales_historyCreateArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sales_histories.
     * @param {sales_historyCreateManyArgs} args - Arguments to create many Sales_histories.
     * @example
     * // Create many Sales_histories
     * const sales_history = await prisma.sales_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sales_historyCreateManyArgs>(args?: SelectSubset<T, sales_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sales_history.
     * @param {sales_historyDeleteArgs} args - Arguments to delete one Sales_history.
     * @example
     * // Delete one Sales_history
     * const Sales_history = await prisma.sales_history.delete({
     *   where: {
     *     // ... filter to delete one Sales_history
     *   }
     * })
     * 
     */
    delete<T extends sales_historyDeleteArgs>(args: SelectSubset<T, sales_historyDeleteArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sales_history.
     * @param {sales_historyUpdateArgs} args - Arguments to update one Sales_history.
     * @example
     * // Update one Sales_history
     * const sales_history = await prisma.sales_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sales_historyUpdateArgs>(args: SelectSubset<T, sales_historyUpdateArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sales_histories.
     * @param {sales_historyDeleteManyArgs} args - Arguments to filter Sales_histories to delete.
     * @example
     * // Delete a few Sales_histories
     * const { count } = await prisma.sales_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sales_historyDeleteManyArgs>(args?: SelectSubset<T, sales_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales_histories
     * const sales_history = await prisma.sales_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sales_historyUpdateManyArgs>(args: SelectSubset<T, sales_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sales_history.
     * @param {sales_historyUpsertArgs} args - Arguments to update or create a Sales_history.
     * @example
     * // Update or create a Sales_history
     * const sales_history = await prisma.sales_history.upsert({
     *   create: {
     *     // ... data to create a Sales_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sales_history we want to update
     *   }
     * })
     */
    upsert<T extends sales_historyUpsertArgs>(args: SelectSubset<T, sales_historyUpsertArgs<ExtArgs>>): Prisma__sales_historyClient<$Result.GetResult<Prisma.$sales_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sales_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_historyCountArgs} args - Arguments to filter Sales_histories to count.
     * @example
     * // Count the number of Sales_histories
     * const count = await prisma.sales_history.count({
     *   where: {
     *     // ... the filter for the Sales_histories we want to count
     *   }
     * })
    **/
    count<T extends sales_historyCountArgs>(
      args?: Subset<T, sales_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sales_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sales_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sales_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sales_historyAggregateArgs>(args: Subset<T, Sales_historyAggregateArgs>): Prisma.PrismaPromise<GetSales_historyAggregateType<T>>

    /**
     * Group by Sales_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sales_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sales_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sales_historyGroupByArgs['orderBy'] }
        : { orderBy?: sales_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sales_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSales_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sales_history model
   */
  readonly fields: sales_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sales_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sales_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sales_history model
   */
  interface sales_historyFieldRefs {
    readonly sale_id: FieldRef<"sales_history", 'Int'>
    readonly buyer_id: FieldRef<"sales_history", 'Int'>
    readonly product_name: FieldRef<"sales_history", 'String'>
    readonly quantity: FieldRef<"sales_history", 'Int'>
    readonly sale_date: FieldRef<"sales_history", 'DateTime'>
    readonly rfid: FieldRef<"sales_history", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * sales_history findUnique
   */
  export type sales_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Filter, which sales_history to fetch.
     */
    where: sales_historyWhereUniqueInput
  }

  /**
   * sales_history findUniqueOrThrow
   */
  export type sales_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Filter, which sales_history to fetch.
     */
    where: sales_historyWhereUniqueInput
  }

  /**
   * sales_history findFirst
   */
  export type sales_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Filter, which sales_history to fetch.
     */
    where?: sales_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales_histories to fetch.
     */
    orderBy?: sales_historyOrderByWithRelationInput | sales_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sales_histories.
     */
    cursor?: sales_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sales_histories.
     */
    distinct?: Sales_historyScalarFieldEnum | Sales_historyScalarFieldEnum[]
  }

  /**
   * sales_history findFirstOrThrow
   */
  export type sales_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Filter, which sales_history to fetch.
     */
    where?: sales_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales_histories to fetch.
     */
    orderBy?: sales_historyOrderByWithRelationInput | sales_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sales_histories.
     */
    cursor?: sales_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sales_histories.
     */
    distinct?: Sales_historyScalarFieldEnum | Sales_historyScalarFieldEnum[]
  }

  /**
   * sales_history findMany
   */
  export type sales_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Filter, which sales_histories to fetch.
     */
    where?: sales_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales_histories to fetch.
     */
    orderBy?: sales_historyOrderByWithRelationInput | sales_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sales_histories.
     */
    cursor?: sales_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales_histories.
     */
    skip?: number
    distinct?: Sales_historyScalarFieldEnum | Sales_historyScalarFieldEnum[]
  }

  /**
   * sales_history create
   */
  export type sales_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a sales_history.
     */
    data: XOR<sales_historyCreateInput, sales_historyUncheckedCreateInput>
  }

  /**
   * sales_history createMany
   */
  export type sales_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sales_histories.
     */
    data: sales_historyCreateManyInput | sales_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sales_history update
   */
  export type sales_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a sales_history.
     */
    data: XOR<sales_historyUpdateInput, sales_historyUncheckedUpdateInput>
    /**
     * Choose, which sales_history to update.
     */
    where: sales_historyWhereUniqueInput
  }

  /**
   * sales_history updateMany
   */
  export type sales_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sales_histories.
     */
    data: XOR<sales_historyUpdateManyMutationInput, sales_historyUncheckedUpdateManyInput>
    /**
     * Filter which sales_histories to update
     */
    where?: sales_historyWhereInput
    /**
     * Limit how many sales_histories to update.
     */
    limit?: number
  }

  /**
   * sales_history upsert
   */
  export type sales_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the sales_history to update in case it exists.
     */
    where: sales_historyWhereUniqueInput
    /**
     * In case the sales_history found by the `where` argument doesn't exist, create a new sales_history with this data.
     */
    create: XOR<sales_historyCreateInput, sales_historyUncheckedCreateInput>
    /**
     * In case the sales_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sales_historyUpdateInput, sales_historyUncheckedUpdateInput>
  }

  /**
   * sales_history delete
   */
  export type sales_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
    /**
     * Filter which sales_history to delete.
     */
    where: sales_historyWhereUniqueInput
  }

  /**
   * sales_history deleteMany
   */
  export type sales_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sales_histories to delete
     */
    where?: sales_historyWhereInput
    /**
     * Limit how many sales_histories to delete.
     */
    limit?: number
  }

  /**
   * sales_history without action
   */
  export type sales_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sales_history
     */
    select?: sales_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the sales_history
     */
    omit?: sales_historyOmit<ExtArgs> | null
  }


  /**
   * Model schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleAvgAggregateOutputType = {
    id: number | null
  }

  export type ScheduleSumAggregateOutputType = {
    id: number | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: number | null
    title: string | null
    start: Date | null
    end: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: number | null
    title: string | null
    start: Date | null
    end: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    title: number
    start: number
    end: number
    _all: number
  }


  export type ScheduleAvgAggregateInputType = {
    id?: true
  }

  export type ScheduleSumAggregateInputType = {
    id?: true
  }

  export type ScheduleMinAggregateInputType = {
    id?: true
    title?: true
    start?: true
    end?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    title?: true
    start?: true
    end?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    title?: true
    start?: true
    end?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schedule to aggregate.
     */
    where?: scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schedules to fetch.
     */
    orderBy?: scheduleOrderByWithRelationInput | scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type scheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: scheduleWhereInput
    orderBy?: scheduleOrderByWithAggregationInput | scheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: scheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _avg?: ScheduleAvgAggregateInputType
    _sum?: ScheduleSumAggregateInputType
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: number
    title: string
    start: Date
    end: Date | null
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends scheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type scheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    start?: boolean
    end?: boolean
  }, ExtArgs["result"]["schedule"]>



  export type scheduleSelectScalar = {
    id?: boolean
    title?: boolean
    start?: boolean
    end?: boolean
  }

  export type scheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "start" | "end", ExtArgs["result"]["schedule"]>

  export type $schedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "schedule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      start: Date
      end: Date | null
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type scheduleGetPayload<S extends boolean | null | undefined | scheduleDefaultArgs> = $Result.GetResult<Prisma.$schedulePayload, S>

  type scheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<scheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface scheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['schedule'], meta: { name: 'schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {scheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends scheduleFindUniqueArgs>(args: SelectSubset<T, scheduleFindUniqueArgs<ExtArgs>>): Prisma__scheduleClient<$Result.GetResult<Prisma.$schedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {scheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends scheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, scheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__scheduleClient<$Result.GetResult<Prisma.$schedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends scheduleFindFirstArgs>(args?: SelectSubset<T, scheduleFindFirstArgs<ExtArgs>>): Prisma__scheduleClient<$Result.GetResult<Prisma.$schedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends scheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, scheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__scheduleClient<$Result.GetResult<Prisma.$schedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends scheduleFindManyArgs>(args?: SelectSubset<T, scheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {scheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends scheduleCreateArgs>(args: SelectSubset<T, scheduleCreateArgs<ExtArgs>>): Prisma__scheduleClient<$Result.GetResult<Prisma.$schedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {scheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends scheduleCreateManyArgs>(args?: SelectSubset<T, scheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Schedule.
     * @param {scheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends scheduleDeleteArgs>(args: SelectSubset<T, scheduleDeleteArgs<ExtArgs>>): Prisma__scheduleClient<$Result.GetResult<Prisma.$schedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {scheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends scheduleUpdateArgs>(args: SelectSubset<T, scheduleUpdateArgs<ExtArgs>>): Prisma__scheduleClient<$Result.GetResult<Prisma.$schedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {scheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends scheduleDeleteManyArgs>(args?: SelectSubset<T, scheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends scheduleUpdateManyArgs>(args: SelectSubset<T, scheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Schedule.
     * @param {scheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends scheduleUpsertArgs>(args: SelectSubset<T, scheduleUpsertArgs<ExtArgs>>): Prisma__scheduleClient<$Result.GetResult<Prisma.$schedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends scheduleCountArgs>(
      args?: Subset<T, scheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends scheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: scheduleGroupByArgs['orderBy'] }
        : { orderBy?: scheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, scheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the schedule model
   */
  readonly fields: scheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__scheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the schedule model
   */
  interface scheduleFieldRefs {
    readonly id: FieldRef<"schedule", 'Int'>
    readonly title: FieldRef<"schedule", 'String'>
    readonly start: FieldRef<"schedule", 'DateTime'>
    readonly end: FieldRef<"schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * schedule findUnique
   */
  export type scheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schedule
     */
    select?: scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schedule
     */
    omit?: scheduleOmit<ExtArgs> | null
    /**
     * Filter, which schedule to fetch.
     */
    where: scheduleWhereUniqueInput
  }

  /**
   * schedule findUniqueOrThrow
   */
  export type scheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schedule
     */
    select?: scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schedule
     */
    omit?: scheduleOmit<ExtArgs> | null
    /**
     * Filter, which schedule to fetch.
     */
    where: scheduleWhereUniqueInput
  }

  /**
   * schedule findFirst
   */
  export type scheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schedule
     */
    select?: scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schedule
     */
    omit?: scheduleOmit<ExtArgs> | null
    /**
     * Filter, which schedule to fetch.
     */
    where?: scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schedules to fetch.
     */
    orderBy?: scheduleOrderByWithRelationInput | scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schedules.
     */
    cursor?: scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * schedule findFirstOrThrow
   */
  export type scheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schedule
     */
    select?: scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schedule
     */
    omit?: scheduleOmit<ExtArgs> | null
    /**
     * Filter, which schedule to fetch.
     */
    where?: scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schedules to fetch.
     */
    orderBy?: scheduleOrderByWithRelationInput | scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schedules.
     */
    cursor?: scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * schedule findMany
   */
  export type scheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schedule
     */
    select?: scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schedule
     */
    omit?: scheduleOmit<ExtArgs> | null
    /**
     * Filter, which schedules to fetch.
     */
    where?: scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schedules to fetch.
     */
    orderBy?: scheduleOrderByWithRelationInput | scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing schedules.
     */
    cursor?: scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * schedule create
   */
  export type scheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schedule
     */
    select?: scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schedule
     */
    omit?: scheduleOmit<ExtArgs> | null
    /**
     * The data needed to create a schedule.
     */
    data: XOR<scheduleCreateInput, scheduleUncheckedCreateInput>
  }

  /**
   * schedule createMany
   */
  export type scheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many schedules.
     */
    data: scheduleCreateManyInput | scheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schedule update
   */
  export type scheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schedule
     */
    select?: scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schedule
     */
    omit?: scheduleOmit<ExtArgs> | null
    /**
     * The data needed to update a schedule.
     */
    data: XOR<scheduleUpdateInput, scheduleUncheckedUpdateInput>
    /**
     * Choose, which schedule to update.
     */
    where: scheduleWhereUniqueInput
  }

  /**
   * schedule updateMany
   */
  export type scheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update schedules.
     */
    data: XOR<scheduleUpdateManyMutationInput, scheduleUncheckedUpdateManyInput>
    /**
     * Filter which schedules to update
     */
    where?: scheduleWhereInput
    /**
     * Limit how many schedules to update.
     */
    limit?: number
  }

  /**
   * schedule upsert
   */
  export type scheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schedule
     */
    select?: scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schedule
     */
    omit?: scheduleOmit<ExtArgs> | null
    /**
     * The filter to search for the schedule to update in case it exists.
     */
    where: scheduleWhereUniqueInput
    /**
     * In case the schedule found by the `where` argument doesn't exist, create a new schedule with this data.
     */
    create: XOR<scheduleCreateInput, scheduleUncheckedCreateInput>
    /**
     * In case the schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<scheduleUpdateInput, scheduleUncheckedUpdateInput>
  }

  /**
   * schedule delete
   */
  export type scheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schedule
     */
    select?: scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schedule
     */
    omit?: scheduleOmit<ExtArgs> | null
    /**
     * Filter which schedule to delete.
     */
    where: scheduleWhereUniqueInput
  }

  /**
   * schedule deleteMany
   */
  export type scheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schedules to delete
     */
    where?: scheduleWhereInput
    /**
     * Limit how many schedules to delete.
     */
    limit?: number
  }

  /**
   * schedule without action
   */
  export type scheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schedule
     */
    select?: scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schedule
     */
    omit?: scheduleOmit<ExtArgs> | null
  }


  /**
   * Model studentdetails
   */

  export type AggregateStudentdetails = {
    _count: StudentdetailsCountAggregateOutputType | null
    _avg: StudentdetailsAvgAggregateOutputType | null
    _sum: StudentdetailsSumAggregateOutputType | null
    _min: StudentdetailsMinAggregateOutputType | null
    _max: StudentdetailsMaxAggregateOutputType | null
  }

  export type StudentdetailsAvgAggregateOutputType = {
    id: number | null
  }

  export type StudentdetailsSumAggregateOutputType = {
    id: number | null
  }

  export type StudentdetailsMinAggregateOutputType = {
    id: number | null
    uniqid: string | null
    visa: string | null
    father: string | null
    fathermail: string | null
    fathernumber: string | null
    fatherwork: string | null
    fcompany: string | null
    fsalary: string | null
    mother: string | null
    mothermail: string | null
    mothernumber: string | null
    motherwork: string | null
    mcompany: string | null
    msalary: string | null
    street: string | null
    barangay: string | null
    city: string | null
    postal: string | null
    englishrw: string | null
    englishv: string | null
    languages: string | null
    advclasses: string | null
    remedial: string | null
    skill: string | null
    ashtma: string | null
    ashtmar: string | null
    allergy: string | null
    allergyr: string | null
    drug: string | null
    drugr: string | null
    speech: string | null
    speechr: string | null
    vision: string | null
    visionr: string | null
    hearing: string | null
    hearingr: string | null
    adhd: string | null
    adhdr: string | null
    healthcond: string | null
    hospitalization: string | null
    injuries: string | null
    medication: string | null
    general: string | null
    generaldets: string | null
    psych: string | null
    psychdets: string | null
    minor: string | null
    emergency: string | null
    hospital: string | null
    otc: string | null
    conforme: string | null
    conformedate: string | null
  }

  export type StudentdetailsMaxAggregateOutputType = {
    id: number | null
    uniqid: string | null
    visa: string | null
    father: string | null
    fathermail: string | null
    fathernumber: string | null
    fatherwork: string | null
    fcompany: string | null
    fsalary: string | null
    mother: string | null
    mothermail: string | null
    mothernumber: string | null
    motherwork: string | null
    mcompany: string | null
    msalary: string | null
    street: string | null
    barangay: string | null
    city: string | null
    postal: string | null
    englishrw: string | null
    englishv: string | null
    languages: string | null
    advclasses: string | null
    remedial: string | null
    skill: string | null
    ashtma: string | null
    ashtmar: string | null
    allergy: string | null
    allergyr: string | null
    drug: string | null
    drugr: string | null
    speech: string | null
    speechr: string | null
    vision: string | null
    visionr: string | null
    hearing: string | null
    hearingr: string | null
    adhd: string | null
    adhdr: string | null
    healthcond: string | null
    hospitalization: string | null
    injuries: string | null
    medication: string | null
    general: string | null
    generaldets: string | null
    psych: string | null
    psychdets: string | null
    minor: string | null
    emergency: string | null
    hospital: string | null
    otc: string | null
    conforme: string | null
    conformedate: string | null
  }

  export type StudentdetailsCountAggregateOutputType = {
    id: number
    uniqid: number
    visa: number
    father: number
    fathermail: number
    fathernumber: number
    fatherwork: number
    fcompany: number
    fsalary: number
    mother: number
    mothermail: number
    mothernumber: number
    motherwork: number
    mcompany: number
    msalary: number
    street: number
    barangay: number
    city: number
    postal: number
    englishrw: number
    englishv: number
    languages: number
    advclasses: number
    remedial: number
    skill: number
    ashtma: number
    ashtmar: number
    allergy: number
    allergyr: number
    drug: number
    drugr: number
    speech: number
    speechr: number
    vision: number
    visionr: number
    hearing: number
    hearingr: number
    adhd: number
    adhdr: number
    healthcond: number
    hospitalization: number
    injuries: number
    medication: number
    general: number
    generaldets: number
    psych: number
    psychdets: number
    minor: number
    emergency: number
    hospital: number
    otc: number
    conforme: number
    conformedate: number
    _all: number
  }


  export type StudentdetailsAvgAggregateInputType = {
    id?: true
  }

  export type StudentdetailsSumAggregateInputType = {
    id?: true
  }

  export type StudentdetailsMinAggregateInputType = {
    id?: true
    uniqid?: true
    visa?: true
    father?: true
    fathermail?: true
    fathernumber?: true
    fatherwork?: true
    fcompany?: true
    fsalary?: true
    mother?: true
    mothermail?: true
    mothernumber?: true
    motherwork?: true
    mcompany?: true
    msalary?: true
    street?: true
    barangay?: true
    city?: true
    postal?: true
    englishrw?: true
    englishv?: true
    languages?: true
    advclasses?: true
    remedial?: true
    skill?: true
    ashtma?: true
    ashtmar?: true
    allergy?: true
    allergyr?: true
    drug?: true
    drugr?: true
    speech?: true
    speechr?: true
    vision?: true
    visionr?: true
    hearing?: true
    hearingr?: true
    adhd?: true
    adhdr?: true
    healthcond?: true
    hospitalization?: true
    injuries?: true
    medication?: true
    general?: true
    generaldets?: true
    psych?: true
    psychdets?: true
    minor?: true
    emergency?: true
    hospital?: true
    otc?: true
    conforme?: true
    conformedate?: true
  }

  export type StudentdetailsMaxAggregateInputType = {
    id?: true
    uniqid?: true
    visa?: true
    father?: true
    fathermail?: true
    fathernumber?: true
    fatherwork?: true
    fcompany?: true
    fsalary?: true
    mother?: true
    mothermail?: true
    mothernumber?: true
    motherwork?: true
    mcompany?: true
    msalary?: true
    street?: true
    barangay?: true
    city?: true
    postal?: true
    englishrw?: true
    englishv?: true
    languages?: true
    advclasses?: true
    remedial?: true
    skill?: true
    ashtma?: true
    ashtmar?: true
    allergy?: true
    allergyr?: true
    drug?: true
    drugr?: true
    speech?: true
    speechr?: true
    vision?: true
    visionr?: true
    hearing?: true
    hearingr?: true
    adhd?: true
    adhdr?: true
    healthcond?: true
    hospitalization?: true
    injuries?: true
    medication?: true
    general?: true
    generaldets?: true
    psych?: true
    psychdets?: true
    minor?: true
    emergency?: true
    hospital?: true
    otc?: true
    conforme?: true
    conformedate?: true
  }

  export type StudentdetailsCountAggregateInputType = {
    id?: true
    uniqid?: true
    visa?: true
    father?: true
    fathermail?: true
    fathernumber?: true
    fatherwork?: true
    fcompany?: true
    fsalary?: true
    mother?: true
    mothermail?: true
    mothernumber?: true
    motherwork?: true
    mcompany?: true
    msalary?: true
    street?: true
    barangay?: true
    city?: true
    postal?: true
    englishrw?: true
    englishv?: true
    languages?: true
    advclasses?: true
    remedial?: true
    skill?: true
    ashtma?: true
    ashtmar?: true
    allergy?: true
    allergyr?: true
    drug?: true
    drugr?: true
    speech?: true
    speechr?: true
    vision?: true
    visionr?: true
    hearing?: true
    hearingr?: true
    adhd?: true
    adhdr?: true
    healthcond?: true
    hospitalization?: true
    injuries?: true
    medication?: true
    general?: true
    generaldets?: true
    psych?: true
    psychdets?: true
    minor?: true
    emergency?: true
    hospital?: true
    otc?: true
    conforme?: true
    conformedate?: true
    _all?: true
  }

  export type StudentdetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which studentdetails to aggregate.
     */
    where?: studentdetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentdetails to fetch.
     */
    orderBy?: studentdetailsOrderByWithRelationInput | studentdetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentdetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentdetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentdetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned studentdetails
    **/
    _count?: true | StudentdetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentdetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentdetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentdetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentdetailsMaxAggregateInputType
  }

  export type GetStudentdetailsAggregateType<T extends StudentdetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentdetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentdetails[P]>
      : GetScalarType<T[P], AggregateStudentdetails[P]>
  }




  export type studentdetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentdetailsWhereInput
    orderBy?: studentdetailsOrderByWithAggregationInput | studentdetailsOrderByWithAggregationInput[]
    by: StudentdetailsScalarFieldEnum[] | StudentdetailsScalarFieldEnum
    having?: studentdetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentdetailsCountAggregateInputType | true
    _avg?: StudentdetailsAvgAggregateInputType
    _sum?: StudentdetailsSumAggregateInputType
    _min?: StudentdetailsMinAggregateInputType
    _max?: StudentdetailsMaxAggregateInputType
  }

  export type StudentdetailsGroupByOutputType = {
    id: number
    uniqid: string
    visa: string
    father: string
    fathermail: string
    fathernumber: string
    fatherwork: string
    fcompany: string
    fsalary: string
    mother: string
    mothermail: string
    mothernumber: string
    motherwork: string
    mcompany: string
    msalary: string
    street: string
    barangay: string
    city: string
    postal: string
    englishrw: string
    englishv: string
    languages: string
    advclasses: string
    remedial: string
    skill: string
    ashtma: string
    ashtmar: string
    allergy: string
    allergyr: string
    drug: string
    drugr: string
    speech: string
    speechr: string
    vision: string
    visionr: string
    hearing: string
    hearingr: string
    adhd: string
    adhdr: string
    healthcond: string
    hospitalization: string
    injuries: string
    medication: string
    general: string
    generaldets: string
    psych: string
    psychdets: string
    minor: string
    emergency: string
    hospital: string
    otc: string
    conforme: string
    conformedate: string
    _count: StudentdetailsCountAggregateOutputType | null
    _avg: StudentdetailsAvgAggregateOutputType | null
    _sum: StudentdetailsSumAggregateOutputType | null
    _min: StudentdetailsMinAggregateOutputType | null
    _max: StudentdetailsMaxAggregateOutputType | null
  }

  type GetStudentdetailsGroupByPayload<T extends studentdetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentdetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentdetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentdetailsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentdetailsGroupByOutputType[P]>
        }
      >
    >


  export type studentdetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uniqid?: boolean
    visa?: boolean
    father?: boolean
    fathermail?: boolean
    fathernumber?: boolean
    fatherwork?: boolean
    fcompany?: boolean
    fsalary?: boolean
    mother?: boolean
    mothermail?: boolean
    mothernumber?: boolean
    motherwork?: boolean
    mcompany?: boolean
    msalary?: boolean
    street?: boolean
    barangay?: boolean
    city?: boolean
    postal?: boolean
    englishrw?: boolean
    englishv?: boolean
    languages?: boolean
    advclasses?: boolean
    remedial?: boolean
    skill?: boolean
    ashtma?: boolean
    ashtmar?: boolean
    allergy?: boolean
    allergyr?: boolean
    drug?: boolean
    drugr?: boolean
    speech?: boolean
    speechr?: boolean
    vision?: boolean
    visionr?: boolean
    hearing?: boolean
    hearingr?: boolean
    adhd?: boolean
    adhdr?: boolean
    healthcond?: boolean
    hospitalization?: boolean
    injuries?: boolean
    medication?: boolean
    general?: boolean
    generaldets?: boolean
    psych?: boolean
    psychdets?: boolean
    minor?: boolean
    emergency?: boolean
    hospital?: boolean
    otc?: boolean
    conforme?: boolean
    conformedate?: boolean
  }, ExtArgs["result"]["studentdetails"]>



  export type studentdetailsSelectScalar = {
    id?: boolean
    uniqid?: boolean
    visa?: boolean
    father?: boolean
    fathermail?: boolean
    fathernumber?: boolean
    fatherwork?: boolean
    fcompany?: boolean
    fsalary?: boolean
    mother?: boolean
    mothermail?: boolean
    mothernumber?: boolean
    motherwork?: boolean
    mcompany?: boolean
    msalary?: boolean
    street?: boolean
    barangay?: boolean
    city?: boolean
    postal?: boolean
    englishrw?: boolean
    englishv?: boolean
    languages?: boolean
    advclasses?: boolean
    remedial?: boolean
    skill?: boolean
    ashtma?: boolean
    ashtmar?: boolean
    allergy?: boolean
    allergyr?: boolean
    drug?: boolean
    drugr?: boolean
    speech?: boolean
    speechr?: boolean
    vision?: boolean
    visionr?: boolean
    hearing?: boolean
    hearingr?: boolean
    adhd?: boolean
    adhdr?: boolean
    healthcond?: boolean
    hospitalization?: boolean
    injuries?: boolean
    medication?: boolean
    general?: boolean
    generaldets?: boolean
    psych?: boolean
    psychdets?: boolean
    minor?: boolean
    emergency?: boolean
    hospital?: boolean
    otc?: boolean
    conforme?: boolean
    conformedate?: boolean
  }

  export type studentdetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uniqid" | "visa" | "father" | "fathermail" | "fathernumber" | "fatherwork" | "fcompany" | "fsalary" | "mother" | "mothermail" | "mothernumber" | "motherwork" | "mcompany" | "msalary" | "street" | "barangay" | "city" | "postal" | "englishrw" | "englishv" | "languages" | "advclasses" | "remedial" | "skill" | "ashtma" | "ashtmar" | "allergy" | "allergyr" | "drug" | "drugr" | "speech" | "speechr" | "vision" | "visionr" | "hearing" | "hearingr" | "adhd" | "adhdr" | "healthcond" | "hospitalization" | "injuries" | "medication" | "general" | "generaldets" | "psych" | "psychdets" | "minor" | "emergency" | "hospital" | "otc" | "conforme" | "conformedate", ExtArgs["result"]["studentdetails"]>

  export type $studentdetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "studentdetails"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uniqid: string
      visa: string
      father: string
      fathermail: string
      fathernumber: string
      fatherwork: string
      fcompany: string
      fsalary: string
      mother: string
      mothermail: string
      mothernumber: string
      motherwork: string
      mcompany: string
      msalary: string
      street: string
      barangay: string
      city: string
      postal: string
      englishrw: string
      englishv: string
      languages: string
      advclasses: string
      remedial: string
      skill: string
      ashtma: string
      ashtmar: string
      allergy: string
      allergyr: string
      drug: string
      drugr: string
      speech: string
      speechr: string
      vision: string
      visionr: string
      hearing: string
      hearingr: string
      adhd: string
      adhdr: string
      healthcond: string
      hospitalization: string
      injuries: string
      medication: string
      general: string
      generaldets: string
      psych: string
      psychdets: string
      minor: string
      emergency: string
      hospital: string
      otc: string
      conforme: string
      conformedate: string
    }, ExtArgs["result"]["studentdetails"]>
    composites: {}
  }

  type studentdetailsGetPayload<S extends boolean | null | undefined | studentdetailsDefaultArgs> = $Result.GetResult<Prisma.$studentdetailsPayload, S>

  type studentdetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<studentdetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentdetailsCountAggregateInputType | true
    }

  export interface studentdetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['studentdetails'], meta: { name: 'studentdetails' } }
    /**
     * Find zero or one Studentdetails that matches the filter.
     * @param {studentdetailsFindUniqueArgs} args - Arguments to find a Studentdetails
     * @example
     * // Get one Studentdetails
     * const studentdetails = await prisma.studentdetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentdetailsFindUniqueArgs>(args: SelectSubset<T, studentdetailsFindUniqueArgs<ExtArgs>>): Prisma__studentdetailsClient<$Result.GetResult<Prisma.$studentdetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Studentdetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {studentdetailsFindUniqueOrThrowArgs} args - Arguments to find a Studentdetails
     * @example
     * // Get one Studentdetails
     * const studentdetails = await prisma.studentdetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentdetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, studentdetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentdetailsClient<$Result.GetResult<Prisma.$studentdetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Studentdetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentdetailsFindFirstArgs} args - Arguments to find a Studentdetails
     * @example
     * // Get one Studentdetails
     * const studentdetails = await prisma.studentdetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentdetailsFindFirstArgs>(args?: SelectSubset<T, studentdetailsFindFirstArgs<ExtArgs>>): Prisma__studentdetailsClient<$Result.GetResult<Prisma.$studentdetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Studentdetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentdetailsFindFirstOrThrowArgs} args - Arguments to find a Studentdetails
     * @example
     * // Get one Studentdetails
     * const studentdetails = await prisma.studentdetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentdetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, studentdetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentdetailsClient<$Result.GetResult<Prisma.$studentdetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Studentdetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentdetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Studentdetails
     * const studentdetails = await prisma.studentdetails.findMany()
     * 
     * // Get first 10 Studentdetails
     * const studentdetails = await prisma.studentdetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentdetailsWithIdOnly = await prisma.studentdetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends studentdetailsFindManyArgs>(args?: SelectSubset<T, studentdetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentdetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Studentdetails.
     * @param {studentdetailsCreateArgs} args - Arguments to create a Studentdetails.
     * @example
     * // Create one Studentdetails
     * const Studentdetails = await prisma.studentdetails.create({
     *   data: {
     *     // ... data to create a Studentdetails
     *   }
     * })
     * 
     */
    create<T extends studentdetailsCreateArgs>(args: SelectSubset<T, studentdetailsCreateArgs<ExtArgs>>): Prisma__studentdetailsClient<$Result.GetResult<Prisma.$studentdetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Studentdetails.
     * @param {studentdetailsCreateManyArgs} args - Arguments to create many Studentdetails.
     * @example
     * // Create many Studentdetails
     * const studentdetails = await prisma.studentdetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentdetailsCreateManyArgs>(args?: SelectSubset<T, studentdetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Studentdetails.
     * @param {studentdetailsDeleteArgs} args - Arguments to delete one Studentdetails.
     * @example
     * // Delete one Studentdetails
     * const Studentdetails = await prisma.studentdetails.delete({
     *   where: {
     *     // ... filter to delete one Studentdetails
     *   }
     * })
     * 
     */
    delete<T extends studentdetailsDeleteArgs>(args: SelectSubset<T, studentdetailsDeleteArgs<ExtArgs>>): Prisma__studentdetailsClient<$Result.GetResult<Prisma.$studentdetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Studentdetails.
     * @param {studentdetailsUpdateArgs} args - Arguments to update one Studentdetails.
     * @example
     * // Update one Studentdetails
     * const studentdetails = await prisma.studentdetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentdetailsUpdateArgs>(args: SelectSubset<T, studentdetailsUpdateArgs<ExtArgs>>): Prisma__studentdetailsClient<$Result.GetResult<Prisma.$studentdetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Studentdetails.
     * @param {studentdetailsDeleteManyArgs} args - Arguments to filter Studentdetails to delete.
     * @example
     * // Delete a few Studentdetails
     * const { count } = await prisma.studentdetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentdetailsDeleteManyArgs>(args?: SelectSubset<T, studentdetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Studentdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentdetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Studentdetails
     * const studentdetails = await prisma.studentdetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentdetailsUpdateManyArgs>(args: SelectSubset<T, studentdetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Studentdetails.
     * @param {studentdetailsUpsertArgs} args - Arguments to update or create a Studentdetails.
     * @example
     * // Update or create a Studentdetails
     * const studentdetails = await prisma.studentdetails.upsert({
     *   create: {
     *     // ... data to create a Studentdetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Studentdetails we want to update
     *   }
     * })
     */
    upsert<T extends studentdetailsUpsertArgs>(args: SelectSubset<T, studentdetailsUpsertArgs<ExtArgs>>): Prisma__studentdetailsClient<$Result.GetResult<Prisma.$studentdetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Studentdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentdetailsCountArgs} args - Arguments to filter Studentdetails to count.
     * @example
     * // Count the number of Studentdetails
     * const count = await prisma.studentdetails.count({
     *   where: {
     *     // ... the filter for the Studentdetails we want to count
     *   }
     * })
    **/
    count<T extends studentdetailsCountArgs>(
      args?: Subset<T, studentdetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentdetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Studentdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentdetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentdetailsAggregateArgs>(args: Subset<T, StudentdetailsAggregateArgs>): Prisma.PrismaPromise<GetStudentdetailsAggregateType<T>>

    /**
     * Group by Studentdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentdetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentdetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentdetailsGroupByArgs['orderBy'] }
        : { orderBy?: studentdetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentdetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentdetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the studentdetails model
   */
  readonly fields: studentdetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for studentdetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentdetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the studentdetails model
   */
  interface studentdetailsFieldRefs {
    readonly id: FieldRef<"studentdetails", 'Int'>
    readonly uniqid: FieldRef<"studentdetails", 'String'>
    readonly visa: FieldRef<"studentdetails", 'String'>
    readonly father: FieldRef<"studentdetails", 'String'>
    readonly fathermail: FieldRef<"studentdetails", 'String'>
    readonly fathernumber: FieldRef<"studentdetails", 'String'>
    readonly fatherwork: FieldRef<"studentdetails", 'String'>
    readonly fcompany: FieldRef<"studentdetails", 'String'>
    readonly fsalary: FieldRef<"studentdetails", 'String'>
    readonly mother: FieldRef<"studentdetails", 'String'>
    readonly mothermail: FieldRef<"studentdetails", 'String'>
    readonly mothernumber: FieldRef<"studentdetails", 'String'>
    readonly motherwork: FieldRef<"studentdetails", 'String'>
    readonly mcompany: FieldRef<"studentdetails", 'String'>
    readonly msalary: FieldRef<"studentdetails", 'String'>
    readonly street: FieldRef<"studentdetails", 'String'>
    readonly barangay: FieldRef<"studentdetails", 'String'>
    readonly city: FieldRef<"studentdetails", 'String'>
    readonly postal: FieldRef<"studentdetails", 'String'>
    readonly englishrw: FieldRef<"studentdetails", 'String'>
    readonly englishv: FieldRef<"studentdetails", 'String'>
    readonly languages: FieldRef<"studentdetails", 'String'>
    readonly advclasses: FieldRef<"studentdetails", 'String'>
    readonly remedial: FieldRef<"studentdetails", 'String'>
    readonly skill: FieldRef<"studentdetails", 'String'>
    readonly ashtma: FieldRef<"studentdetails", 'String'>
    readonly ashtmar: FieldRef<"studentdetails", 'String'>
    readonly allergy: FieldRef<"studentdetails", 'String'>
    readonly allergyr: FieldRef<"studentdetails", 'String'>
    readonly drug: FieldRef<"studentdetails", 'String'>
    readonly drugr: FieldRef<"studentdetails", 'String'>
    readonly speech: FieldRef<"studentdetails", 'String'>
    readonly speechr: FieldRef<"studentdetails", 'String'>
    readonly vision: FieldRef<"studentdetails", 'String'>
    readonly visionr: FieldRef<"studentdetails", 'String'>
    readonly hearing: FieldRef<"studentdetails", 'String'>
    readonly hearingr: FieldRef<"studentdetails", 'String'>
    readonly adhd: FieldRef<"studentdetails", 'String'>
    readonly adhdr: FieldRef<"studentdetails", 'String'>
    readonly healthcond: FieldRef<"studentdetails", 'String'>
    readonly hospitalization: FieldRef<"studentdetails", 'String'>
    readonly injuries: FieldRef<"studentdetails", 'String'>
    readonly medication: FieldRef<"studentdetails", 'String'>
    readonly general: FieldRef<"studentdetails", 'String'>
    readonly generaldets: FieldRef<"studentdetails", 'String'>
    readonly psych: FieldRef<"studentdetails", 'String'>
    readonly psychdets: FieldRef<"studentdetails", 'String'>
    readonly minor: FieldRef<"studentdetails", 'String'>
    readonly emergency: FieldRef<"studentdetails", 'String'>
    readonly hospital: FieldRef<"studentdetails", 'String'>
    readonly otc: FieldRef<"studentdetails", 'String'>
    readonly conforme: FieldRef<"studentdetails", 'String'>
    readonly conformedate: FieldRef<"studentdetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * studentdetails findUnique
   */
  export type studentdetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentdetails
     */
    select?: studentdetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentdetails
     */
    omit?: studentdetailsOmit<ExtArgs> | null
    /**
     * Filter, which studentdetails to fetch.
     */
    where: studentdetailsWhereUniqueInput
  }

  /**
   * studentdetails findUniqueOrThrow
   */
  export type studentdetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentdetails
     */
    select?: studentdetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentdetails
     */
    omit?: studentdetailsOmit<ExtArgs> | null
    /**
     * Filter, which studentdetails to fetch.
     */
    where: studentdetailsWhereUniqueInput
  }

  /**
   * studentdetails findFirst
   */
  export type studentdetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentdetails
     */
    select?: studentdetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentdetails
     */
    omit?: studentdetailsOmit<ExtArgs> | null
    /**
     * Filter, which studentdetails to fetch.
     */
    where?: studentdetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentdetails to fetch.
     */
    orderBy?: studentdetailsOrderByWithRelationInput | studentdetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for studentdetails.
     */
    cursor?: studentdetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentdetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentdetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of studentdetails.
     */
    distinct?: StudentdetailsScalarFieldEnum | StudentdetailsScalarFieldEnum[]
  }

  /**
   * studentdetails findFirstOrThrow
   */
  export type studentdetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentdetails
     */
    select?: studentdetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentdetails
     */
    omit?: studentdetailsOmit<ExtArgs> | null
    /**
     * Filter, which studentdetails to fetch.
     */
    where?: studentdetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentdetails to fetch.
     */
    orderBy?: studentdetailsOrderByWithRelationInput | studentdetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for studentdetails.
     */
    cursor?: studentdetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentdetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentdetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of studentdetails.
     */
    distinct?: StudentdetailsScalarFieldEnum | StudentdetailsScalarFieldEnum[]
  }

  /**
   * studentdetails findMany
   */
  export type studentdetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentdetails
     */
    select?: studentdetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentdetails
     */
    omit?: studentdetailsOmit<ExtArgs> | null
    /**
     * Filter, which studentdetails to fetch.
     */
    where?: studentdetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentdetails to fetch.
     */
    orderBy?: studentdetailsOrderByWithRelationInput | studentdetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing studentdetails.
     */
    cursor?: studentdetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentdetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentdetails.
     */
    skip?: number
    distinct?: StudentdetailsScalarFieldEnum | StudentdetailsScalarFieldEnum[]
  }

  /**
   * studentdetails create
   */
  export type studentdetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentdetails
     */
    select?: studentdetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentdetails
     */
    omit?: studentdetailsOmit<ExtArgs> | null
    /**
     * The data needed to create a studentdetails.
     */
    data: XOR<studentdetailsCreateInput, studentdetailsUncheckedCreateInput>
  }

  /**
   * studentdetails createMany
   */
  export type studentdetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many studentdetails.
     */
    data: studentdetailsCreateManyInput | studentdetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * studentdetails update
   */
  export type studentdetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentdetails
     */
    select?: studentdetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentdetails
     */
    omit?: studentdetailsOmit<ExtArgs> | null
    /**
     * The data needed to update a studentdetails.
     */
    data: XOR<studentdetailsUpdateInput, studentdetailsUncheckedUpdateInput>
    /**
     * Choose, which studentdetails to update.
     */
    where: studentdetailsWhereUniqueInput
  }

  /**
   * studentdetails updateMany
   */
  export type studentdetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update studentdetails.
     */
    data: XOR<studentdetailsUpdateManyMutationInput, studentdetailsUncheckedUpdateManyInput>
    /**
     * Filter which studentdetails to update
     */
    where?: studentdetailsWhereInput
    /**
     * Limit how many studentdetails to update.
     */
    limit?: number
  }

  /**
   * studentdetails upsert
   */
  export type studentdetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentdetails
     */
    select?: studentdetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentdetails
     */
    omit?: studentdetailsOmit<ExtArgs> | null
    /**
     * The filter to search for the studentdetails to update in case it exists.
     */
    where: studentdetailsWhereUniqueInput
    /**
     * In case the studentdetails found by the `where` argument doesn't exist, create a new studentdetails with this data.
     */
    create: XOR<studentdetailsCreateInput, studentdetailsUncheckedCreateInput>
    /**
     * In case the studentdetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentdetailsUpdateInput, studentdetailsUncheckedUpdateInput>
  }

  /**
   * studentdetails delete
   */
  export type studentdetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentdetails
     */
    select?: studentdetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentdetails
     */
    omit?: studentdetailsOmit<ExtArgs> | null
    /**
     * Filter which studentdetails to delete.
     */
    where: studentdetailsWhereUniqueInput
  }

  /**
   * studentdetails deleteMany
   */
  export type studentdetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which studentdetails to delete
     */
    where?: studentdetailsWhereInput
    /**
     * Limit how many studentdetails to delete.
     */
    limit?: number
  }

  /**
   * studentdetails without action
   */
  export type studentdetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentdetails
     */
    select?: studentdetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the studentdetails
     */
    omit?: studentdetailsOmit<ExtArgs> | null
  }


  /**
   * Model timeoff
   */

  export type AggregateTimeoff = {
    _count: TimeoffCountAggregateOutputType | null
    _avg: TimeoffAvgAggregateOutputType | null
    _sum: TimeoffSumAggregateOutputType | null
    _min: TimeoffMinAggregateOutputType | null
    _max: TimeoffMaxAggregateOutputType | null
  }

  export type TimeoffAvgAggregateOutputType = {
    id: number | null
    rfid: number | null
    ishalfday: number | null
    credit: number | null
  }

  export type TimeoffSumAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    ishalfday: number | null
    credit: number | null
  }

  export type TimeoffMinAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    leavetype: string | null
    datefrom: Date | null
    dateto: Date | null
    ishalfday: number | null
    details: string | null
    credit: number | null
    approval: string | null
    approvedate: Date | null
    hrnote: string | null
    hrdate: Date | null
  }

  export type TimeoffMaxAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    leavetype: string | null
    datefrom: Date | null
    dateto: Date | null
    ishalfday: number | null
    details: string | null
    credit: number | null
    approval: string | null
    approvedate: Date | null
    hrnote: string | null
    hrdate: Date | null
  }

  export type TimeoffCountAggregateOutputType = {
    id: number
    rfid: number
    leavetype: number
    datefrom: number
    dateto: number
    ishalfday: number
    details: number
    credit: number
    approval: number
    approvedate: number
    hrnote: number
    hrdate: number
    _all: number
  }


  export type TimeoffAvgAggregateInputType = {
    id?: true
    rfid?: true
    ishalfday?: true
    credit?: true
  }

  export type TimeoffSumAggregateInputType = {
    id?: true
    rfid?: true
    ishalfday?: true
    credit?: true
  }

  export type TimeoffMinAggregateInputType = {
    id?: true
    rfid?: true
    leavetype?: true
    datefrom?: true
    dateto?: true
    ishalfday?: true
    details?: true
    credit?: true
    approval?: true
    approvedate?: true
    hrnote?: true
    hrdate?: true
  }

  export type TimeoffMaxAggregateInputType = {
    id?: true
    rfid?: true
    leavetype?: true
    datefrom?: true
    dateto?: true
    ishalfday?: true
    details?: true
    credit?: true
    approval?: true
    approvedate?: true
    hrnote?: true
    hrdate?: true
  }

  export type TimeoffCountAggregateInputType = {
    id?: true
    rfid?: true
    leavetype?: true
    datefrom?: true
    dateto?: true
    ishalfday?: true
    details?: true
    credit?: true
    approval?: true
    approvedate?: true
    hrnote?: true
    hrdate?: true
    _all?: true
  }

  export type TimeoffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which timeoff to aggregate.
     */
    where?: timeoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of timeoffs to fetch.
     */
    orderBy?: timeoffOrderByWithRelationInput | timeoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: timeoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` timeoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` timeoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned timeoffs
    **/
    _count?: true | TimeoffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeoffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeoffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeoffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeoffMaxAggregateInputType
  }

  export type GetTimeoffAggregateType<T extends TimeoffAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeoff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeoff[P]>
      : GetScalarType<T[P], AggregateTimeoff[P]>
  }




  export type timeoffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: timeoffWhereInput
    orderBy?: timeoffOrderByWithAggregationInput | timeoffOrderByWithAggregationInput[]
    by: TimeoffScalarFieldEnum[] | TimeoffScalarFieldEnum
    having?: timeoffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeoffCountAggregateInputType | true
    _avg?: TimeoffAvgAggregateInputType
    _sum?: TimeoffSumAggregateInputType
    _min?: TimeoffMinAggregateInputType
    _max?: TimeoffMaxAggregateInputType
  }

  export type TimeoffGroupByOutputType = {
    id: number
    rfid: bigint
    leavetype: string
    datefrom: Date
    dateto: Date
    ishalfday: number
    details: string
    credit: number
    approval: string
    approvedate: Date
    hrnote: string
    hrdate: Date
    _count: TimeoffCountAggregateOutputType | null
    _avg: TimeoffAvgAggregateOutputType | null
    _sum: TimeoffSumAggregateOutputType | null
    _min: TimeoffMinAggregateOutputType | null
    _max: TimeoffMaxAggregateOutputType | null
  }

  type GetTimeoffGroupByPayload<T extends timeoffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeoffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeoffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeoffGroupByOutputType[P]>
            : GetScalarType<T[P], TimeoffGroupByOutputType[P]>
        }
      >
    >


  export type timeoffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfid?: boolean
    leavetype?: boolean
    datefrom?: boolean
    dateto?: boolean
    ishalfday?: boolean
    details?: boolean
    credit?: boolean
    approval?: boolean
    approvedate?: boolean
    hrnote?: boolean
    hrdate?: boolean
  }, ExtArgs["result"]["timeoff"]>



  export type timeoffSelectScalar = {
    id?: boolean
    rfid?: boolean
    leavetype?: boolean
    datefrom?: boolean
    dateto?: boolean
    ishalfday?: boolean
    details?: boolean
    credit?: boolean
    approval?: boolean
    approvedate?: boolean
    hrnote?: boolean
    hrdate?: boolean
  }

  export type timeoffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rfid" | "leavetype" | "datefrom" | "dateto" | "ishalfday" | "details" | "credit" | "approval" | "approvedate" | "hrnote" | "hrdate", ExtArgs["result"]["timeoff"]>

  export type $timeoffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "timeoff"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rfid: bigint
      leavetype: string
      datefrom: Date
      dateto: Date
      ishalfday: number
      details: string
      credit: number
      approval: string
      approvedate: Date
      hrnote: string
      hrdate: Date
    }, ExtArgs["result"]["timeoff"]>
    composites: {}
  }

  type timeoffGetPayload<S extends boolean | null | undefined | timeoffDefaultArgs> = $Result.GetResult<Prisma.$timeoffPayload, S>

  type timeoffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<timeoffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeoffCountAggregateInputType | true
    }

  export interface timeoffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['timeoff'], meta: { name: 'timeoff' } }
    /**
     * Find zero or one Timeoff that matches the filter.
     * @param {timeoffFindUniqueArgs} args - Arguments to find a Timeoff
     * @example
     * // Get one Timeoff
     * const timeoff = await prisma.timeoff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends timeoffFindUniqueArgs>(args: SelectSubset<T, timeoffFindUniqueArgs<ExtArgs>>): Prisma__timeoffClient<$Result.GetResult<Prisma.$timeoffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Timeoff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {timeoffFindUniqueOrThrowArgs} args - Arguments to find a Timeoff
     * @example
     * // Get one Timeoff
     * const timeoff = await prisma.timeoff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends timeoffFindUniqueOrThrowArgs>(args: SelectSubset<T, timeoffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__timeoffClient<$Result.GetResult<Prisma.$timeoffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Timeoff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeoffFindFirstArgs} args - Arguments to find a Timeoff
     * @example
     * // Get one Timeoff
     * const timeoff = await prisma.timeoff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends timeoffFindFirstArgs>(args?: SelectSubset<T, timeoffFindFirstArgs<ExtArgs>>): Prisma__timeoffClient<$Result.GetResult<Prisma.$timeoffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Timeoff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeoffFindFirstOrThrowArgs} args - Arguments to find a Timeoff
     * @example
     * // Get one Timeoff
     * const timeoff = await prisma.timeoff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends timeoffFindFirstOrThrowArgs>(args?: SelectSubset<T, timeoffFindFirstOrThrowArgs<ExtArgs>>): Prisma__timeoffClient<$Result.GetResult<Prisma.$timeoffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Timeoffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeoffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Timeoffs
     * const timeoffs = await prisma.timeoff.findMany()
     * 
     * // Get first 10 Timeoffs
     * const timeoffs = await prisma.timeoff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeoffWithIdOnly = await prisma.timeoff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends timeoffFindManyArgs>(args?: SelectSubset<T, timeoffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$timeoffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Timeoff.
     * @param {timeoffCreateArgs} args - Arguments to create a Timeoff.
     * @example
     * // Create one Timeoff
     * const Timeoff = await prisma.timeoff.create({
     *   data: {
     *     // ... data to create a Timeoff
     *   }
     * })
     * 
     */
    create<T extends timeoffCreateArgs>(args: SelectSubset<T, timeoffCreateArgs<ExtArgs>>): Prisma__timeoffClient<$Result.GetResult<Prisma.$timeoffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Timeoffs.
     * @param {timeoffCreateManyArgs} args - Arguments to create many Timeoffs.
     * @example
     * // Create many Timeoffs
     * const timeoff = await prisma.timeoff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends timeoffCreateManyArgs>(args?: SelectSubset<T, timeoffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Timeoff.
     * @param {timeoffDeleteArgs} args - Arguments to delete one Timeoff.
     * @example
     * // Delete one Timeoff
     * const Timeoff = await prisma.timeoff.delete({
     *   where: {
     *     // ... filter to delete one Timeoff
     *   }
     * })
     * 
     */
    delete<T extends timeoffDeleteArgs>(args: SelectSubset<T, timeoffDeleteArgs<ExtArgs>>): Prisma__timeoffClient<$Result.GetResult<Prisma.$timeoffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Timeoff.
     * @param {timeoffUpdateArgs} args - Arguments to update one Timeoff.
     * @example
     * // Update one Timeoff
     * const timeoff = await prisma.timeoff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends timeoffUpdateArgs>(args: SelectSubset<T, timeoffUpdateArgs<ExtArgs>>): Prisma__timeoffClient<$Result.GetResult<Prisma.$timeoffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Timeoffs.
     * @param {timeoffDeleteManyArgs} args - Arguments to filter Timeoffs to delete.
     * @example
     * // Delete a few Timeoffs
     * const { count } = await prisma.timeoff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends timeoffDeleteManyArgs>(args?: SelectSubset<T, timeoffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timeoffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeoffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Timeoffs
     * const timeoff = await prisma.timeoff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends timeoffUpdateManyArgs>(args: SelectSubset<T, timeoffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Timeoff.
     * @param {timeoffUpsertArgs} args - Arguments to update or create a Timeoff.
     * @example
     * // Update or create a Timeoff
     * const timeoff = await prisma.timeoff.upsert({
     *   create: {
     *     // ... data to create a Timeoff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Timeoff we want to update
     *   }
     * })
     */
    upsert<T extends timeoffUpsertArgs>(args: SelectSubset<T, timeoffUpsertArgs<ExtArgs>>): Prisma__timeoffClient<$Result.GetResult<Prisma.$timeoffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Timeoffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeoffCountArgs} args - Arguments to filter Timeoffs to count.
     * @example
     * // Count the number of Timeoffs
     * const count = await prisma.timeoff.count({
     *   where: {
     *     // ... the filter for the Timeoffs we want to count
     *   }
     * })
    **/
    count<T extends timeoffCountArgs>(
      args?: Subset<T, timeoffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeoffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Timeoff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeoffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeoffAggregateArgs>(args: Subset<T, TimeoffAggregateArgs>): Prisma.PrismaPromise<GetTimeoffAggregateType<T>>

    /**
     * Group by Timeoff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeoffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends timeoffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: timeoffGroupByArgs['orderBy'] }
        : { orderBy?: timeoffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, timeoffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeoffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the timeoff model
   */
  readonly fields: timeoffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for timeoff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__timeoffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the timeoff model
   */
  interface timeoffFieldRefs {
    readonly id: FieldRef<"timeoff", 'Int'>
    readonly rfid: FieldRef<"timeoff", 'BigInt'>
    readonly leavetype: FieldRef<"timeoff", 'String'>
    readonly datefrom: FieldRef<"timeoff", 'DateTime'>
    readonly dateto: FieldRef<"timeoff", 'DateTime'>
    readonly ishalfday: FieldRef<"timeoff", 'Int'>
    readonly details: FieldRef<"timeoff", 'String'>
    readonly credit: FieldRef<"timeoff", 'Int'>
    readonly approval: FieldRef<"timeoff", 'String'>
    readonly approvedate: FieldRef<"timeoff", 'DateTime'>
    readonly hrnote: FieldRef<"timeoff", 'String'>
    readonly hrdate: FieldRef<"timeoff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * timeoff findUnique
   */
  export type timeoffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeoff
     */
    select?: timeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeoff
     */
    omit?: timeoffOmit<ExtArgs> | null
    /**
     * Filter, which timeoff to fetch.
     */
    where: timeoffWhereUniqueInput
  }

  /**
   * timeoff findUniqueOrThrow
   */
  export type timeoffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeoff
     */
    select?: timeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeoff
     */
    omit?: timeoffOmit<ExtArgs> | null
    /**
     * Filter, which timeoff to fetch.
     */
    where: timeoffWhereUniqueInput
  }

  /**
   * timeoff findFirst
   */
  export type timeoffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeoff
     */
    select?: timeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeoff
     */
    omit?: timeoffOmit<ExtArgs> | null
    /**
     * Filter, which timeoff to fetch.
     */
    where?: timeoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of timeoffs to fetch.
     */
    orderBy?: timeoffOrderByWithRelationInput | timeoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for timeoffs.
     */
    cursor?: timeoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` timeoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` timeoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of timeoffs.
     */
    distinct?: TimeoffScalarFieldEnum | TimeoffScalarFieldEnum[]
  }

  /**
   * timeoff findFirstOrThrow
   */
  export type timeoffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeoff
     */
    select?: timeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeoff
     */
    omit?: timeoffOmit<ExtArgs> | null
    /**
     * Filter, which timeoff to fetch.
     */
    where?: timeoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of timeoffs to fetch.
     */
    orderBy?: timeoffOrderByWithRelationInput | timeoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for timeoffs.
     */
    cursor?: timeoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` timeoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` timeoffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of timeoffs.
     */
    distinct?: TimeoffScalarFieldEnum | TimeoffScalarFieldEnum[]
  }

  /**
   * timeoff findMany
   */
  export type timeoffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeoff
     */
    select?: timeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeoff
     */
    omit?: timeoffOmit<ExtArgs> | null
    /**
     * Filter, which timeoffs to fetch.
     */
    where?: timeoffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of timeoffs to fetch.
     */
    orderBy?: timeoffOrderByWithRelationInput | timeoffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing timeoffs.
     */
    cursor?: timeoffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` timeoffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` timeoffs.
     */
    skip?: number
    distinct?: TimeoffScalarFieldEnum | TimeoffScalarFieldEnum[]
  }

  /**
   * timeoff create
   */
  export type timeoffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeoff
     */
    select?: timeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeoff
     */
    omit?: timeoffOmit<ExtArgs> | null
    /**
     * The data needed to create a timeoff.
     */
    data: XOR<timeoffCreateInput, timeoffUncheckedCreateInput>
  }

  /**
   * timeoff createMany
   */
  export type timeoffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many timeoffs.
     */
    data: timeoffCreateManyInput | timeoffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * timeoff update
   */
  export type timeoffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeoff
     */
    select?: timeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeoff
     */
    omit?: timeoffOmit<ExtArgs> | null
    /**
     * The data needed to update a timeoff.
     */
    data: XOR<timeoffUpdateInput, timeoffUncheckedUpdateInput>
    /**
     * Choose, which timeoff to update.
     */
    where: timeoffWhereUniqueInput
  }

  /**
   * timeoff updateMany
   */
  export type timeoffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update timeoffs.
     */
    data: XOR<timeoffUpdateManyMutationInput, timeoffUncheckedUpdateManyInput>
    /**
     * Filter which timeoffs to update
     */
    where?: timeoffWhereInput
    /**
     * Limit how many timeoffs to update.
     */
    limit?: number
  }

  /**
   * timeoff upsert
   */
  export type timeoffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeoff
     */
    select?: timeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeoff
     */
    omit?: timeoffOmit<ExtArgs> | null
    /**
     * The filter to search for the timeoff to update in case it exists.
     */
    where: timeoffWhereUniqueInput
    /**
     * In case the timeoff found by the `where` argument doesn't exist, create a new timeoff with this data.
     */
    create: XOR<timeoffCreateInput, timeoffUncheckedCreateInput>
    /**
     * In case the timeoff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<timeoffUpdateInput, timeoffUncheckedUpdateInput>
  }

  /**
   * timeoff delete
   */
  export type timeoffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeoff
     */
    select?: timeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeoff
     */
    omit?: timeoffOmit<ExtArgs> | null
    /**
     * Filter which timeoff to delete.
     */
    where: timeoffWhereUniqueInput
  }

  /**
   * timeoff deleteMany
   */
  export type timeoffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which timeoffs to delete
     */
    where?: timeoffWhereInput
    /**
     * Limit how many timeoffs to delete.
     */
    limit?: number
  }

  /**
   * timeoff without action
   */
  export type timeoffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeoff
     */
    select?: timeoffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeoff
     */
    omit?: timeoffOmit<ExtArgs> | null
  }


  /**
   * Model type_of_products
   */

  export type AggregateType_of_products = {
    _count: Type_of_productsCountAggregateOutputType | null
    _avg: Type_of_productsAvgAggregateOutputType | null
    _sum: Type_of_productsSumAggregateOutputType | null
    _min: Type_of_productsMinAggregateOutputType | null
    _max: Type_of_productsMaxAggregateOutputType | null
  }

  export type Type_of_productsAvgAggregateOutputType = {
    id: number | null
  }

  export type Type_of_productsSumAggregateOutputType = {
    id: number | null
  }

  export type Type_of_productsMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Type_of_productsMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Type_of_productsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Type_of_productsAvgAggregateInputType = {
    id?: true
  }

  export type Type_of_productsSumAggregateInputType = {
    id?: true
  }

  export type Type_of_productsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Type_of_productsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Type_of_productsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Type_of_productsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which type_of_products to aggregate.
     */
    where?: type_of_productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_of_products to fetch.
     */
    orderBy?: type_of_productsOrderByWithRelationInput | type_of_productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: type_of_productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_of_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_of_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned type_of_products
    **/
    _count?: true | Type_of_productsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Type_of_productsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Type_of_productsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Type_of_productsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Type_of_productsMaxAggregateInputType
  }

  export type GetType_of_productsAggregateType<T extends Type_of_productsAggregateArgs> = {
        [P in keyof T & keyof AggregateType_of_products]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateType_of_products[P]>
      : GetScalarType<T[P], AggregateType_of_products[P]>
  }




  export type type_of_productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: type_of_productsWhereInput
    orderBy?: type_of_productsOrderByWithAggregationInput | type_of_productsOrderByWithAggregationInput[]
    by: Type_of_productsScalarFieldEnum[] | Type_of_productsScalarFieldEnum
    having?: type_of_productsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Type_of_productsCountAggregateInputType | true
    _avg?: Type_of_productsAvgAggregateInputType
    _sum?: Type_of_productsSumAggregateInputType
    _min?: Type_of_productsMinAggregateInputType
    _max?: Type_of_productsMaxAggregateInputType
  }

  export type Type_of_productsGroupByOutputType = {
    id: number
    name: string
    _count: Type_of_productsCountAggregateOutputType | null
    _avg: Type_of_productsAvgAggregateOutputType | null
    _sum: Type_of_productsSumAggregateOutputType | null
    _min: Type_of_productsMinAggregateOutputType | null
    _max: Type_of_productsMaxAggregateOutputType | null
  }

  type GetType_of_productsGroupByPayload<T extends type_of_productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Type_of_productsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Type_of_productsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Type_of_productsGroupByOutputType[P]>
            : GetScalarType<T[P], Type_of_productsGroupByOutputType[P]>
        }
      >
    >


  export type type_of_productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["type_of_products"]>



  export type type_of_productsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type type_of_productsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["type_of_products"]>

  export type $type_of_productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "type_of_products"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["type_of_products"]>
    composites: {}
  }

  type type_of_productsGetPayload<S extends boolean | null | undefined | type_of_productsDefaultArgs> = $Result.GetResult<Prisma.$type_of_productsPayload, S>

  type type_of_productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<type_of_productsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Type_of_productsCountAggregateInputType | true
    }

  export interface type_of_productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['type_of_products'], meta: { name: 'type_of_products' } }
    /**
     * Find zero or one Type_of_products that matches the filter.
     * @param {type_of_productsFindUniqueArgs} args - Arguments to find a Type_of_products
     * @example
     * // Get one Type_of_products
     * const type_of_products = await prisma.type_of_products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends type_of_productsFindUniqueArgs>(args: SelectSubset<T, type_of_productsFindUniqueArgs<ExtArgs>>): Prisma__type_of_productsClient<$Result.GetResult<Prisma.$type_of_productsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Type_of_products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {type_of_productsFindUniqueOrThrowArgs} args - Arguments to find a Type_of_products
     * @example
     * // Get one Type_of_products
     * const type_of_products = await prisma.type_of_products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends type_of_productsFindUniqueOrThrowArgs>(args: SelectSubset<T, type_of_productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__type_of_productsClient<$Result.GetResult<Prisma.$type_of_productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Type_of_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_productsFindFirstArgs} args - Arguments to find a Type_of_products
     * @example
     * // Get one Type_of_products
     * const type_of_products = await prisma.type_of_products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends type_of_productsFindFirstArgs>(args?: SelectSubset<T, type_of_productsFindFirstArgs<ExtArgs>>): Prisma__type_of_productsClient<$Result.GetResult<Prisma.$type_of_productsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Type_of_products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_productsFindFirstOrThrowArgs} args - Arguments to find a Type_of_products
     * @example
     * // Get one Type_of_products
     * const type_of_products = await prisma.type_of_products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends type_of_productsFindFirstOrThrowArgs>(args?: SelectSubset<T, type_of_productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__type_of_productsClient<$Result.GetResult<Prisma.$type_of_productsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Type_of_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Type_of_products
     * const type_of_products = await prisma.type_of_products.findMany()
     * 
     * // Get first 10 Type_of_products
     * const type_of_products = await prisma.type_of_products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const type_of_productsWithIdOnly = await prisma.type_of_products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends type_of_productsFindManyArgs>(args?: SelectSubset<T, type_of_productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$type_of_productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Type_of_products.
     * @param {type_of_productsCreateArgs} args - Arguments to create a Type_of_products.
     * @example
     * // Create one Type_of_products
     * const Type_of_products = await prisma.type_of_products.create({
     *   data: {
     *     // ... data to create a Type_of_products
     *   }
     * })
     * 
     */
    create<T extends type_of_productsCreateArgs>(args: SelectSubset<T, type_of_productsCreateArgs<ExtArgs>>): Prisma__type_of_productsClient<$Result.GetResult<Prisma.$type_of_productsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Type_of_products.
     * @param {type_of_productsCreateManyArgs} args - Arguments to create many Type_of_products.
     * @example
     * // Create many Type_of_products
     * const type_of_products = await prisma.type_of_products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends type_of_productsCreateManyArgs>(args?: SelectSubset<T, type_of_productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Type_of_products.
     * @param {type_of_productsDeleteArgs} args - Arguments to delete one Type_of_products.
     * @example
     * // Delete one Type_of_products
     * const Type_of_products = await prisma.type_of_products.delete({
     *   where: {
     *     // ... filter to delete one Type_of_products
     *   }
     * })
     * 
     */
    delete<T extends type_of_productsDeleteArgs>(args: SelectSubset<T, type_of_productsDeleteArgs<ExtArgs>>): Prisma__type_of_productsClient<$Result.GetResult<Prisma.$type_of_productsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Type_of_products.
     * @param {type_of_productsUpdateArgs} args - Arguments to update one Type_of_products.
     * @example
     * // Update one Type_of_products
     * const type_of_products = await prisma.type_of_products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends type_of_productsUpdateArgs>(args: SelectSubset<T, type_of_productsUpdateArgs<ExtArgs>>): Prisma__type_of_productsClient<$Result.GetResult<Prisma.$type_of_productsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Type_of_products.
     * @param {type_of_productsDeleteManyArgs} args - Arguments to filter Type_of_products to delete.
     * @example
     * // Delete a few Type_of_products
     * const { count } = await prisma.type_of_products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends type_of_productsDeleteManyArgs>(args?: SelectSubset<T, type_of_productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Type_of_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Type_of_products
     * const type_of_products = await prisma.type_of_products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends type_of_productsUpdateManyArgs>(args: SelectSubset<T, type_of_productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Type_of_products.
     * @param {type_of_productsUpsertArgs} args - Arguments to update or create a Type_of_products.
     * @example
     * // Update or create a Type_of_products
     * const type_of_products = await prisma.type_of_products.upsert({
     *   create: {
     *     // ... data to create a Type_of_products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Type_of_products we want to update
     *   }
     * })
     */
    upsert<T extends type_of_productsUpsertArgs>(args: SelectSubset<T, type_of_productsUpsertArgs<ExtArgs>>): Prisma__type_of_productsClient<$Result.GetResult<Prisma.$type_of_productsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Type_of_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_productsCountArgs} args - Arguments to filter Type_of_products to count.
     * @example
     * // Count the number of Type_of_products
     * const count = await prisma.type_of_products.count({
     *   where: {
     *     // ... the filter for the Type_of_products we want to count
     *   }
     * })
    **/
    count<T extends type_of_productsCountArgs>(
      args?: Subset<T, type_of_productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Type_of_productsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Type_of_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Type_of_productsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Type_of_productsAggregateArgs>(args: Subset<T, Type_of_productsAggregateArgs>): Prisma.PrismaPromise<GetType_of_productsAggregateType<T>>

    /**
     * Group by Type_of_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends type_of_productsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: type_of_productsGroupByArgs['orderBy'] }
        : { orderBy?: type_of_productsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, type_of_productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetType_of_productsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the type_of_products model
   */
  readonly fields: type_of_productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for type_of_products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__type_of_productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the type_of_products model
   */
  interface type_of_productsFieldRefs {
    readonly id: FieldRef<"type_of_products", 'Int'>
    readonly name: FieldRef<"type_of_products", 'String'>
  }
    

  // Custom InputTypes
  /**
   * type_of_products findUnique
   */
  export type type_of_productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_products
     */
    select?: type_of_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_products
     */
    omit?: type_of_productsOmit<ExtArgs> | null
    /**
     * Filter, which type_of_products to fetch.
     */
    where: type_of_productsWhereUniqueInput
  }

  /**
   * type_of_products findUniqueOrThrow
   */
  export type type_of_productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_products
     */
    select?: type_of_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_products
     */
    omit?: type_of_productsOmit<ExtArgs> | null
    /**
     * Filter, which type_of_products to fetch.
     */
    where: type_of_productsWhereUniqueInput
  }

  /**
   * type_of_products findFirst
   */
  export type type_of_productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_products
     */
    select?: type_of_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_products
     */
    omit?: type_of_productsOmit<ExtArgs> | null
    /**
     * Filter, which type_of_products to fetch.
     */
    where?: type_of_productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_of_products to fetch.
     */
    orderBy?: type_of_productsOrderByWithRelationInput | type_of_productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for type_of_products.
     */
    cursor?: type_of_productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_of_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_of_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of type_of_products.
     */
    distinct?: Type_of_productsScalarFieldEnum | Type_of_productsScalarFieldEnum[]
  }

  /**
   * type_of_products findFirstOrThrow
   */
  export type type_of_productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_products
     */
    select?: type_of_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_products
     */
    omit?: type_of_productsOmit<ExtArgs> | null
    /**
     * Filter, which type_of_products to fetch.
     */
    where?: type_of_productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_of_products to fetch.
     */
    orderBy?: type_of_productsOrderByWithRelationInput | type_of_productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for type_of_products.
     */
    cursor?: type_of_productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_of_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_of_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of type_of_products.
     */
    distinct?: Type_of_productsScalarFieldEnum | Type_of_productsScalarFieldEnum[]
  }

  /**
   * type_of_products findMany
   */
  export type type_of_productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_products
     */
    select?: type_of_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_products
     */
    omit?: type_of_productsOmit<ExtArgs> | null
    /**
     * Filter, which type_of_products to fetch.
     */
    where?: type_of_productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_of_products to fetch.
     */
    orderBy?: type_of_productsOrderByWithRelationInput | type_of_productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing type_of_products.
     */
    cursor?: type_of_productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_of_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_of_products.
     */
    skip?: number
    distinct?: Type_of_productsScalarFieldEnum | Type_of_productsScalarFieldEnum[]
  }

  /**
   * type_of_products create
   */
  export type type_of_productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_products
     */
    select?: type_of_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_products
     */
    omit?: type_of_productsOmit<ExtArgs> | null
    /**
     * The data needed to create a type_of_products.
     */
    data: XOR<type_of_productsCreateInput, type_of_productsUncheckedCreateInput>
  }

  /**
   * type_of_products createMany
   */
  export type type_of_productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many type_of_products.
     */
    data: type_of_productsCreateManyInput | type_of_productsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * type_of_products update
   */
  export type type_of_productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_products
     */
    select?: type_of_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_products
     */
    omit?: type_of_productsOmit<ExtArgs> | null
    /**
     * The data needed to update a type_of_products.
     */
    data: XOR<type_of_productsUpdateInput, type_of_productsUncheckedUpdateInput>
    /**
     * Choose, which type_of_products to update.
     */
    where: type_of_productsWhereUniqueInput
  }

  /**
   * type_of_products updateMany
   */
  export type type_of_productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update type_of_products.
     */
    data: XOR<type_of_productsUpdateManyMutationInput, type_of_productsUncheckedUpdateManyInput>
    /**
     * Filter which type_of_products to update
     */
    where?: type_of_productsWhereInput
    /**
     * Limit how many type_of_products to update.
     */
    limit?: number
  }

  /**
   * type_of_products upsert
   */
  export type type_of_productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_products
     */
    select?: type_of_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_products
     */
    omit?: type_of_productsOmit<ExtArgs> | null
    /**
     * The filter to search for the type_of_products to update in case it exists.
     */
    where: type_of_productsWhereUniqueInput
    /**
     * In case the type_of_products found by the `where` argument doesn't exist, create a new type_of_products with this data.
     */
    create: XOR<type_of_productsCreateInput, type_of_productsUncheckedCreateInput>
    /**
     * In case the type_of_products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<type_of_productsUpdateInput, type_of_productsUncheckedUpdateInput>
  }

  /**
   * type_of_products delete
   */
  export type type_of_productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_products
     */
    select?: type_of_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_products
     */
    omit?: type_of_productsOmit<ExtArgs> | null
    /**
     * Filter which type_of_products to delete.
     */
    where: type_of_productsWhereUniqueInput
  }

  /**
   * type_of_products deleteMany
   */
  export type type_of_productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which type_of_products to delete
     */
    where?: type_of_productsWhereInput
    /**
     * Limit how many type_of_products to delete.
     */
    limit?: number
  }

  /**
   * type_of_products without action
   */
  export type type_of_productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_products
     */
    select?: type_of_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_products
     */
    omit?: type_of_productsOmit<ExtArgs> | null
  }


  /**
   * Model uniform
   */

  export type AggregateUniform = {
    _count: UniformCountAggregateOutputType | null
    _avg: UniformAvgAggregateOutputType | null
    _sum: UniformSumAggregateOutputType | null
    _min: UniformMinAggregateOutputType | null
    _max: UniformMaxAggregateOutputType | null
  }

  export type UniformAvgAggregateOutputType = {
    id: number | null
    iscomplete: number | null
  }

  export type UniformSumAggregateOutputType = {
    id: number | null
    iscomplete: number | null
  }

  export type UniformMinAggregateOutputType = {
    id: number | null
    rfid: string | null
    size: string | null
    basic: string | null
    activity: string | null
    formal: string | null
    qtybasic: string | null
    qtyact: string | null
    qtyform: string | null
    iscomplete: number | null
    lasttouch: string | null
    dateordered: string | null
    datereleased: string | null
    comment: string | null
  }

  export type UniformMaxAggregateOutputType = {
    id: number | null
    rfid: string | null
    size: string | null
    basic: string | null
    activity: string | null
    formal: string | null
    qtybasic: string | null
    qtyact: string | null
    qtyform: string | null
    iscomplete: number | null
    lasttouch: string | null
    dateordered: string | null
    datereleased: string | null
    comment: string | null
  }

  export type UniformCountAggregateOutputType = {
    id: number
    rfid: number
    size: number
    basic: number
    activity: number
    formal: number
    qtybasic: number
    qtyact: number
    qtyform: number
    iscomplete: number
    lasttouch: number
    dateordered: number
    datereleased: number
    comment: number
    _all: number
  }


  export type UniformAvgAggregateInputType = {
    id?: true
    iscomplete?: true
  }

  export type UniformSumAggregateInputType = {
    id?: true
    iscomplete?: true
  }

  export type UniformMinAggregateInputType = {
    id?: true
    rfid?: true
    size?: true
    basic?: true
    activity?: true
    formal?: true
    qtybasic?: true
    qtyact?: true
    qtyform?: true
    iscomplete?: true
    lasttouch?: true
    dateordered?: true
    datereleased?: true
    comment?: true
  }

  export type UniformMaxAggregateInputType = {
    id?: true
    rfid?: true
    size?: true
    basic?: true
    activity?: true
    formal?: true
    qtybasic?: true
    qtyact?: true
    qtyform?: true
    iscomplete?: true
    lasttouch?: true
    dateordered?: true
    datereleased?: true
    comment?: true
  }

  export type UniformCountAggregateInputType = {
    id?: true
    rfid?: true
    size?: true
    basic?: true
    activity?: true
    formal?: true
    qtybasic?: true
    qtyact?: true
    qtyform?: true
    iscomplete?: true
    lasttouch?: true
    dateordered?: true
    datereleased?: true
    comment?: true
    _all?: true
  }

  export type UniformAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which uniform to aggregate.
     */
    where?: uniformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniforms to fetch.
     */
    orderBy?: uniformOrderByWithRelationInput | uniformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: uniformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned uniforms
    **/
    _count?: true | UniformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UniformAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UniformSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UniformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UniformMaxAggregateInputType
  }

  export type GetUniformAggregateType<T extends UniformAggregateArgs> = {
        [P in keyof T & keyof AggregateUniform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniform[P]>
      : GetScalarType<T[P], AggregateUniform[P]>
  }




  export type uniformGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: uniformWhereInput
    orderBy?: uniformOrderByWithAggregationInput | uniformOrderByWithAggregationInput[]
    by: UniformScalarFieldEnum[] | UniformScalarFieldEnum
    having?: uniformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UniformCountAggregateInputType | true
    _avg?: UniformAvgAggregateInputType
    _sum?: UniformSumAggregateInputType
    _min?: UniformMinAggregateInputType
    _max?: UniformMaxAggregateInputType
  }

  export type UniformGroupByOutputType = {
    id: number
    rfid: string
    size: string
    basic: string | null
    activity: string | null
    formal: string | null
    qtybasic: string
    qtyact: string
    qtyform: string
    iscomplete: number
    lasttouch: string
    dateordered: string | null
    datereleased: string | null
    comment: string
    _count: UniformCountAggregateOutputType | null
    _avg: UniformAvgAggregateOutputType | null
    _sum: UniformSumAggregateOutputType | null
    _min: UniformMinAggregateOutputType | null
    _max: UniformMaxAggregateOutputType | null
  }

  type GetUniformGroupByPayload<T extends uniformGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UniformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UniformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UniformGroupByOutputType[P]>
            : GetScalarType<T[P], UniformGroupByOutputType[P]>
        }
      >
    >


  export type uniformSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfid?: boolean
    size?: boolean
    basic?: boolean
    activity?: boolean
    formal?: boolean
    qtybasic?: boolean
    qtyact?: boolean
    qtyform?: boolean
    iscomplete?: boolean
    lasttouch?: boolean
    dateordered?: boolean
    datereleased?: boolean
    comment?: boolean
  }, ExtArgs["result"]["uniform"]>



  export type uniformSelectScalar = {
    id?: boolean
    rfid?: boolean
    size?: boolean
    basic?: boolean
    activity?: boolean
    formal?: boolean
    qtybasic?: boolean
    qtyact?: boolean
    qtyform?: boolean
    iscomplete?: boolean
    lasttouch?: boolean
    dateordered?: boolean
    datereleased?: boolean
    comment?: boolean
  }

  export type uniformOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rfid" | "size" | "basic" | "activity" | "formal" | "qtybasic" | "qtyact" | "qtyform" | "iscomplete" | "lasttouch" | "dateordered" | "datereleased" | "comment", ExtArgs["result"]["uniform"]>

  export type $uniformPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "uniform"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rfid: string
      size: string
      basic: string | null
      activity: string | null
      formal: string | null
      qtybasic: string
      qtyact: string
      qtyform: string
      iscomplete: number
      lasttouch: string
      dateordered: string | null
      datereleased: string | null
      comment: string
    }, ExtArgs["result"]["uniform"]>
    composites: {}
  }

  type uniformGetPayload<S extends boolean | null | undefined | uniformDefaultArgs> = $Result.GetResult<Prisma.$uniformPayload, S>

  type uniformCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<uniformFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UniformCountAggregateInputType | true
    }

  export interface uniformDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['uniform'], meta: { name: 'uniform' } }
    /**
     * Find zero or one Uniform that matches the filter.
     * @param {uniformFindUniqueArgs} args - Arguments to find a Uniform
     * @example
     * // Get one Uniform
     * const uniform = await prisma.uniform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends uniformFindUniqueArgs>(args: SelectSubset<T, uniformFindUniqueArgs<ExtArgs>>): Prisma__uniformClient<$Result.GetResult<Prisma.$uniformPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Uniform that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {uniformFindUniqueOrThrowArgs} args - Arguments to find a Uniform
     * @example
     * // Get one Uniform
     * const uniform = await prisma.uniform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends uniformFindUniqueOrThrowArgs>(args: SelectSubset<T, uniformFindUniqueOrThrowArgs<ExtArgs>>): Prisma__uniformClient<$Result.GetResult<Prisma.$uniformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Uniform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniformFindFirstArgs} args - Arguments to find a Uniform
     * @example
     * // Get one Uniform
     * const uniform = await prisma.uniform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends uniformFindFirstArgs>(args?: SelectSubset<T, uniformFindFirstArgs<ExtArgs>>): Prisma__uniformClient<$Result.GetResult<Prisma.$uniformPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Uniform that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniformFindFirstOrThrowArgs} args - Arguments to find a Uniform
     * @example
     * // Get one Uniform
     * const uniform = await prisma.uniform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends uniformFindFirstOrThrowArgs>(args?: SelectSubset<T, uniformFindFirstOrThrowArgs<ExtArgs>>): Prisma__uniformClient<$Result.GetResult<Prisma.$uniformPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Uniforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniformFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Uniforms
     * const uniforms = await prisma.uniform.findMany()
     * 
     * // Get first 10 Uniforms
     * const uniforms = await prisma.uniform.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uniformWithIdOnly = await prisma.uniform.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends uniformFindManyArgs>(args?: SelectSubset<T, uniformFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$uniformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Uniform.
     * @param {uniformCreateArgs} args - Arguments to create a Uniform.
     * @example
     * // Create one Uniform
     * const Uniform = await prisma.uniform.create({
     *   data: {
     *     // ... data to create a Uniform
     *   }
     * })
     * 
     */
    create<T extends uniformCreateArgs>(args: SelectSubset<T, uniformCreateArgs<ExtArgs>>): Prisma__uniformClient<$Result.GetResult<Prisma.$uniformPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Uniforms.
     * @param {uniformCreateManyArgs} args - Arguments to create many Uniforms.
     * @example
     * // Create many Uniforms
     * const uniform = await prisma.uniform.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends uniformCreateManyArgs>(args?: SelectSubset<T, uniformCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Uniform.
     * @param {uniformDeleteArgs} args - Arguments to delete one Uniform.
     * @example
     * // Delete one Uniform
     * const Uniform = await prisma.uniform.delete({
     *   where: {
     *     // ... filter to delete one Uniform
     *   }
     * })
     * 
     */
    delete<T extends uniformDeleteArgs>(args: SelectSubset<T, uniformDeleteArgs<ExtArgs>>): Prisma__uniformClient<$Result.GetResult<Prisma.$uniformPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Uniform.
     * @param {uniformUpdateArgs} args - Arguments to update one Uniform.
     * @example
     * // Update one Uniform
     * const uniform = await prisma.uniform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends uniformUpdateArgs>(args: SelectSubset<T, uniformUpdateArgs<ExtArgs>>): Prisma__uniformClient<$Result.GetResult<Prisma.$uniformPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Uniforms.
     * @param {uniformDeleteManyArgs} args - Arguments to filter Uniforms to delete.
     * @example
     * // Delete a few Uniforms
     * const { count } = await prisma.uniform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends uniformDeleteManyArgs>(args?: SelectSubset<T, uniformDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uniforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Uniforms
     * const uniform = await prisma.uniform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends uniformUpdateManyArgs>(args: SelectSubset<T, uniformUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Uniform.
     * @param {uniformUpsertArgs} args - Arguments to update or create a Uniform.
     * @example
     * // Update or create a Uniform
     * const uniform = await prisma.uniform.upsert({
     *   create: {
     *     // ... data to create a Uniform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Uniform we want to update
     *   }
     * })
     */
    upsert<T extends uniformUpsertArgs>(args: SelectSubset<T, uniformUpsertArgs<ExtArgs>>): Prisma__uniformClient<$Result.GetResult<Prisma.$uniformPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Uniforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniformCountArgs} args - Arguments to filter Uniforms to count.
     * @example
     * // Count the number of Uniforms
     * const count = await prisma.uniform.count({
     *   where: {
     *     // ... the filter for the Uniforms we want to count
     *   }
     * })
    **/
    count<T extends uniformCountArgs>(
      args?: Subset<T, uniformCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UniformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Uniform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UniformAggregateArgs>(args: Subset<T, UniformAggregateArgs>): Prisma.PrismaPromise<GetUniformAggregateType<T>>

    /**
     * Group by Uniform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends uniformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: uniformGroupByArgs['orderBy'] }
        : { orderBy?: uniformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, uniformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniformGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the uniform model
   */
  readonly fields: uniformFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for uniform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__uniformClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the uniform model
   */
  interface uniformFieldRefs {
    readonly id: FieldRef<"uniform", 'Int'>
    readonly rfid: FieldRef<"uniform", 'String'>
    readonly size: FieldRef<"uniform", 'String'>
    readonly basic: FieldRef<"uniform", 'String'>
    readonly activity: FieldRef<"uniform", 'String'>
    readonly formal: FieldRef<"uniform", 'String'>
    readonly qtybasic: FieldRef<"uniform", 'String'>
    readonly qtyact: FieldRef<"uniform", 'String'>
    readonly qtyform: FieldRef<"uniform", 'String'>
    readonly iscomplete: FieldRef<"uniform", 'Int'>
    readonly lasttouch: FieldRef<"uniform", 'String'>
    readonly dateordered: FieldRef<"uniform", 'String'>
    readonly datereleased: FieldRef<"uniform", 'String'>
    readonly comment: FieldRef<"uniform", 'String'>
  }
    

  // Custom InputTypes
  /**
   * uniform findUnique
   */
  export type uniformFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform
     */
    select?: uniformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform
     */
    omit?: uniformOmit<ExtArgs> | null
    /**
     * Filter, which uniform to fetch.
     */
    where: uniformWhereUniqueInput
  }

  /**
   * uniform findUniqueOrThrow
   */
  export type uniformFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform
     */
    select?: uniformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform
     */
    omit?: uniformOmit<ExtArgs> | null
    /**
     * Filter, which uniform to fetch.
     */
    where: uniformWhereUniqueInput
  }

  /**
   * uniform findFirst
   */
  export type uniformFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform
     */
    select?: uniformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform
     */
    omit?: uniformOmit<ExtArgs> | null
    /**
     * Filter, which uniform to fetch.
     */
    where?: uniformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniforms to fetch.
     */
    orderBy?: uniformOrderByWithRelationInput | uniformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for uniforms.
     */
    cursor?: uniformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of uniforms.
     */
    distinct?: UniformScalarFieldEnum | UniformScalarFieldEnum[]
  }

  /**
   * uniform findFirstOrThrow
   */
  export type uniformFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform
     */
    select?: uniformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform
     */
    omit?: uniformOmit<ExtArgs> | null
    /**
     * Filter, which uniform to fetch.
     */
    where?: uniformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniforms to fetch.
     */
    orderBy?: uniformOrderByWithRelationInput | uniformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for uniforms.
     */
    cursor?: uniformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of uniforms.
     */
    distinct?: UniformScalarFieldEnum | UniformScalarFieldEnum[]
  }

  /**
   * uniform findMany
   */
  export type uniformFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform
     */
    select?: uniformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform
     */
    omit?: uniformOmit<ExtArgs> | null
    /**
     * Filter, which uniforms to fetch.
     */
    where?: uniformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniforms to fetch.
     */
    orderBy?: uniformOrderByWithRelationInput | uniformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing uniforms.
     */
    cursor?: uniformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniforms.
     */
    skip?: number
    distinct?: UniformScalarFieldEnum | UniformScalarFieldEnum[]
  }

  /**
   * uniform create
   */
  export type uniformCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform
     */
    select?: uniformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform
     */
    omit?: uniformOmit<ExtArgs> | null
    /**
     * The data needed to create a uniform.
     */
    data: XOR<uniformCreateInput, uniformUncheckedCreateInput>
  }

  /**
   * uniform createMany
   */
  export type uniformCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many uniforms.
     */
    data: uniformCreateManyInput | uniformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * uniform update
   */
  export type uniformUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform
     */
    select?: uniformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform
     */
    omit?: uniformOmit<ExtArgs> | null
    /**
     * The data needed to update a uniform.
     */
    data: XOR<uniformUpdateInput, uniformUncheckedUpdateInput>
    /**
     * Choose, which uniform to update.
     */
    where: uniformWhereUniqueInput
  }

  /**
   * uniform updateMany
   */
  export type uniformUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update uniforms.
     */
    data: XOR<uniformUpdateManyMutationInput, uniformUncheckedUpdateManyInput>
    /**
     * Filter which uniforms to update
     */
    where?: uniformWhereInput
    /**
     * Limit how many uniforms to update.
     */
    limit?: number
  }

  /**
   * uniform upsert
   */
  export type uniformUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform
     */
    select?: uniformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform
     */
    omit?: uniformOmit<ExtArgs> | null
    /**
     * The filter to search for the uniform to update in case it exists.
     */
    where: uniformWhereUniqueInput
    /**
     * In case the uniform found by the `where` argument doesn't exist, create a new uniform with this data.
     */
    create: XOR<uniformCreateInput, uniformUncheckedCreateInput>
    /**
     * In case the uniform was found with the provided `where` argument, update it with this data.
     */
    update: XOR<uniformUpdateInput, uniformUncheckedUpdateInput>
  }

  /**
   * uniform delete
   */
  export type uniformDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform
     */
    select?: uniformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform
     */
    omit?: uniformOmit<ExtArgs> | null
    /**
     * Filter which uniform to delete.
     */
    where: uniformWhereUniqueInput
  }

  /**
   * uniform deleteMany
   */
  export type uniformDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which uniforms to delete
     */
    where?: uniformWhereInput
    /**
     * Limit how many uniforms to delete.
     */
    limit?: number
  }

  /**
   * uniform without action
   */
  export type uniformDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform
     */
    select?: uniformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform
     */
    omit?: uniformOmit<ExtArgs> | null
  }


  /**
   * Model uniform_inventory
   */

  export type AggregateUniform_inventory = {
    _count: Uniform_inventoryCountAggregateOutputType | null
    _avg: Uniform_inventoryAvgAggregateOutputType | null
    _sum: Uniform_inventorySumAggregateOutputType | null
    _min: Uniform_inventoryMinAggregateOutputType | null
    _max: Uniform_inventoryMaxAggregateOutputType | null
  }

  export type Uniform_inventoryAvgAggregateOutputType = {
    id: number | null
    qty: number | null
  }

  export type Uniform_inventorySumAggregateOutputType = {
    id: number | null
    qty: number | null
  }

  export type Uniform_inventoryMinAggregateOutputType = {
    id: number | null
    uniform_type_id: string | null
    uniform_size_id: string | null
    qty: number | null
    gender: string | null
    date: Date | null
    user: string | null
  }

  export type Uniform_inventoryMaxAggregateOutputType = {
    id: number | null
    uniform_type_id: string | null
    uniform_size_id: string | null
    qty: number | null
    gender: string | null
    date: Date | null
    user: string | null
  }

  export type Uniform_inventoryCountAggregateOutputType = {
    id: number
    uniform_type_id: number
    uniform_size_id: number
    qty: number
    gender: number
    date: number
    user: number
    _all: number
  }


  export type Uniform_inventoryAvgAggregateInputType = {
    id?: true
    qty?: true
  }

  export type Uniform_inventorySumAggregateInputType = {
    id?: true
    qty?: true
  }

  export type Uniform_inventoryMinAggregateInputType = {
    id?: true
    uniform_type_id?: true
    uniform_size_id?: true
    qty?: true
    gender?: true
    date?: true
    user?: true
  }

  export type Uniform_inventoryMaxAggregateInputType = {
    id?: true
    uniform_type_id?: true
    uniform_size_id?: true
    qty?: true
    gender?: true
    date?: true
    user?: true
  }

  export type Uniform_inventoryCountAggregateInputType = {
    id?: true
    uniform_type_id?: true
    uniform_size_id?: true
    qty?: true
    gender?: true
    date?: true
    user?: true
    _all?: true
  }

  export type Uniform_inventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which uniform_inventory to aggregate.
     */
    where?: uniform_inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_inventories to fetch.
     */
    orderBy?: uniform_inventoryOrderByWithRelationInput | uniform_inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: uniform_inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned uniform_inventories
    **/
    _count?: true | Uniform_inventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Uniform_inventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Uniform_inventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Uniform_inventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Uniform_inventoryMaxAggregateInputType
  }

  export type GetUniform_inventoryAggregateType<T extends Uniform_inventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUniform_inventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniform_inventory[P]>
      : GetScalarType<T[P], AggregateUniform_inventory[P]>
  }




  export type uniform_inventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: uniform_inventoryWhereInput
    orderBy?: uniform_inventoryOrderByWithAggregationInput | uniform_inventoryOrderByWithAggregationInput[]
    by: Uniform_inventoryScalarFieldEnum[] | Uniform_inventoryScalarFieldEnum
    having?: uniform_inventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Uniform_inventoryCountAggregateInputType | true
    _avg?: Uniform_inventoryAvgAggregateInputType
    _sum?: Uniform_inventorySumAggregateInputType
    _min?: Uniform_inventoryMinAggregateInputType
    _max?: Uniform_inventoryMaxAggregateInputType
  }

  export type Uniform_inventoryGroupByOutputType = {
    id: number
    uniform_type_id: string
    uniform_size_id: string
    qty: number
    gender: string
    date: Date
    user: string
    _count: Uniform_inventoryCountAggregateOutputType | null
    _avg: Uniform_inventoryAvgAggregateOutputType | null
    _sum: Uniform_inventorySumAggregateOutputType | null
    _min: Uniform_inventoryMinAggregateOutputType | null
    _max: Uniform_inventoryMaxAggregateOutputType | null
  }

  type GetUniform_inventoryGroupByPayload<T extends uniform_inventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Uniform_inventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Uniform_inventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Uniform_inventoryGroupByOutputType[P]>
            : GetScalarType<T[P], Uniform_inventoryGroupByOutputType[P]>
        }
      >
    >


  export type uniform_inventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uniform_type_id?: boolean
    uniform_size_id?: boolean
    qty?: boolean
    gender?: boolean
    date?: boolean
    user?: boolean
  }, ExtArgs["result"]["uniform_inventory"]>



  export type uniform_inventorySelectScalar = {
    id?: boolean
    uniform_type_id?: boolean
    uniform_size_id?: boolean
    qty?: boolean
    gender?: boolean
    date?: boolean
    user?: boolean
  }

  export type uniform_inventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uniform_type_id" | "uniform_size_id" | "qty" | "gender" | "date" | "user", ExtArgs["result"]["uniform_inventory"]>

  export type $uniform_inventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "uniform_inventory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uniform_type_id: string
      uniform_size_id: string
      qty: number
      gender: string
      date: Date
      user: string
    }, ExtArgs["result"]["uniform_inventory"]>
    composites: {}
  }

  type uniform_inventoryGetPayload<S extends boolean | null | undefined | uniform_inventoryDefaultArgs> = $Result.GetResult<Prisma.$uniform_inventoryPayload, S>

  type uniform_inventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<uniform_inventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Uniform_inventoryCountAggregateInputType | true
    }

  export interface uniform_inventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['uniform_inventory'], meta: { name: 'uniform_inventory' } }
    /**
     * Find zero or one Uniform_inventory that matches the filter.
     * @param {uniform_inventoryFindUniqueArgs} args - Arguments to find a Uniform_inventory
     * @example
     * // Get one Uniform_inventory
     * const uniform_inventory = await prisma.uniform_inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends uniform_inventoryFindUniqueArgs>(args: SelectSubset<T, uniform_inventoryFindUniqueArgs<ExtArgs>>): Prisma__uniform_inventoryClient<$Result.GetResult<Prisma.$uniform_inventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Uniform_inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {uniform_inventoryFindUniqueOrThrowArgs} args - Arguments to find a Uniform_inventory
     * @example
     * // Get one Uniform_inventory
     * const uniform_inventory = await prisma.uniform_inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends uniform_inventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, uniform_inventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__uniform_inventoryClient<$Result.GetResult<Prisma.$uniform_inventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Uniform_inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_inventoryFindFirstArgs} args - Arguments to find a Uniform_inventory
     * @example
     * // Get one Uniform_inventory
     * const uniform_inventory = await prisma.uniform_inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends uniform_inventoryFindFirstArgs>(args?: SelectSubset<T, uniform_inventoryFindFirstArgs<ExtArgs>>): Prisma__uniform_inventoryClient<$Result.GetResult<Prisma.$uniform_inventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Uniform_inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_inventoryFindFirstOrThrowArgs} args - Arguments to find a Uniform_inventory
     * @example
     * // Get one Uniform_inventory
     * const uniform_inventory = await prisma.uniform_inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends uniform_inventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, uniform_inventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__uniform_inventoryClient<$Result.GetResult<Prisma.$uniform_inventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Uniform_inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_inventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Uniform_inventories
     * const uniform_inventories = await prisma.uniform_inventory.findMany()
     * 
     * // Get first 10 Uniform_inventories
     * const uniform_inventories = await prisma.uniform_inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uniform_inventoryWithIdOnly = await prisma.uniform_inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends uniform_inventoryFindManyArgs>(args?: SelectSubset<T, uniform_inventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$uniform_inventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Uniform_inventory.
     * @param {uniform_inventoryCreateArgs} args - Arguments to create a Uniform_inventory.
     * @example
     * // Create one Uniform_inventory
     * const Uniform_inventory = await prisma.uniform_inventory.create({
     *   data: {
     *     // ... data to create a Uniform_inventory
     *   }
     * })
     * 
     */
    create<T extends uniform_inventoryCreateArgs>(args: SelectSubset<T, uniform_inventoryCreateArgs<ExtArgs>>): Prisma__uniform_inventoryClient<$Result.GetResult<Prisma.$uniform_inventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Uniform_inventories.
     * @param {uniform_inventoryCreateManyArgs} args - Arguments to create many Uniform_inventories.
     * @example
     * // Create many Uniform_inventories
     * const uniform_inventory = await prisma.uniform_inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends uniform_inventoryCreateManyArgs>(args?: SelectSubset<T, uniform_inventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Uniform_inventory.
     * @param {uniform_inventoryDeleteArgs} args - Arguments to delete one Uniform_inventory.
     * @example
     * // Delete one Uniform_inventory
     * const Uniform_inventory = await prisma.uniform_inventory.delete({
     *   where: {
     *     // ... filter to delete one Uniform_inventory
     *   }
     * })
     * 
     */
    delete<T extends uniform_inventoryDeleteArgs>(args: SelectSubset<T, uniform_inventoryDeleteArgs<ExtArgs>>): Prisma__uniform_inventoryClient<$Result.GetResult<Prisma.$uniform_inventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Uniform_inventory.
     * @param {uniform_inventoryUpdateArgs} args - Arguments to update one Uniform_inventory.
     * @example
     * // Update one Uniform_inventory
     * const uniform_inventory = await prisma.uniform_inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends uniform_inventoryUpdateArgs>(args: SelectSubset<T, uniform_inventoryUpdateArgs<ExtArgs>>): Prisma__uniform_inventoryClient<$Result.GetResult<Prisma.$uniform_inventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Uniform_inventories.
     * @param {uniform_inventoryDeleteManyArgs} args - Arguments to filter Uniform_inventories to delete.
     * @example
     * // Delete a few Uniform_inventories
     * const { count } = await prisma.uniform_inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends uniform_inventoryDeleteManyArgs>(args?: SelectSubset<T, uniform_inventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uniform_inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_inventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Uniform_inventories
     * const uniform_inventory = await prisma.uniform_inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends uniform_inventoryUpdateManyArgs>(args: SelectSubset<T, uniform_inventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Uniform_inventory.
     * @param {uniform_inventoryUpsertArgs} args - Arguments to update or create a Uniform_inventory.
     * @example
     * // Update or create a Uniform_inventory
     * const uniform_inventory = await prisma.uniform_inventory.upsert({
     *   create: {
     *     // ... data to create a Uniform_inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Uniform_inventory we want to update
     *   }
     * })
     */
    upsert<T extends uniform_inventoryUpsertArgs>(args: SelectSubset<T, uniform_inventoryUpsertArgs<ExtArgs>>): Prisma__uniform_inventoryClient<$Result.GetResult<Prisma.$uniform_inventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Uniform_inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_inventoryCountArgs} args - Arguments to filter Uniform_inventories to count.
     * @example
     * // Count the number of Uniform_inventories
     * const count = await prisma.uniform_inventory.count({
     *   where: {
     *     // ... the filter for the Uniform_inventories we want to count
     *   }
     * })
    **/
    count<T extends uniform_inventoryCountArgs>(
      args?: Subset<T, uniform_inventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Uniform_inventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Uniform_inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Uniform_inventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Uniform_inventoryAggregateArgs>(args: Subset<T, Uniform_inventoryAggregateArgs>): Prisma.PrismaPromise<GetUniform_inventoryAggregateType<T>>

    /**
     * Group by Uniform_inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_inventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends uniform_inventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: uniform_inventoryGroupByArgs['orderBy'] }
        : { orderBy?: uniform_inventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, uniform_inventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniform_inventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the uniform_inventory model
   */
  readonly fields: uniform_inventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for uniform_inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__uniform_inventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the uniform_inventory model
   */
  interface uniform_inventoryFieldRefs {
    readonly id: FieldRef<"uniform_inventory", 'Int'>
    readonly uniform_type_id: FieldRef<"uniform_inventory", 'String'>
    readonly uniform_size_id: FieldRef<"uniform_inventory", 'String'>
    readonly qty: FieldRef<"uniform_inventory", 'Int'>
    readonly gender: FieldRef<"uniform_inventory", 'String'>
    readonly date: FieldRef<"uniform_inventory", 'DateTime'>
    readonly user: FieldRef<"uniform_inventory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * uniform_inventory findUnique
   */
  export type uniform_inventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_inventory
     */
    select?: uniform_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_inventory
     */
    omit?: uniform_inventoryOmit<ExtArgs> | null
    /**
     * Filter, which uniform_inventory to fetch.
     */
    where: uniform_inventoryWhereUniqueInput
  }

  /**
   * uniform_inventory findUniqueOrThrow
   */
  export type uniform_inventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_inventory
     */
    select?: uniform_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_inventory
     */
    omit?: uniform_inventoryOmit<ExtArgs> | null
    /**
     * Filter, which uniform_inventory to fetch.
     */
    where: uniform_inventoryWhereUniqueInput
  }

  /**
   * uniform_inventory findFirst
   */
  export type uniform_inventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_inventory
     */
    select?: uniform_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_inventory
     */
    omit?: uniform_inventoryOmit<ExtArgs> | null
    /**
     * Filter, which uniform_inventory to fetch.
     */
    where?: uniform_inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_inventories to fetch.
     */
    orderBy?: uniform_inventoryOrderByWithRelationInput | uniform_inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for uniform_inventories.
     */
    cursor?: uniform_inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of uniform_inventories.
     */
    distinct?: Uniform_inventoryScalarFieldEnum | Uniform_inventoryScalarFieldEnum[]
  }

  /**
   * uniform_inventory findFirstOrThrow
   */
  export type uniform_inventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_inventory
     */
    select?: uniform_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_inventory
     */
    omit?: uniform_inventoryOmit<ExtArgs> | null
    /**
     * Filter, which uniform_inventory to fetch.
     */
    where?: uniform_inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_inventories to fetch.
     */
    orderBy?: uniform_inventoryOrderByWithRelationInput | uniform_inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for uniform_inventories.
     */
    cursor?: uniform_inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of uniform_inventories.
     */
    distinct?: Uniform_inventoryScalarFieldEnum | Uniform_inventoryScalarFieldEnum[]
  }

  /**
   * uniform_inventory findMany
   */
  export type uniform_inventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_inventory
     */
    select?: uniform_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_inventory
     */
    omit?: uniform_inventoryOmit<ExtArgs> | null
    /**
     * Filter, which uniform_inventories to fetch.
     */
    where?: uniform_inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_inventories to fetch.
     */
    orderBy?: uniform_inventoryOrderByWithRelationInput | uniform_inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing uniform_inventories.
     */
    cursor?: uniform_inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_inventories.
     */
    skip?: number
    distinct?: Uniform_inventoryScalarFieldEnum | Uniform_inventoryScalarFieldEnum[]
  }

  /**
   * uniform_inventory create
   */
  export type uniform_inventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_inventory
     */
    select?: uniform_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_inventory
     */
    omit?: uniform_inventoryOmit<ExtArgs> | null
    /**
     * The data needed to create a uniform_inventory.
     */
    data: XOR<uniform_inventoryCreateInput, uniform_inventoryUncheckedCreateInput>
  }

  /**
   * uniform_inventory createMany
   */
  export type uniform_inventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many uniform_inventories.
     */
    data: uniform_inventoryCreateManyInput | uniform_inventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * uniform_inventory update
   */
  export type uniform_inventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_inventory
     */
    select?: uniform_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_inventory
     */
    omit?: uniform_inventoryOmit<ExtArgs> | null
    /**
     * The data needed to update a uniform_inventory.
     */
    data: XOR<uniform_inventoryUpdateInput, uniform_inventoryUncheckedUpdateInput>
    /**
     * Choose, which uniform_inventory to update.
     */
    where: uniform_inventoryWhereUniqueInput
  }

  /**
   * uniform_inventory updateMany
   */
  export type uniform_inventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update uniform_inventories.
     */
    data: XOR<uniform_inventoryUpdateManyMutationInput, uniform_inventoryUncheckedUpdateManyInput>
    /**
     * Filter which uniform_inventories to update
     */
    where?: uniform_inventoryWhereInput
    /**
     * Limit how many uniform_inventories to update.
     */
    limit?: number
  }

  /**
   * uniform_inventory upsert
   */
  export type uniform_inventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_inventory
     */
    select?: uniform_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_inventory
     */
    omit?: uniform_inventoryOmit<ExtArgs> | null
    /**
     * The filter to search for the uniform_inventory to update in case it exists.
     */
    where: uniform_inventoryWhereUniqueInput
    /**
     * In case the uniform_inventory found by the `where` argument doesn't exist, create a new uniform_inventory with this data.
     */
    create: XOR<uniform_inventoryCreateInput, uniform_inventoryUncheckedCreateInput>
    /**
     * In case the uniform_inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<uniform_inventoryUpdateInput, uniform_inventoryUncheckedUpdateInput>
  }

  /**
   * uniform_inventory delete
   */
  export type uniform_inventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_inventory
     */
    select?: uniform_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_inventory
     */
    omit?: uniform_inventoryOmit<ExtArgs> | null
    /**
     * Filter which uniform_inventory to delete.
     */
    where: uniform_inventoryWhereUniqueInput
  }

  /**
   * uniform_inventory deleteMany
   */
  export type uniform_inventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which uniform_inventories to delete
     */
    where?: uniform_inventoryWhereInput
    /**
     * Limit how many uniform_inventories to delete.
     */
    limit?: number
  }

  /**
   * uniform_inventory without action
   */
  export type uniform_inventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_inventory
     */
    select?: uniform_inventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_inventory
     */
    omit?: uniform_inventoryOmit<ExtArgs> | null
  }


  /**
   * Model uniform_issued
   */

  export type AggregateUniform_issued = {
    _count: Uniform_issuedCountAggregateOutputType | null
    _avg: Uniform_issuedAvgAggregateOutputType | null
    _sum: Uniform_issuedSumAggregateOutputType | null
    _min: Uniform_issuedMinAggregateOutputType | null
    _max: Uniform_issuedMaxAggregateOutputType | null
  }

  export type Uniform_issuedAvgAggregateOutputType = {
    id: number | null
  }

  export type Uniform_issuedSumAggregateOutputType = {
    id: number | null
  }

  export type Uniform_issuedMinAggregateOutputType = {
    id: number | null
    rfid: string | null
    releasedby: string | null
    uniform_type_id: string | null
    uniform_size_id: string | null
    date: Date | null
  }

  export type Uniform_issuedMaxAggregateOutputType = {
    id: number | null
    rfid: string | null
    releasedby: string | null
    uniform_type_id: string | null
    uniform_size_id: string | null
    date: Date | null
  }

  export type Uniform_issuedCountAggregateOutputType = {
    id: number
    rfid: number
    releasedby: number
    uniform_type_id: number
    uniform_size_id: number
    date: number
    _all: number
  }


  export type Uniform_issuedAvgAggregateInputType = {
    id?: true
  }

  export type Uniform_issuedSumAggregateInputType = {
    id?: true
  }

  export type Uniform_issuedMinAggregateInputType = {
    id?: true
    rfid?: true
    releasedby?: true
    uniform_type_id?: true
    uniform_size_id?: true
    date?: true
  }

  export type Uniform_issuedMaxAggregateInputType = {
    id?: true
    rfid?: true
    releasedby?: true
    uniform_type_id?: true
    uniform_size_id?: true
    date?: true
  }

  export type Uniform_issuedCountAggregateInputType = {
    id?: true
    rfid?: true
    releasedby?: true
    uniform_type_id?: true
    uniform_size_id?: true
    date?: true
    _all?: true
  }

  export type Uniform_issuedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which uniform_issued to aggregate.
     */
    where?: uniform_issuedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_issueds to fetch.
     */
    orderBy?: uniform_issuedOrderByWithRelationInput | uniform_issuedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: uniform_issuedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_issueds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_issueds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned uniform_issueds
    **/
    _count?: true | Uniform_issuedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Uniform_issuedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Uniform_issuedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Uniform_issuedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Uniform_issuedMaxAggregateInputType
  }

  export type GetUniform_issuedAggregateType<T extends Uniform_issuedAggregateArgs> = {
        [P in keyof T & keyof AggregateUniform_issued]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniform_issued[P]>
      : GetScalarType<T[P], AggregateUniform_issued[P]>
  }




  export type uniform_issuedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: uniform_issuedWhereInput
    orderBy?: uniform_issuedOrderByWithAggregationInput | uniform_issuedOrderByWithAggregationInput[]
    by: Uniform_issuedScalarFieldEnum[] | Uniform_issuedScalarFieldEnum
    having?: uniform_issuedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Uniform_issuedCountAggregateInputType | true
    _avg?: Uniform_issuedAvgAggregateInputType
    _sum?: Uniform_issuedSumAggregateInputType
    _min?: Uniform_issuedMinAggregateInputType
    _max?: Uniform_issuedMaxAggregateInputType
  }

  export type Uniform_issuedGroupByOutputType = {
    id: number
    rfid: string
    releasedby: string
    uniform_type_id: string
    uniform_size_id: string
    date: Date
    _count: Uniform_issuedCountAggregateOutputType | null
    _avg: Uniform_issuedAvgAggregateOutputType | null
    _sum: Uniform_issuedSumAggregateOutputType | null
    _min: Uniform_issuedMinAggregateOutputType | null
    _max: Uniform_issuedMaxAggregateOutputType | null
  }

  type GetUniform_issuedGroupByPayload<T extends uniform_issuedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Uniform_issuedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Uniform_issuedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Uniform_issuedGroupByOutputType[P]>
            : GetScalarType<T[P], Uniform_issuedGroupByOutputType[P]>
        }
      >
    >


  export type uniform_issuedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfid?: boolean
    releasedby?: boolean
    uniform_type_id?: boolean
    uniform_size_id?: boolean
    date?: boolean
  }, ExtArgs["result"]["uniform_issued"]>



  export type uniform_issuedSelectScalar = {
    id?: boolean
    rfid?: boolean
    releasedby?: boolean
    uniform_type_id?: boolean
    uniform_size_id?: boolean
    date?: boolean
  }

  export type uniform_issuedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rfid" | "releasedby" | "uniform_type_id" | "uniform_size_id" | "date", ExtArgs["result"]["uniform_issued"]>

  export type $uniform_issuedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "uniform_issued"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rfid: string
      releasedby: string
      uniform_type_id: string
      uniform_size_id: string
      date: Date
    }, ExtArgs["result"]["uniform_issued"]>
    composites: {}
  }

  type uniform_issuedGetPayload<S extends boolean | null | undefined | uniform_issuedDefaultArgs> = $Result.GetResult<Prisma.$uniform_issuedPayload, S>

  type uniform_issuedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<uniform_issuedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Uniform_issuedCountAggregateInputType | true
    }

  export interface uniform_issuedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['uniform_issued'], meta: { name: 'uniform_issued' } }
    /**
     * Find zero or one Uniform_issued that matches the filter.
     * @param {uniform_issuedFindUniqueArgs} args - Arguments to find a Uniform_issued
     * @example
     * // Get one Uniform_issued
     * const uniform_issued = await prisma.uniform_issued.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends uniform_issuedFindUniqueArgs>(args: SelectSubset<T, uniform_issuedFindUniqueArgs<ExtArgs>>): Prisma__uniform_issuedClient<$Result.GetResult<Prisma.$uniform_issuedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Uniform_issued that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {uniform_issuedFindUniqueOrThrowArgs} args - Arguments to find a Uniform_issued
     * @example
     * // Get one Uniform_issued
     * const uniform_issued = await prisma.uniform_issued.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends uniform_issuedFindUniqueOrThrowArgs>(args: SelectSubset<T, uniform_issuedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__uniform_issuedClient<$Result.GetResult<Prisma.$uniform_issuedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Uniform_issued that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_issuedFindFirstArgs} args - Arguments to find a Uniform_issued
     * @example
     * // Get one Uniform_issued
     * const uniform_issued = await prisma.uniform_issued.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends uniform_issuedFindFirstArgs>(args?: SelectSubset<T, uniform_issuedFindFirstArgs<ExtArgs>>): Prisma__uniform_issuedClient<$Result.GetResult<Prisma.$uniform_issuedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Uniform_issued that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_issuedFindFirstOrThrowArgs} args - Arguments to find a Uniform_issued
     * @example
     * // Get one Uniform_issued
     * const uniform_issued = await prisma.uniform_issued.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends uniform_issuedFindFirstOrThrowArgs>(args?: SelectSubset<T, uniform_issuedFindFirstOrThrowArgs<ExtArgs>>): Prisma__uniform_issuedClient<$Result.GetResult<Prisma.$uniform_issuedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Uniform_issueds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_issuedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Uniform_issueds
     * const uniform_issueds = await prisma.uniform_issued.findMany()
     * 
     * // Get first 10 Uniform_issueds
     * const uniform_issueds = await prisma.uniform_issued.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uniform_issuedWithIdOnly = await prisma.uniform_issued.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends uniform_issuedFindManyArgs>(args?: SelectSubset<T, uniform_issuedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$uniform_issuedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Uniform_issued.
     * @param {uniform_issuedCreateArgs} args - Arguments to create a Uniform_issued.
     * @example
     * // Create one Uniform_issued
     * const Uniform_issued = await prisma.uniform_issued.create({
     *   data: {
     *     // ... data to create a Uniform_issued
     *   }
     * })
     * 
     */
    create<T extends uniform_issuedCreateArgs>(args: SelectSubset<T, uniform_issuedCreateArgs<ExtArgs>>): Prisma__uniform_issuedClient<$Result.GetResult<Prisma.$uniform_issuedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Uniform_issueds.
     * @param {uniform_issuedCreateManyArgs} args - Arguments to create many Uniform_issueds.
     * @example
     * // Create many Uniform_issueds
     * const uniform_issued = await prisma.uniform_issued.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends uniform_issuedCreateManyArgs>(args?: SelectSubset<T, uniform_issuedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Uniform_issued.
     * @param {uniform_issuedDeleteArgs} args - Arguments to delete one Uniform_issued.
     * @example
     * // Delete one Uniform_issued
     * const Uniform_issued = await prisma.uniform_issued.delete({
     *   where: {
     *     // ... filter to delete one Uniform_issued
     *   }
     * })
     * 
     */
    delete<T extends uniform_issuedDeleteArgs>(args: SelectSubset<T, uniform_issuedDeleteArgs<ExtArgs>>): Prisma__uniform_issuedClient<$Result.GetResult<Prisma.$uniform_issuedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Uniform_issued.
     * @param {uniform_issuedUpdateArgs} args - Arguments to update one Uniform_issued.
     * @example
     * // Update one Uniform_issued
     * const uniform_issued = await prisma.uniform_issued.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends uniform_issuedUpdateArgs>(args: SelectSubset<T, uniform_issuedUpdateArgs<ExtArgs>>): Prisma__uniform_issuedClient<$Result.GetResult<Prisma.$uniform_issuedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Uniform_issueds.
     * @param {uniform_issuedDeleteManyArgs} args - Arguments to filter Uniform_issueds to delete.
     * @example
     * // Delete a few Uniform_issueds
     * const { count } = await prisma.uniform_issued.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends uniform_issuedDeleteManyArgs>(args?: SelectSubset<T, uniform_issuedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uniform_issueds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_issuedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Uniform_issueds
     * const uniform_issued = await prisma.uniform_issued.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends uniform_issuedUpdateManyArgs>(args: SelectSubset<T, uniform_issuedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Uniform_issued.
     * @param {uniform_issuedUpsertArgs} args - Arguments to update or create a Uniform_issued.
     * @example
     * // Update or create a Uniform_issued
     * const uniform_issued = await prisma.uniform_issued.upsert({
     *   create: {
     *     // ... data to create a Uniform_issued
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Uniform_issued we want to update
     *   }
     * })
     */
    upsert<T extends uniform_issuedUpsertArgs>(args: SelectSubset<T, uniform_issuedUpsertArgs<ExtArgs>>): Prisma__uniform_issuedClient<$Result.GetResult<Prisma.$uniform_issuedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Uniform_issueds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_issuedCountArgs} args - Arguments to filter Uniform_issueds to count.
     * @example
     * // Count the number of Uniform_issueds
     * const count = await prisma.uniform_issued.count({
     *   where: {
     *     // ... the filter for the Uniform_issueds we want to count
     *   }
     * })
    **/
    count<T extends uniform_issuedCountArgs>(
      args?: Subset<T, uniform_issuedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Uniform_issuedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Uniform_issued.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Uniform_issuedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Uniform_issuedAggregateArgs>(args: Subset<T, Uniform_issuedAggregateArgs>): Prisma.PrismaPromise<GetUniform_issuedAggregateType<T>>

    /**
     * Group by Uniform_issued.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_issuedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends uniform_issuedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: uniform_issuedGroupByArgs['orderBy'] }
        : { orderBy?: uniform_issuedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, uniform_issuedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniform_issuedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the uniform_issued model
   */
  readonly fields: uniform_issuedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for uniform_issued.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__uniform_issuedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the uniform_issued model
   */
  interface uniform_issuedFieldRefs {
    readonly id: FieldRef<"uniform_issued", 'Int'>
    readonly rfid: FieldRef<"uniform_issued", 'String'>
    readonly releasedby: FieldRef<"uniform_issued", 'String'>
    readonly uniform_type_id: FieldRef<"uniform_issued", 'String'>
    readonly uniform_size_id: FieldRef<"uniform_issued", 'String'>
    readonly date: FieldRef<"uniform_issued", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * uniform_issued findUnique
   */
  export type uniform_issuedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_issued
     */
    select?: uniform_issuedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_issued
     */
    omit?: uniform_issuedOmit<ExtArgs> | null
    /**
     * Filter, which uniform_issued to fetch.
     */
    where: uniform_issuedWhereUniqueInput
  }

  /**
   * uniform_issued findUniqueOrThrow
   */
  export type uniform_issuedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_issued
     */
    select?: uniform_issuedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_issued
     */
    omit?: uniform_issuedOmit<ExtArgs> | null
    /**
     * Filter, which uniform_issued to fetch.
     */
    where: uniform_issuedWhereUniqueInput
  }

  /**
   * uniform_issued findFirst
   */
  export type uniform_issuedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_issued
     */
    select?: uniform_issuedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_issued
     */
    omit?: uniform_issuedOmit<ExtArgs> | null
    /**
     * Filter, which uniform_issued to fetch.
     */
    where?: uniform_issuedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_issueds to fetch.
     */
    orderBy?: uniform_issuedOrderByWithRelationInput | uniform_issuedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for uniform_issueds.
     */
    cursor?: uniform_issuedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_issueds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_issueds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of uniform_issueds.
     */
    distinct?: Uniform_issuedScalarFieldEnum | Uniform_issuedScalarFieldEnum[]
  }

  /**
   * uniform_issued findFirstOrThrow
   */
  export type uniform_issuedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_issued
     */
    select?: uniform_issuedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_issued
     */
    omit?: uniform_issuedOmit<ExtArgs> | null
    /**
     * Filter, which uniform_issued to fetch.
     */
    where?: uniform_issuedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_issueds to fetch.
     */
    orderBy?: uniform_issuedOrderByWithRelationInput | uniform_issuedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for uniform_issueds.
     */
    cursor?: uniform_issuedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_issueds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_issueds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of uniform_issueds.
     */
    distinct?: Uniform_issuedScalarFieldEnum | Uniform_issuedScalarFieldEnum[]
  }

  /**
   * uniform_issued findMany
   */
  export type uniform_issuedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_issued
     */
    select?: uniform_issuedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_issued
     */
    omit?: uniform_issuedOmit<ExtArgs> | null
    /**
     * Filter, which uniform_issueds to fetch.
     */
    where?: uniform_issuedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_issueds to fetch.
     */
    orderBy?: uniform_issuedOrderByWithRelationInput | uniform_issuedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing uniform_issueds.
     */
    cursor?: uniform_issuedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_issueds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_issueds.
     */
    skip?: number
    distinct?: Uniform_issuedScalarFieldEnum | Uniform_issuedScalarFieldEnum[]
  }

  /**
   * uniform_issued create
   */
  export type uniform_issuedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_issued
     */
    select?: uniform_issuedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_issued
     */
    omit?: uniform_issuedOmit<ExtArgs> | null
    /**
     * The data needed to create a uniform_issued.
     */
    data: XOR<uniform_issuedCreateInput, uniform_issuedUncheckedCreateInput>
  }

  /**
   * uniform_issued createMany
   */
  export type uniform_issuedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many uniform_issueds.
     */
    data: uniform_issuedCreateManyInput | uniform_issuedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * uniform_issued update
   */
  export type uniform_issuedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_issued
     */
    select?: uniform_issuedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_issued
     */
    omit?: uniform_issuedOmit<ExtArgs> | null
    /**
     * The data needed to update a uniform_issued.
     */
    data: XOR<uniform_issuedUpdateInput, uniform_issuedUncheckedUpdateInput>
    /**
     * Choose, which uniform_issued to update.
     */
    where: uniform_issuedWhereUniqueInput
  }

  /**
   * uniform_issued updateMany
   */
  export type uniform_issuedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update uniform_issueds.
     */
    data: XOR<uniform_issuedUpdateManyMutationInput, uniform_issuedUncheckedUpdateManyInput>
    /**
     * Filter which uniform_issueds to update
     */
    where?: uniform_issuedWhereInput
    /**
     * Limit how many uniform_issueds to update.
     */
    limit?: number
  }

  /**
   * uniform_issued upsert
   */
  export type uniform_issuedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_issued
     */
    select?: uniform_issuedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_issued
     */
    omit?: uniform_issuedOmit<ExtArgs> | null
    /**
     * The filter to search for the uniform_issued to update in case it exists.
     */
    where: uniform_issuedWhereUniqueInput
    /**
     * In case the uniform_issued found by the `where` argument doesn't exist, create a new uniform_issued with this data.
     */
    create: XOR<uniform_issuedCreateInput, uniform_issuedUncheckedCreateInput>
    /**
     * In case the uniform_issued was found with the provided `where` argument, update it with this data.
     */
    update: XOR<uniform_issuedUpdateInput, uniform_issuedUncheckedUpdateInput>
  }

  /**
   * uniform_issued delete
   */
  export type uniform_issuedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_issued
     */
    select?: uniform_issuedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_issued
     */
    omit?: uniform_issuedOmit<ExtArgs> | null
    /**
     * Filter which uniform_issued to delete.
     */
    where: uniform_issuedWhereUniqueInput
  }

  /**
   * uniform_issued deleteMany
   */
  export type uniform_issuedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which uniform_issueds to delete
     */
    where?: uniform_issuedWhereInput
    /**
     * Limit how many uniform_issueds to delete.
     */
    limit?: number
  }

  /**
   * uniform_issued without action
   */
  export type uniform_issuedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_issued
     */
    select?: uniform_issuedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_issued
     */
    omit?: uniform_issuedOmit<ExtArgs> | null
  }


  /**
   * Model uniform_sizes
   */

  export type AggregateUniform_sizes = {
    _count: Uniform_sizesCountAggregateOutputType | null
    _avg: Uniform_sizesAvgAggregateOutputType | null
    _sum: Uniform_sizesSumAggregateOutputType | null
    _min: Uniform_sizesMinAggregateOutputType | null
    _max: Uniform_sizesMaxAggregateOutputType | null
  }

  export type Uniform_sizesAvgAggregateOutputType = {
    id: number | null
  }

  export type Uniform_sizesSumAggregateOutputType = {
    id: number | null
  }

  export type Uniform_sizesMinAggregateOutputType = {
    id: number | null
    size: string | null
    created_at: Date | null
  }

  export type Uniform_sizesMaxAggregateOutputType = {
    id: number | null
    size: string | null
    created_at: Date | null
  }

  export type Uniform_sizesCountAggregateOutputType = {
    id: number
    size: number
    created_at: number
    _all: number
  }


  export type Uniform_sizesAvgAggregateInputType = {
    id?: true
  }

  export type Uniform_sizesSumAggregateInputType = {
    id?: true
  }

  export type Uniform_sizesMinAggregateInputType = {
    id?: true
    size?: true
    created_at?: true
  }

  export type Uniform_sizesMaxAggregateInputType = {
    id?: true
    size?: true
    created_at?: true
  }

  export type Uniform_sizesCountAggregateInputType = {
    id?: true
    size?: true
    created_at?: true
    _all?: true
  }

  export type Uniform_sizesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which uniform_sizes to aggregate.
     */
    where?: uniform_sizesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_sizes to fetch.
     */
    orderBy?: uniform_sizesOrderByWithRelationInput | uniform_sizesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: uniform_sizesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_sizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned uniform_sizes
    **/
    _count?: true | Uniform_sizesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Uniform_sizesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Uniform_sizesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Uniform_sizesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Uniform_sizesMaxAggregateInputType
  }

  export type GetUniform_sizesAggregateType<T extends Uniform_sizesAggregateArgs> = {
        [P in keyof T & keyof AggregateUniform_sizes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniform_sizes[P]>
      : GetScalarType<T[P], AggregateUniform_sizes[P]>
  }




  export type uniform_sizesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: uniform_sizesWhereInput
    orderBy?: uniform_sizesOrderByWithAggregationInput | uniform_sizesOrderByWithAggregationInput[]
    by: Uniform_sizesScalarFieldEnum[] | Uniform_sizesScalarFieldEnum
    having?: uniform_sizesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Uniform_sizesCountAggregateInputType | true
    _avg?: Uniform_sizesAvgAggregateInputType
    _sum?: Uniform_sizesSumAggregateInputType
    _min?: Uniform_sizesMinAggregateInputType
    _max?: Uniform_sizesMaxAggregateInputType
  }

  export type Uniform_sizesGroupByOutputType = {
    id: number
    size: string
    created_at: Date | null
    _count: Uniform_sizesCountAggregateOutputType | null
    _avg: Uniform_sizesAvgAggregateOutputType | null
    _sum: Uniform_sizesSumAggregateOutputType | null
    _min: Uniform_sizesMinAggregateOutputType | null
    _max: Uniform_sizesMaxAggregateOutputType | null
  }

  type GetUniform_sizesGroupByPayload<T extends uniform_sizesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Uniform_sizesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Uniform_sizesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Uniform_sizesGroupByOutputType[P]>
            : GetScalarType<T[P], Uniform_sizesGroupByOutputType[P]>
        }
      >
    >


  export type uniform_sizesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    size?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["uniform_sizes"]>



  export type uniform_sizesSelectScalar = {
    id?: boolean
    size?: boolean
    created_at?: boolean
  }

  export type uniform_sizesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "size" | "created_at", ExtArgs["result"]["uniform_sizes"]>

  export type $uniform_sizesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "uniform_sizes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      size: string
      created_at: Date | null
    }, ExtArgs["result"]["uniform_sizes"]>
    composites: {}
  }

  type uniform_sizesGetPayload<S extends boolean | null | undefined | uniform_sizesDefaultArgs> = $Result.GetResult<Prisma.$uniform_sizesPayload, S>

  type uniform_sizesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<uniform_sizesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Uniform_sizesCountAggregateInputType | true
    }

  export interface uniform_sizesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['uniform_sizes'], meta: { name: 'uniform_sizes' } }
    /**
     * Find zero or one Uniform_sizes that matches the filter.
     * @param {uniform_sizesFindUniqueArgs} args - Arguments to find a Uniform_sizes
     * @example
     * // Get one Uniform_sizes
     * const uniform_sizes = await prisma.uniform_sizes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends uniform_sizesFindUniqueArgs>(args: SelectSubset<T, uniform_sizesFindUniqueArgs<ExtArgs>>): Prisma__uniform_sizesClient<$Result.GetResult<Prisma.$uniform_sizesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Uniform_sizes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {uniform_sizesFindUniqueOrThrowArgs} args - Arguments to find a Uniform_sizes
     * @example
     * // Get one Uniform_sizes
     * const uniform_sizes = await prisma.uniform_sizes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends uniform_sizesFindUniqueOrThrowArgs>(args: SelectSubset<T, uniform_sizesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__uniform_sizesClient<$Result.GetResult<Prisma.$uniform_sizesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Uniform_sizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_sizesFindFirstArgs} args - Arguments to find a Uniform_sizes
     * @example
     * // Get one Uniform_sizes
     * const uniform_sizes = await prisma.uniform_sizes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends uniform_sizesFindFirstArgs>(args?: SelectSubset<T, uniform_sizesFindFirstArgs<ExtArgs>>): Prisma__uniform_sizesClient<$Result.GetResult<Prisma.$uniform_sizesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Uniform_sizes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_sizesFindFirstOrThrowArgs} args - Arguments to find a Uniform_sizes
     * @example
     * // Get one Uniform_sizes
     * const uniform_sizes = await prisma.uniform_sizes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends uniform_sizesFindFirstOrThrowArgs>(args?: SelectSubset<T, uniform_sizesFindFirstOrThrowArgs<ExtArgs>>): Prisma__uniform_sizesClient<$Result.GetResult<Prisma.$uniform_sizesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Uniform_sizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_sizesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Uniform_sizes
     * const uniform_sizes = await prisma.uniform_sizes.findMany()
     * 
     * // Get first 10 Uniform_sizes
     * const uniform_sizes = await prisma.uniform_sizes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uniform_sizesWithIdOnly = await prisma.uniform_sizes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends uniform_sizesFindManyArgs>(args?: SelectSubset<T, uniform_sizesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$uniform_sizesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Uniform_sizes.
     * @param {uniform_sizesCreateArgs} args - Arguments to create a Uniform_sizes.
     * @example
     * // Create one Uniform_sizes
     * const Uniform_sizes = await prisma.uniform_sizes.create({
     *   data: {
     *     // ... data to create a Uniform_sizes
     *   }
     * })
     * 
     */
    create<T extends uniform_sizesCreateArgs>(args: SelectSubset<T, uniform_sizesCreateArgs<ExtArgs>>): Prisma__uniform_sizesClient<$Result.GetResult<Prisma.$uniform_sizesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Uniform_sizes.
     * @param {uniform_sizesCreateManyArgs} args - Arguments to create many Uniform_sizes.
     * @example
     * // Create many Uniform_sizes
     * const uniform_sizes = await prisma.uniform_sizes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends uniform_sizesCreateManyArgs>(args?: SelectSubset<T, uniform_sizesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Uniform_sizes.
     * @param {uniform_sizesDeleteArgs} args - Arguments to delete one Uniform_sizes.
     * @example
     * // Delete one Uniform_sizes
     * const Uniform_sizes = await prisma.uniform_sizes.delete({
     *   where: {
     *     // ... filter to delete one Uniform_sizes
     *   }
     * })
     * 
     */
    delete<T extends uniform_sizesDeleteArgs>(args: SelectSubset<T, uniform_sizesDeleteArgs<ExtArgs>>): Prisma__uniform_sizesClient<$Result.GetResult<Prisma.$uniform_sizesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Uniform_sizes.
     * @param {uniform_sizesUpdateArgs} args - Arguments to update one Uniform_sizes.
     * @example
     * // Update one Uniform_sizes
     * const uniform_sizes = await prisma.uniform_sizes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends uniform_sizesUpdateArgs>(args: SelectSubset<T, uniform_sizesUpdateArgs<ExtArgs>>): Prisma__uniform_sizesClient<$Result.GetResult<Prisma.$uniform_sizesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Uniform_sizes.
     * @param {uniform_sizesDeleteManyArgs} args - Arguments to filter Uniform_sizes to delete.
     * @example
     * // Delete a few Uniform_sizes
     * const { count } = await prisma.uniform_sizes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends uniform_sizesDeleteManyArgs>(args?: SelectSubset<T, uniform_sizesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uniform_sizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_sizesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Uniform_sizes
     * const uniform_sizes = await prisma.uniform_sizes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends uniform_sizesUpdateManyArgs>(args: SelectSubset<T, uniform_sizesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Uniform_sizes.
     * @param {uniform_sizesUpsertArgs} args - Arguments to update or create a Uniform_sizes.
     * @example
     * // Update or create a Uniform_sizes
     * const uniform_sizes = await prisma.uniform_sizes.upsert({
     *   create: {
     *     // ... data to create a Uniform_sizes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Uniform_sizes we want to update
     *   }
     * })
     */
    upsert<T extends uniform_sizesUpsertArgs>(args: SelectSubset<T, uniform_sizesUpsertArgs<ExtArgs>>): Prisma__uniform_sizesClient<$Result.GetResult<Prisma.$uniform_sizesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Uniform_sizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_sizesCountArgs} args - Arguments to filter Uniform_sizes to count.
     * @example
     * // Count the number of Uniform_sizes
     * const count = await prisma.uniform_sizes.count({
     *   where: {
     *     // ... the filter for the Uniform_sizes we want to count
     *   }
     * })
    **/
    count<T extends uniform_sizesCountArgs>(
      args?: Subset<T, uniform_sizesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Uniform_sizesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Uniform_sizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Uniform_sizesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Uniform_sizesAggregateArgs>(args: Subset<T, Uniform_sizesAggregateArgs>): Prisma.PrismaPromise<GetUniform_sizesAggregateType<T>>

    /**
     * Group by Uniform_sizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_sizesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends uniform_sizesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: uniform_sizesGroupByArgs['orderBy'] }
        : { orderBy?: uniform_sizesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, uniform_sizesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniform_sizesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the uniform_sizes model
   */
  readonly fields: uniform_sizesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for uniform_sizes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__uniform_sizesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the uniform_sizes model
   */
  interface uniform_sizesFieldRefs {
    readonly id: FieldRef<"uniform_sizes", 'Int'>
    readonly size: FieldRef<"uniform_sizes", 'String'>
    readonly created_at: FieldRef<"uniform_sizes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * uniform_sizes findUnique
   */
  export type uniform_sizesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_sizes
     */
    select?: uniform_sizesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_sizes
     */
    omit?: uniform_sizesOmit<ExtArgs> | null
    /**
     * Filter, which uniform_sizes to fetch.
     */
    where: uniform_sizesWhereUniqueInput
  }

  /**
   * uniform_sizes findUniqueOrThrow
   */
  export type uniform_sizesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_sizes
     */
    select?: uniform_sizesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_sizes
     */
    omit?: uniform_sizesOmit<ExtArgs> | null
    /**
     * Filter, which uniform_sizes to fetch.
     */
    where: uniform_sizesWhereUniqueInput
  }

  /**
   * uniform_sizes findFirst
   */
  export type uniform_sizesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_sizes
     */
    select?: uniform_sizesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_sizes
     */
    omit?: uniform_sizesOmit<ExtArgs> | null
    /**
     * Filter, which uniform_sizes to fetch.
     */
    where?: uniform_sizesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_sizes to fetch.
     */
    orderBy?: uniform_sizesOrderByWithRelationInput | uniform_sizesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for uniform_sizes.
     */
    cursor?: uniform_sizesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_sizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of uniform_sizes.
     */
    distinct?: Uniform_sizesScalarFieldEnum | Uniform_sizesScalarFieldEnum[]
  }

  /**
   * uniform_sizes findFirstOrThrow
   */
  export type uniform_sizesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_sizes
     */
    select?: uniform_sizesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_sizes
     */
    omit?: uniform_sizesOmit<ExtArgs> | null
    /**
     * Filter, which uniform_sizes to fetch.
     */
    where?: uniform_sizesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_sizes to fetch.
     */
    orderBy?: uniform_sizesOrderByWithRelationInput | uniform_sizesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for uniform_sizes.
     */
    cursor?: uniform_sizesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_sizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of uniform_sizes.
     */
    distinct?: Uniform_sizesScalarFieldEnum | Uniform_sizesScalarFieldEnum[]
  }

  /**
   * uniform_sizes findMany
   */
  export type uniform_sizesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_sizes
     */
    select?: uniform_sizesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_sizes
     */
    omit?: uniform_sizesOmit<ExtArgs> | null
    /**
     * Filter, which uniform_sizes to fetch.
     */
    where?: uniform_sizesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_sizes to fetch.
     */
    orderBy?: uniform_sizesOrderByWithRelationInput | uniform_sizesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing uniform_sizes.
     */
    cursor?: uniform_sizesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_sizes.
     */
    skip?: number
    distinct?: Uniform_sizesScalarFieldEnum | Uniform_sizesScalarFieldEnum[]
  }

  /**
   * uniform_sizes create
   */
  export type uniform_sizesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_sizes
     */
    select?: uniform_sizesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_sizes
     */
    omit?: uniform_sizesOmit<ExtArgs> | null
    /**
     * The data needed to create a uniform_sizes.
     */
    data: XOR<uniform_sizesCreateInput, uniform_sizesUncheckedCreateInput>
  }

  /**
   * uniform_sizes createMany
   */
  export type uniform_sizesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many uniform_sizes.
     */
    data: uniform_sizesCreateManyInput | uniform_sizesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * uniform_sizes update
   */
  export type uniform_sizesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_sizes
     */
    select?: uniform_sizesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_sizes
     */
    omit?: uniform_sizesOmit<ExtArgs> | null
    /**
     * The data needed to update a uniform_sizes.
     */
    data: XOR<uniform_sizesUpdateInput, uniform_sizesUncheckedUpdateInput>
    /**
     * Choose, which uniform_sizes to update.
     */
    where: uniform_sizesWhereUniqueInput
  }

  /**
   * uniform_sizes updateMany
   */
  export type uniform_sizesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update uniform_sizes.
     */
    data: XOR<uniform_sizesUpdateManyMutationInput, uniform_sizesUncheckedUpdateManyInput>
    /**
     * Filter which uniform_sizes to update
     */
    where?: uniform_sizesWhereInput
    /**
     * Limit how many uniform_sizes to update.
     */
    limit?: number
  }

  /**
   * uniform_sizes upsert
   */
  export type uniform_sizesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_sizes
     */
    select?: uniform_sizesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_sizes
     */
    omit?: uniform_sizesOmit<ExtArgs> | null
    /**
     * The filter to search for the uniform_sizes to update in case it exists.
     */
    where: uniform_sizesWhereUniqueInput
    /**
     * In case the uniform_sizes found by the `where` argument doesn't exist, create a new uniform_sizes with this data.
     */
    create: XOR<uniform_sizesCreateInput, uniform_sizesUncheckedCreateInput>
    /**
     * In case the uniform_sizes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<uniform_sizesUpdateInput, uniform_sizesUncheckedUpdateInput>
  }

  /**
   * uniform_sizes delete
   */
  export type uniform_sizesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_sizes
     */
    select?: uniform_sizesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_sizes
     */
    omit?: uniform_sizesOmit<ExtArgs> | null
    /**
     * Filter which uniform_sizes to delete.
     */
    where: uniform_sizesWhereUniqueInput
  }

  /**
   * uniform_sizes deleteMany
   */
  export type uniform_sizesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which uniform_sizes to delete
     */
    where?: uniform_sizesWhereInput
    /**
     * Limit how many uniform_sizes to delete.
     */
    limit?: number
  }

  /**
   * uniform_sizes without action
   */
  export type uniform_sizesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_sizes
     */
    select?: uniform_sizesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_sizes
     */
    omit?: uniform_sizesOmit<ExtArgs> | null
  }


  /**
   * Model uniform_types
   */

  export type AggregateUniform_types = {
    _count: Uniform_typesCountAggregateOutputType | null
    _avg: Uniform_typesAvgAggregateOutputType | null
    _sum: Uniform_typesSumAggregateOutputType | null
    _min: Uniform_typesMinAggregateOutputType | null
    _max: Uniform_typesMaxAggregateOutputType | null
  }

  export type Uniform_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Uniform_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Uniform_typesMinAggregateOutputType = {
    id: number | null
    type: string | null
    created_at: Date | null
  }

  export type Uniform_typesMaxAggregateOutputType = {
    id: number | null
    type: string | null
    created_at: Date | null
  }

  export type Uniform_typesCountAggregateOutputType = {
    id: number
    type: number
    created_at: number
    _all: number
  }


  export type Uniform_typesAvgAggregateInputType = {
    id?: true
  }

  export type Uniform_typesSumAggregateInputType = {
    id?: true
  }

  export type Uniform_typesMinAggregateInputType = {
    id?: true
    type?: true
    created_at?: true
  }

  export type Uniform_typesMaxAggregateInputType = {
    id?: true
    type?: true
    created_at?: true
  }

  export type Uniform_typesCountAggregateInputType = {
    id?: true
    type?: true
    created_at?: true
    _all?: true
  }

  export type Uniform_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which uniform_types to aggregate.
     */
    where?: uniform_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_types to fetch.
     */
    orderBy?: uniform_typesOrderByWithRelationInput | uniform_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: uniform_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned uniform_types
    **/
    _count?: true | Uniform_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Uniform_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Uniform_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Uniform_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Uniform_typesMaxAggregateInputType
  }

  export type GetUniform_typesAggregateType<T extends Uniform_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateUniform_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniform_types[P]>
      : GetScalarType<T[P], AggregateUniform_types[P]>
  }




  export type uniform_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: uniform_typesWhereInput
    orderBy?: uniform_typesOrderByWithAggregationInput | uniform_typesOrderByWithAggregationInput[]
    by: Uniform_typesScalarFieldEnum[] | Uniform_typesScalarFieldEnum
    having?: uniform_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Uniform_typesCountAggregateInputType | true
    _avg?: Uniform_typesAvgAggregateInputType
    _sum?: Uniform_typesSumAggregateInputType
    _min?: Uniform_typesMinAggregateInputType
    _max?: Uniform_typesMaxAggregateInputType
  }

  export type Uniform_typesGroupByOutputType = {
    id: number
    type: string
    created_at: Date | null
    _count: Uniform_typesCountAggregateOutputType | null
    _avg: Uniform_typesAvgAggregateOutputType | null
    _sum: Uniform_typesSumAggregateOutputType | null
    _min: Uniform_typesMinAggregateOutputType | null
    _max: Uniform_typesMaxAggregateOutputType | null
  }

  type GetUniform_typesGroupByPayload<T extends uniform_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Uniform_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Uniform_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Uniform_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Uniform_typesGroupByOutputType[P]>
        }
      >
    >


  export type uniform_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["uniform_types"]>



  export type uniform_typesSelectScalar = {
    id?: boolean
    type?: boolean
    created_at?: boolean
  }

  export type uniform_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "created_at", ExtArgs["result"]["uniform_types"]>

  export type $uniform_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "uniform_types"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      created_at: Date | null
    }, ExtArgs["result"]["uniform_types"]>
    composites: {}
  }

  type uniform_typesGetPayload<S extends boolean | null | undefined | uniform_typesDefaultArgs> = $Result.GetResult<Prisma.$uniform_typesPayload, S>

  type uniform_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<uniform_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Uniform_typesCountAggregateInputType | true
    }

  export interface uniform_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['uniform_types'], meta: { name: 'uniform_types' } }
    /**
     * Find zero or one Uniform_types that matches the filter.
     * @param {uniform_typesFindUniqueArgs} args - Arguments to find a Uniform_types
     * @example
     * // Get one Uniform_types
     * const uniform_types = await prisma.uniform_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends uniform_typesFindUniqueArgs>(args: SelectSubset<T, uniform_typesFindUniqueArgs<ExtArgs>>): Prisma__uniform_typesClient<$Result.GetResult<Prisma.$uniform_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Uniform_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {uniform_typesFindUniqueOrThrowArgs} args - Arguments to find a Uniform_types
     * @example
     * // Get one Uniform_types
     * const uniform_types = await prisma.uniform_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends uniform_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, uniform_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__uniform_typesClient<$Result.GetResult<Prisma.$uniform_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Uniform_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_typesFindFirstArgs} args - Arguments to find a Uniform_types
     * @example
     * // Get one Uniform_types
     * const uniform_types = await prisma.uniform_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends uniform_typesFindFirstArgs>(args?: SelectSubset<T, uniform_typesFindFirstArgs<ExtArgs>>): Prisma__uniform_typesClient<$Result.GetResult<Prisma.$uniform_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Uniform_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_typesFindFirstOrThrowArgs} args - Arguments to find a Uniform_types
     * @example
     * // Get one Uniform_types
     * const uniform_types = await prisma.uniform_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends uniform_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, uniform_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__uniform_typesClient<$Result.GetResult<Prisma.$uniform_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Uniform_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Uniform_types
     * const uniform_types = await prisma.uniform_types.findMany()
     * 
     * // Get first 10 Uniform_types
     * const uniform_types = await prisma.uniform_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uniform_typesWithIdOnly = await prisma.uniform_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends uniform_typesFindManyArgs>(args?: SelectSubset<T, uniform_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$uniform_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Uniform_types.
     * @param {uniform_typesCreateArgs} args - Arguments to create a Uniform_types.
     * @example
     * // Create one Uniform_types
     * const Uniform_types = await prisma.uniform_types.create({
     *   data: {
     *     // ... data to create a Uniform_types
     *   }
     * })
     * 
     */
    create<T extends uniform_typesCreateArgs>(args: SelectSubset<T, uniform_typesCreateArgs<ExtArgs>>): Prisma__uniform_typesClient<$Result.GetResult<Prisma.$uniform_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Uniform_types.
     * @param {uniform_typesCreateManyArgs} args - Arguments to create many Uniform_types.
     * @example
     * // Create many Uniform_types
     * const uniform_types = await prisma.uniform_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends uniform_typesCreateManyArgs>(args?: SelectSubset<T, uniform_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Uniform_types.
     * @param {uniform_typesDeleteArgs} args - Arguments to delete one Uniform_types.
     * @example
     * // Delete one Uniform_types
     * const Uniform_types = await prisma.uniform_types.delete({
     *   where: {
     *     // ... filter to delete one Uniform_types
     *   }
     * })
     * 
     */
    delete<T extends uniform_typesDeleteArgs>(args: SelectSubset<T, uniform_typesDeleteArgs<ExtArgs>>): Prisma__uniform_typesClient<$Result.GetResult<Prisma.$uniform_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Uniform_types.
     * @param {uniform_typesUpdateArgs} args - Arguments to update one Uniform_types.
     * @example
     * // Update one Uniform_types
     * const uniform_types = await prisma.uniform_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends uniform_typesUpdateArgs>(args: SelectSubset<T, uniform_typesUpdateArgs<ExtArgs>>): Prisma__uniform_typesClient<$Result.GetResult<Prisma.$uniform_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Uniform_types.
     * @param {uniform_typesDeleteManyArgs} args - Arguments to filter Uniform_types to delete.
     * @example
     * // Delete a few Uniform_types
     * const { count } = await prisma.uniform_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends uniform_typesDeleteManyArgs>(args?: SelectSubset<T, uniform_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uniform_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Uniform_types
     * const uniform_types = await prisma.uniform_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends uniform_typesUpdateManyArgs>(args: SelectSubset<T, uniform_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Uniform_types.
     * @param {uniform_typesUpsertArgs} args - Arguments to update or create a Uniform_types.
     * @example
     * // Update or create a Uniform_types
     * const uniform_types = await prisma.uniform_types.upsert({
     *   create: {
     *     // ... data to create a Uniform_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Uniform_types we want to update
     *   }
     * })
     */
    upsert<T extends uniform_typesUpsertArgs>(args: SelectSubset<T, uniform_typesUpsertArgs<ExtArgs>>): Prisma__uniform_typesClient<$Result.GetResult<Prisma.$uniform_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Uniform_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_typesCountArgs} args - Arguments to filter Uniform_types to count.
     * @example
     * // Count the number of Uniform_types
     * const count = await prisma.uniform_types.count({
     *   where: {
     *     // ... the filter for the Uniform_types we want to count
     *   }
     * })
    **/
    count<T extends uniform_typesCountArgs>(
      args?: Subset<T, uniform_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Uniform_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Uniform_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Uniform_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Uniform_typesAggregateArgs>(args: Subset<T, Uniform_typesAggregateArgs>): Prisma.PrismaPromise<GetUniform_typesAggregateType<T>>

    /**
     * Group by Uniform_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {uniform_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends uniform_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: uniform_typesGroupByArgs['orderBy'] }
        : { orderBy?: uniform_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, uniform_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniform_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the uniform_types model
   */
  readonly fields: uniform_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for uniform_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__uniform_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the uniform_types model
   */
  interface uniform_typesFieldRefs {
    readonly id: FieldRef<"uniform_types", 'Int'>
    readonly type: FieldRef<"uniform_types", 'String'>
    readonly created_at: FieldRef<"uniform_types", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * uniform_types findUnique
   */
  export type uniform_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_types
     */
    select?: uniform_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_types
     */
    omit?: uniform_typesOmit<ExtArgs> | null
    /**
     * Filter, which uniform_types to fetch.
     */
    where: uniform_typesWhereUniqueInput
  }

  /**
   * uniform_types findUniqueOrThrow
   */
  export type uniform_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_types
     */
    select?: uniform_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_types
     */
    omit?: uniform_typesOmit<ExtArgs> | null
    /**
     * Filter, which uniform_types to fetch.
     */
    where: uniform_typesWhereUniqueInput
  }

  /**
   * uniform_types findFirst
   */
  export type uniform_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_types
     */
    select?: uniform_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_types
     */
    omit?: uniform_typesOmit<ExtArgs> | null
    /**
     * Filter, which uniform_types to fetch.
     */
    where?: uniform_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_types to fetch.
     */
    orderBy?: uniform_typesOrderByWithRelationInput | uniform_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for uniform_types.
     */
    cursor?: uniform_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of uniform_types.
     */
    distinct?: Uniform_typesScalarFieldEnum | Uniform_typesScalarFieldEnum[]
  }

  /**
   * uniform_types findFirstOrThrow
   */
  export type uniform_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_types
     */
    select?: uniform_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_types
     */
    omit?: uniform_typesOmit<ExtArgs> | null
    /**
     * Filter, which uniform_types to fetch.
     */
    where?: uniform_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_types to fetch.
     */
    orderBy?: uniform_typesOrderByWithRelationInput | uniform_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for uniform_types.
     */
    cursor?: uniform_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of uniform_types.
     */
    distinct?: Uniform_typesScalarFieldEnum | Uniform_typesScalarFieldEnum[]
  }

  /**
   * uniform_types findMany
   */
  export type uniform_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_types
     */
    select?: uniform_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_types
     */
    omit?: uniform_typesOmit<ExtArgs> | null
    /**
     * Filter, which uniform_types to fetch.
     */
    where?: uniform_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of uniform_types to fetch.
     */
    orderBy?: uniform_typesOrderByWithRelationInput | uniform_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing uniform_types.
     */
    cursor?: uniform_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` uniform_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` uniform_types.
     */
    skip?: number
    distinct?: Uniform_typesScalarFieldEnum | Uniform_typesScalarFieldEnum[]
  }

  /**
   * uniform_types create
   */
  export type uniform_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_types
     */
    select?: uniform_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_types
     */
    omit?: uniform_typesOmit<ExtArgs> | null
    /**
     * The data needed to create a uniform_types.
     */
    data: XOR<uniform_typesCreateInput, uniform_typesUncheckedCreateInput>
  }

  /**
   * uniform_types createMany
   */
  export type uniform_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many uniform_types.
     */
    data: uniform_typesCreateManyInput | uniform_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * uniform_types update
   */
  export type uniform_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_types
     */
    select?: uniform_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_types
     */
    omit?: uniform_typesOmit<ExtArgs> | null
    /**
     * The data needed to update a uniform_types.
     */
    data: XOR<uniform_typesUpdateInput, uniform_typesUncheckedUpdateInput>
    /**
     * Choose, which uniform_types to update.
     */
    where: uniform_typesWhereUniqueInput
  }

  /**
   * uniform_types updateMany
   */
  export type uniform_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update uniform_types.
     */
    data: XOR<uniform_typesUpdateManyMutationInput, uniform_typesUncheckedUpdateManyInput>
    /**
     * Filter which uniform_types to update
     */
    where?: uniform_typesWhereInput
    /**
     * Limit how many uniform_types to update.
     */
    limit?: number
  }

  /**
   * uniform_types upsert
   */
  export type uniform_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_types
     */
    select?: uniform_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_types
     */
    omit?: uniform_typesOmit<ExtArgs> | null
    /**
     * The filter to search for the uniform_types to update in case it exists.
     */
    where: uniform_typesWhereUniqueInput
    /**
     * In case the uniform_types found by the `where` argument doesn't exist, create a new uniform_types with this data.
     */
    create: XOR<uniform_typesCreateInput, uniform_typesUncheckedCreateInput>
    /**
     * In case the uniform_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<uniform_typesUpdateInput, uniform_typesUncheckedUpdateInput>
  }

  /**
   * uniform_types delete
   */
  export type uniform_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_types
     */
    select?: uniform_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_types
     */
    omit?: uniform_typesOmit<ExtArgs> | null
    /**
     * Filter which uniform_types to delete.
     */
    where: uniform_typesWhereUniqueInput
  }

  /**
   * uniform_types deleteMany
   */
  export type uniform_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which uniform_types to delete
     */
    where?: uniform_typesWhereInput
    /**
     * Limit how many uniform_types to delete.
     */
    limit?: number
  }

  /**
   * uniform_types without action
   */
  export type uniform_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the uniform_types
     */
    select?: uniform_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the uniform_types
     */
    omit?: uniform_typesOmit<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    rfid: number | null
    isactive: number | null
    level: number | null
    status: number | null
    earlybird: number | null
    modelrelease: number | null
    feepolicy: number | null
    refund: number | null
    tos: number | null
    isESL: number | null
    isofficial: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    isactive: number | null
    level: number | null
    status: number | null
    earlybird: number | null
    modelrelease: number | null
    feepolicy: number | null
    refund: number | null
    tos: number | null
    isESL: number | null
    isofficial: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    fname: string | null
    mname: string | null
    lname: string | null
    type: string | null
    gender: string | null
    position: string | null
    grade: string | null
    section: string | null
    dob: Date | null
    email: string | null
    mobile: string | null
    vacchist: string | null
    photo: string | null
    manager: string | null
    isactive: number | null
    is_situation: string | null
    username: string | null
    password: string | null
    level: number | null
    status: number | null
    prevsch: string | null
    prevschcountry: string | null
    lrn: string | null
    uniqid: string | null
    tf: string | null
    country: string | null
    nationality: string | null
    nationalities: string | null
    guardianname: string | null
    guardianemail: string | null
    guardianphone: string | null
    referral: string | null
    apptype: string | null
    sy: string | null
    strand: string | null
    religion: string | null
    visa: string | null
    earlybird: number | null
    modelrelease: number | null
    feepolicy: number | null
    refund: number | null
    tos: number | null
    empno: string | null
    isESL: number | null
    house: string | null
    isofficial: number | null
    isEnrolledInAfterSchool: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    fname: string | null
    mname: string | null
    lname: string | null
    type: string | null
    gender: string | null
    position: string | null
    grade: string | null
    section: string | null
    dob: Date | null
    email: string | null
    mobile: string | null
    vacchist: string | null
    photo: string | null
    manager: string | null
    isactive: number | null
    is_situation: string | null
    username: string | null
    password: string | null
    level: number | null
    status: number | null
    prevsch: string | null
    prevschcountry: string | null
    lrn: string | null
    uniqid: string | null
    tf: string | null
    country: string | null
    nationality: string | null
    nationalities: string | null
    guardianname: string | null
    guardianemail: string | null
    guardianphone: string | null
    referral: string | null
    apptype: string | null
    sy: string | null
    strand: string | null
    religion: string | null
    visa: string | null
    earlybird: number | null
    modelrelease: number | null
    feepolicy: number | null
    refund: number | null
    tos: number | null
    empno: string | null
    isESL: number | null
    house: string | null
    isofficial: number | null
    isEnrolledInAfterSchool: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    rfid: number
    fname: number
    mname: number
    lname: number
    type: number
    gender: number
    position: number
    grade: number
    section: number
    dob: number
    email: number
    mobile: number
    vacchist: number
    photo: number
    manager: number
    isactive: number
    is_situation: number
    username: number
    password: number
    level: number
    status: number
    prevsch: number
    prevschcountry: number
    lrn: number
    uniqid: number
    tf: number
    country: number
    nationality: number
    nationalities: number
    guardianname: number
    guardianemail: number
    guardianphone: number
    referral: number
    apptype: number
    sy: number
    strand: number
    religion: number
    visa: number
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: number
    isESL: number
    house: number
    isofficial: number
    isEnrolledInAfterSchool: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    rfid?: true
    isactive?: true
    level?: true
    status?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
    isESL?: true
    isofficial?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    rfid?: true
    isactive?: true
    level?: true
    status?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
    isESL?: true
    isofficial?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    rfid?: true
    fname?: true
    mname?: true
    lname?: true
    type?: true
    gender?: true
    position?: true
    grade?: true
    section?: true
    dob?: true
    email?: true
    mobile?: true
    vacchist?: true
    photo?: true
    manager?: true
    isactive?: true
    is_situation?: true
    username?: true
    password?: true
    level?: true
    status?: true
    prevsch?: true
    prevschcountry?: true
    lrn?: true
    uniqid?: true
    tf?: true
    country?: true
    nationality?: true
    nationalities?: true
    guardianname?: true
    guardianemail?: true
    guardianphone?: true
    referral?: true
    apptype?: true
    sy?: true
    strand?: true
    religion?: true
    visa?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
    empno?: true
    isESL?: true
    house?: true
    isofficial?: true
    isEnrolledInAfterSchool?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    rfid?: true
    fname?: true
    mname?: true
    lname?: true
    type?: true
    gender?: true
    position?: true
    grade?: true
    section?: true
    dob?: true
    email?: true
    mobile?: true
    vacchist?: true
    photo?: true
    manager?: true
    isactive?: true
    is_situation?: true
    username?: true
    password?: true
    level?: true
    status?: true
    prevsch?: true
    prevschcountry?: true
    lrn?: true
    uniqid?: true
    tf?: true
    country?: true
    nationality?: true
    nationalities?: true
    guardianname?: true
    guardianemail?: true
    guardianphone?: true
    referral?: true
    apptype?: true
    sy?: true
    strand?: true
    religion?: true
    visa?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
    empno?: true
    isESL?: true
    house?: true
    isofficial?: true
    isEnrolledInAfterSchool?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    rfid?: true
    fname?: true
    mname?: true
    lname?: true
    type?: true
    gender?: true
    position?: true
    grade?: true
    section?: true
    dob?: true
    email?: true
    mobile?: true
    vacchist?: true
    photo?: true
    manager?: true
    isactive?: true
    is_situation?: true
    username?: true
    password?: true
    level?: true
    status?: true
    prevsch?: true
    prevschcountry?: true
    lrn?: true
    uniqid?: true
    tf?: true
    country?: true
    nationality?: true
    nationalities?: true
    guardianname?: true
    guardianemail?: true
    guardianphone?: true
    referral?: true
    apptype?: true
    sy?: true
    strand?: true
    religion?: true
    visa?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
    empno?: true
    isESL?: true
    house?: true
    isofficial?: true
    isEnrolledInAfterSchool?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    rfid: bigint
    fname: string
    mname: string
    lname: string
    type: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    is_situation: string
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    nationalities: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    religion: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: string
    isESL: number
    house: string
    isofficial: number
    isEnrolledInAfterSchool: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfid?: boolean
    fname?: boolean
    mname?: boolean
    lname?: boolean
    type?: boolean
    gender?: boolean
    position?: boolean
    grade?: boolean
    section?: boolean
    dob?: boolean
    email?: boolean
    mobile?: boolean
    vacchist?: boolean
    photo?: boolean
    manager?: boolean
    isactive?: boolean
    is_situation?: boolean
    username?: boolean
    password?: boolean
    level?: boolean
    status?: boolean
    prevsch?: boolean
    prevschcountry?: boolean
    lrn?: boolean
    uniqid?: boolean
    tf?: boolean
    country?: boolean
    nationality?: boolean
    nationalities?: boolean
    guardianname?: boolean
    guardianemail?: boolean
    guardianphone?: boolean
    referral?: boolean
    apptype?: boolean
    sy?: boolean
    strand?: boolean
    religion?: boolean
    visa?: boolean
    earlybird?: boolean
    modelrelease?: boolean
    feepolicy?: boolean
    refund?: boolean
    tos?: boolean
    empno?: boolean
    isESL?: boolean
    house?: boolean
    isofficial?: boolean
    isEnrolledInAfterSchool?: boolean
    attendance?: boolean | user$attendanceArgs<ExtArgs>
    enrolledactivity?: boolean | user$enrolledactivityArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    id?: boolean
    rfid?: boolean
    fname?: boolean
    mname?: boolean
    lname?: boolean
    type?: boolean
    gender?: boolean
    position?: boolean
    grade?: boolean
    section?: boolean
    dob?: boolean
    email?: boolean
    mobile?: boolean
    vacchist?: boolean
    photo?: boolean
    manager?: boolean
    isactive?: boolean
    is_situation?: boolean
    username?: boolean
    password?: boolean
    level?: boolean
    status?: boolean
    prevsch?: boolean
    prevschcountry?: boolean
    lrn?: boolean
    uniqid?: boolean
    tf?: boolean
    country?: boolean
    nationality?: boolean
    nationalities?: boolean
    guardianname?: boolean
    guardianemail?: boolean
    guardianphone?: boolean
    referral?: boolean
    apptype?: boolean
    sy?: boolean
    strand?: boolean
    religion?: boolean
    visa?: boolean
    earlybird?: boolean
    modelrelease?: boolean
    feepolicy?: boolean
    refund?: boolean
    tos?: boolean
    empno?: boolean
    isESL?: boolean
    house?: boolean
    isofficial?: boolean
    isEnrolledInAfterSchool?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rfid" | "fname" | "mname" | "lname" | "type" | "gender" | "position" | "grade" | "section" | "dob" | "email" | "mobile" | "vacchist" | "photo" | "manager" | "isactive" | "is_situation" | "username" | "password" | "level" | "status" | "prevsch" | "prevschcountry" | "lrn" | "uniqid" | "tf" | "country" | "nationality" | "nationalities" | "guardianname" | "guardianemail" | "guardianphone" | "referral" | "apptype" | "sy" | "strand" | "religion" | "visa" | "earlybird" | "modelrelease" | "feepolicy" | "refund" | "tos" | "empno" | "isESL" | "house" | "isofficial" | "isEnrolledInAfterSchool", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | user$attendanceArgs<ExtArgs>
    enrolledactivity?: boolean | user$enrolledactivityArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      attendance: Prisma.$attendancePayload<ExtArgs>[]
      enrolledactivity: Prisma.$enrolledactivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rfid: bigint
      fname: string
      mname: string
      lname: string
      type: string
      gender: string
      position: string
      grade: string
      section: string
      dob: Date
      email: string
      mobile: string
      vacchist: string
      photo: string
      manager: string
      isactive: number
      is_situation: string
      username: string
      password: string
      level: number
      status: number
      prevsch: string
      prevschcountry: string
      lrn: string
      uniqid: string
      tf: string
      country: string
      nationality: string
      nationalities: string
      guardianname: string
      guardianemail: string
      guardianphone: string
      referral: string
      apptype: string
      sy: string
      strand: string
      religion: string
      visa: string
      earlybird: number
      modelrelease: number
      feepolicy: number
      refund: number
      tos: number
      empno: string
      isESL: number
      house: string
      isofficial: number
      isEnrolledInAfterSchool: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendance<T extends user$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, user$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrolledactivity<T extends user$enrolledactivityArgs<ExtArgs> = {}>(args?: Subset<T, user$enrolledactivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrolledactivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly rfid: FieldRef<"user", 'BigInt'>
    readonly fname: FieldRef<"user", 'String'>
    readonly mname: FieldRef<"user", 'String'>
    readonly lname: FieldRef<"user", 'String'>
    readonly type: FieldRef<"user", 'String'>
    readonly gender: FieldRef<"user", 'String'>
    readonly position: FieldRef<"user", 'String'>
    readonly grade: FieldRef<"user", 'String'>
    readonly section: FieldRef<"user", 'String'>
    readonly dob: FieldRef<"user", 'DateTime'>
    readonly email: FieldRef<"user", 'String'>
    readonly mobile: FieldRef<"user", 'String'>
    readonly vacchist: FieldRef<"user", 'String'>
    readonly photo: FieldRef<"user", 'String'>
    readonly manager: FieldRef<"user", 'String'>
    readonly isactive: FieldRef<"user", 'Int'>
    readonly is_situation: FieldRef<"user", 'String'>
    readonly username: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly level: FieldRef<"user", 'Int'>
    readonly status: FieldRef<"user", 'Int'>
    readonly prevsch: FieldRef<"user", 'String'>
    readonly prevschcountry: FieldRef<"user", 'String'>
    readonly lrn: FieldRef<"user", 'String'>
    readonly uniqid: FieldRef<"user", 'String'>
    readonly tf: FieldRef<"user", 'String'>
    readonly country: FieldRef<"user", 'String'>
    readonly nationality: FieldRef<"user", 'String'>
    readonly nationalities: FieldRef<"user", 'String'>
    readonly guardianname: FieldRef<"user", 'String'>
    readonly guardianemail: FieldRef<"user", 'String'>
    readonly guardianphone: FieldRef<"user", 'String'>
    readonly referral: FieldRef<"user", 'String'>
    readonly apptype: FieldRef<"user", 'String'>
    readonly sy: FieldRef<"user", 'String'>
    readonly strand: FieldRef<"user", 'String'>
    readonly religion: FieldRef<"user", 'String'>
    readonly visa: FieldRef<"user", 'String'>
    readonly earlybird: FieldRef<"user", 'Int'>
    readonly modelrelease: FieldRef<"user", 'Int'>
    readonly feepolicy: FieldRef<"user", 'Int'>
    readonly refund: FieldRef<"user", 'Int'>
    readonly tos: FieldRef<"user", 'Int'>
    readonly empno: FieldRef<"user", 'String'>
    readonly isESL: FieldRef<"user", 'Int'>
    readonly house: FieldRef<"user", 'String'>
    readonly isofficial: FieldRef<"user", 'Int'>
    readonly isEnrolledInAfterSchool: FieldRef<"user", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.attendance
   */
  export type user$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    where?: attendanceWhereInput
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    cursor?: attendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * user.enrolledactivity
   */
  export type user$enrolledactivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrolledactivity
     */
    select?: enrolledactivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrolledactivity
     */
    omit?: enrolledactivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrolledactivityInclude<ExtArgs> | null
    where?: enrolledactivityWhereInput
    orderBy?: enrolledactivityOrderByWithRelationInput | enrolledactivityOrderByWithRelationInput[]
    cursor?: enrolledactivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrolledactivityScalarFieldEnum | EnrolledactivityScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model user22
   */

  export type AggregateUser22 = {
    _count: User22CountAggregateOutputType | null
    _avg: User22AvgAggregateOutputType | null
    _sum: User22SumAggregateOutputType | null
    _min: User22MinAggregateOutputType | null
    _max: User22MaxAggregateOutputType | null
  }

  export type User22AvgAggregateOutputType = {
    id: number | null
    rfid: number | null
    isactive: number | null
    level: number | null
    status: number | null
    earlybird: number | null
    modelrelease: number | null
    feepolicy: number | null
    refund: number | null
    tos: number | null
  }

  export type User22SumAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    isactive: number | null
    level: number | null
    status: number | null
    earlybird: number | null
    modelrelease: number | null
    feepolicy: number | null
    refund: number | null
    tos: number | null
  }

  export type User22MinAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    fname: string | null
    mname: string | null
    lname: string | null
    gender: string | null
    position: string | null
    grade: string | null
    section: string | null
    dob: Date | null
    email: string | null
    mobile: string | null
    vacchist: string | null
    photo: string | null
    manager: string | null
    isactive: number | null
    username: string | null
    password: string | null
    level: number | null
    status: number | null
    prevsch: string | null
    prevschcountry: string | null
    lrn: string | null
    uniqid: string | null
    tf: string | null
    country: string | null
    nationality: string | null
    guardianname: string | null
    guardianemail: string | null
    guardianphone: string | null
    referral: string | null
    apptype: string | null
    sy: string | null
    strand: string | null
    visa: string | null
    earlybird: number | null
    modelrelease: number | null
    feepolicy: number | null
    refund: number | null
    tos: number | null
  }

  export type User22MaxAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    fname: string | null
    mname: string | null
    lname: string | null
    gender: string | null
    position: string | null
    grade: string | null
    section: string | null
    dob: Date | null
    email: string | null
    mobile: string | null
    vacchist: string | null
    photo: string | null
    manager: string | null
    isactive: number | null
    username: string | null
    password: string | null
    level: number | null
    status: number | null
    prevsch: string | null
    prevschcountry: string | null
    lrn: string | null
    uniqid: string | null
    tf: string | null
    country: string | null
    nationality: string | null
    guardianname: string | null
    guardianemail: string | null
    guardianphone: string | null
    referral: string | null
    apptype: string | null
    sy: string | null
    strand: string | null
    visa: string | null
    earlybird: number | null
    modelrelease: number | null
    feepolicy: number | null
    refund: number | null
    tos: number | null
  }

  export type User22CountAggregateOutputType = {
    id: number
    rfid: number
    fname: number
    mname: number
    lname: number
    gender: number
    position: number
    grade: number
    section: number
    dob: number
    email: number
    mobile: number
    vacchist: number
    photo: number
    manager: number
    isactive: number
    username: number
    password: number
    level: number
    status: number
    prevsch: number
    prevschcountry: number
    lrn: number
    uniqid: number
    tf: number
    country: number
    nationality: number
    guardianname: number
    guardianemail: number
    guardianphone: number
    referral: number
    apptype: number
    sy: number
    strand: number
    visa: number
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    _all: number
  }


  export type User22AvgAggregateInputType = {
    id?: true
    rfid?: true
    isactive?: true
    level?: true
    status?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
  }

  export type User22SumAggregateInputType = {
    id?: true
    rfid?: true
    isactive?: true
    level?: true
    status?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
  }

  export type User22MinAggregateInputType = {
    id?: true
    rfid?: true
    fname?: true
    mname?: true
    lname?: true
    gender?: true
    position?: true
    grade?: true
    section?: true
    dob?: true
    email?: true
    mobile?: true
    vacchist?: true
    photo?: true
    manager?: true
    isactive?: true
    username?: true
    password?: true
    level?: true
    status?: true
    prevsch?: true
    prevschcountry?: true
    lrn?: true
    uniqid?: true
    tf?: true
    country?: true
    nationality?: true
    guardianname?: true
    guardianemail?: true
    guardianphone?: true
    referral?: true
    apptype?: true
    sy?: true
    strand?: true
    visa?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
  }

  export type User22MaxAggregateInputType = {
    id?: true
    rfid?: true
    fname?: true
    mname?: true
    lname?: true
    gender?: true
    position?: true
    grade?: true
    section?: true
    dob?: true
    email?: true
    mobile?: true
    vacchist?: true
    photo?: true
    manager?: true
    isactive?: true
    username?: true
    password?: true
    level?: true
    status?: true
    prevsch?: true
    prevschcountry?: true
    lrn?: true
    uniqid?: true
    tf?: true
    country?: true
    nationality?: true
    guardianname?: true
    guardianemail?: true
    guardianphone?: true
    referral?: true
    apptype?: true
    sy?: true
    strand?: true
    visa?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
  }

  export type User22CountAggregateInputType = {
    id?: true
    rfid?: true
    fname?: true
    mname?: true
    lname?: true
    gender?: true
    position?: true
    grade?: true
    section?: true
    dob?: true
    email?: true
    mobile?: true
    vacchist?: true
    photo?: true
    manager?: true
    isactive?: true
    username?: true
    password?: true
    level?: true
    status?: true
    prevsch?: true
    prevschcountry?: true
    lrn?: true
    uniqid?: true
    tf?: true
    country?: true
    nationality?: true
    guardianname?: true
    guardianemail?: true
    guardianphone?: true
    referral?: true
    apptype?: true
    sy?: true
    strand?: true
    visa?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
    _all?: true
  }

  export type User22AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user22 to aggregate.
     */
    where?: user22WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user22s to fetch.
     */
    orderBy?: user22OrderByWithRelationInput | user22OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user22WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user22s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user22s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user22s
    **/
    _count?: true | User22CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User22AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User22SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User22MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User22MaxAggregateInputType
  }

  export type GetUser22AggregateType<T extends User22AggregateArgs> = {
        [P in keyof T & keyof AggregateUser22]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser22[P]>
      : GetScalarType<T[P], AggregateUser22[P]>
  }




  export type user22GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user22WhereInput
    orderBy?: user22OrderByWithAggregationInput | user22OrderByWithAggregationInput[]
    by: User22ScalarFieldEnum[] | User22ScalarFieldEnum
    having?: user22ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User22CountAggregateInputType | true
    _avg?: User22AvgAggregateInputType
    _sum?: User22SumAggregateInputType
    _min?: User22MinAggregateInputType
    _max?: User22MaxAggregateInputType
  }

  export type User22GroupByOutputType = {
    id: number
    rfid: bigint
    fname: string
    mname: string
    lname: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    _count: User22CountAggregateOutputType | null
    _avg: User22AvgAggregateOutputType | null
    _sum: User22SumAggregateOutputType | null
    _min: User22MinAggregateOutputType | null
    _max: User22MaxAggregateOutputType | null
  }

  type GetUser22GroupByPayload<T extends user22GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User22GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User22GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User22GroupByOutputType[P]>
            : GetScalarType<T[P], User22GroupByOutputType[P]>
        }
      >
    >


  export type user22Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfid?: boolean
    fname?: boolean
    mname?: boolean
    lname?: boolean
    gender?: boolean
    position?: boolean
    grade?: boolean
    section?: boolean
    dob?: boolean
    email?: boolean
    mobile?: boolean
    vacchist?: boolean
    photo?: boolean
    manager?: boolean
    isactive?: boolean
    username?: boolean
    password?: boolean
    level?: boolean
    status?: boolean
    prevsch?: boolean
    prevschcountry?: boolean
    lrn?: boolean
    uniqid?: boolean
    tf?: boolean
    country?: boolean
    nationality?: boolean
    guardianname?: boolean
    guardianemail?: boolean
    guardianphone?: boolean
    referral?: boolean
    apptype?: boolean
    sy?: boolean
    strand?: boolean
    visa?: boolean
    earlybird?: boolean
    modelrelease?: boolean
    feepolicy?: boolean
    refund?: boolean
    tos?: boolean
  }, ExtArgs["result"]["user22"]>



  export type user22SelectScalar = {
    id?: boolean
    rfid?: boolean
    fname?: boolean
    mname?: boolean
    lname?: boolean
    gender?: boolean
    position?: boolean
    grade?: boolean
    section?: boolean
    dob?: boolean
    email?: boolean
    mobile?: boolean
    vacchist?: boolean
    photo?: boolean
    manager?: boolean
    isactive?: boolean
    username?: boolean
    password?: boolean
    level?: boolean
    status?: boolean
    prevsch?: boolean
    prevschcountry?: boolean
    lrn?: boolean
    uniqid?: boolean
    tf?: boolean
    country?: boolean
    nationality?: boolean
    guardianname?: boolean
    guardianemail?: boolean
    guardianphone?: boolean
    referral?: boolean
    apptype?: boolean
    sy?: boolean
    strand?: boolean
    visa?: boolean
    earlybird?: boolean
    modelrelease?: boolean
    feepolicy?: boolean
    refund?: boolean
    tos?: boolean
  }

  export type user22Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rfid" | "fname" | "mname" | "lname" | "gender" | "position" | "grade" | "section" | "dob" | "email" | "mobile" | "vacchist" | "photo" | "manager" | "isactive" | "username" | "password" | "level" | "status" | "prevsch" | "prevschcountry" | "lrn" | "uniqid" | "tf" | "country" | "nationality" | "guardianname" | "guardianemail" | "guardianphone" | "referral" | "apptype" | "sy" | "strand" | "visa" | "earlybird" | "modelrelease" | "feepolicy" | "refund" | "tos", ExtArgs["result"]["user22"]>

  export type $user22Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user22"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rfid: bigint
      fname: string
      mname: string
      lname: string
      gender: string
      position: string
      grade: string
      section: string
      dob: Date
      email: string
      mobile: string
      vacchist: string
      photo: string
      manager: string
      isactive: number
      username: string
      password: string
      level: number
      status: number
      prevsch: string
      prevschcountry: string
      lrn: string
      uniqid: string
      tf: string
      country: string
      nationality: string
      guardianname: string
      guardianemail: string
      guardianphone: string
      referral: string
      apptype: string
      sy: string
      strand: string
      visa: string
      earlybird: number
      modelrelease: number
      feepolicy: number
      refund: number
      tos: number
    }, ExtArgs["result"]["user22"]>
    composites: {}
  }

  type user22GetPayload<S extends boolean | null | undefined | user22DefaultArgs> = $Result.GetResult<Prisma.$user22Payload, S>

  type user22CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user22FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User22CountAggregateInputType | true
    }

  export interface user22Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user22'], meta: { name: 'user22' } }
    /**
     * Find zero or one User22 that matches the filter.
     * @param {user22FindUniqueArgs} args - Arguments to find a User22
     * @example
     * // Get one User22
     * const user22 = await prisma.user22.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user22FindUniqueArgs>(args: SelectSubset<T, user22FindUniqueArgs<ExtArgs>>): Prisma__user22Client<$Result.GetResult<Prisma.$user22Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User22 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user22FindUniqueOrThrowArgs} args - Arguments to find a User22
     * @example
     * // Get one User22
     * const user22 = await prisma.user22.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user22FindUniqueOrThrowArgs>(args: SelectSubset<T, user22FindUniqueOrThrowArgs<ExtArgs>>): Prisma__user22Client<$Result.GetResult<Prisma.$user22Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User22 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user22FindFirstArgs} args - Arguments to find a User22
     * @example
     * // Get one User22
     * const user22 = await prisma.user22.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user22FindFirstArgs>(args?: SelectSubset<T, user22FindFirstArgs<ExtArgs>>): Prisma__user22Client<$Result.GetResult<Prisma.$user22Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User22 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user22FindFirstOrThrowArgs} args - Arguments to find a User22
     * @example
     * // Get one User22
     * const user22 = await prisma.user22.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user22FindFirstOrThrowArgs>(args?: SelectSubset<T, user22FindFirstOrThrowArgs<ExtArgs>>): Prisma__user22Client<$Result.GetResult<Prisma.$user22Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User22s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user22FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User22s
     * const user22s = await prisma.user22.findMany()
     * 
     * // Get first 10 User22s
     * const user22s = await prisma.user22.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user22WithIdOnly = await prisma.user22.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user22FindManyArgs>(args?: SelectSubset<T, user22FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user22Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User22.
     * @param {user22CreateArgs} args - Arguments to create a User22.
     * @example
     * // Create one User22
     * const User22 = await prisma.user22.create({
     *   data: {
     *     // ... data to create a User22
     *   }
     * })
     * 
     */
    create<T extends user22CreateArgs>(args: SelectSubset<T, user22CreateArgs<ExtArgs>>): Prisma__user22Client<$Result.GetResult<Prisma.$user22Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User22s.
     * @param {user22CreateManyArgs} args - Arguments to create many User22s.
     * @example
     * // Create many User22s
     * const user22 = await prisma.user22.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user22CreateManyArgs>(args?: SelectSubset<T, user22CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User22.
     * @param {user22DeleteArgs} args - Arguments to delete one User22.
     * @example
     * // Delete one User22
     * const User22 = await prisma.user22.delete({
     *   where: {
     *     // ... filter to delete one User22
     *   }
     * })
     * 
     */
    delete<T extends user22DeleteArgs>(args: SelectSubset<T, user22DeleteArgs<ExtArgs>>): Prisma__user22Client<$Result.GetResult<Prisma.$user22Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User22.
     * @param {user22UpdateArgs} args - Arguments to update one User22.
     * @example
     * // Update one User22
     * const user22 = await prisma.user22.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user22UpdateArgs>(args: SelectSubset<T, user22UpdateArgs<ExtArgs>>): Prisma__user22Client<$Result.GetResult<Prisma.$user22Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User22s.
     * @param {user22DeleteManyArgs} args - Arguments to filter User22s to delete.
     * @example
     * // Delete a few User22s
     * const { count } = await prisma.user22.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user22DeleteManyArgs>(args?: SelectSubset<T, user22DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User22s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user22UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User22s
     * const user22 = await prisma.user22.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user22UpdateManyArgs>(args: SelectSubset<T, user22UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User22.
     * @param {user22UpsertArgs} args - Arguments to update or create a User22.
     * @example
     * // Update or create a User22
     * const user22 = await prisma.user22.upsert({
     *   create: {
     *     // ... data to create a User22
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User22 we want to update
     *   }
     * })
     */
    upsert<T extends user22UpsertArgs>(args: SelectSubset<T, user22UpsertArgs<ExtArgs>>): Prisma__user22Client<$Result.GetResult<Prisma.$user22Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User22s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user22CountArgs} args - Arguments to filter User22s to count.
     * @example
     * // Count the number of User22s
     * const count = await prisma.user22.count({
     *   where: {
     *     // ... the filter for the User22s we want to count
     *   }
     * })
    **/
    count<T extends user22CountArgs>(
      args?: Subset<T, user22CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User22CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User22.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User22AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User22AggregateArgs>(args: Subset<T, User22AggregateArgs>): Prisma.PrismaPromise<GetUser22AggregateType<T>>

    /**
     * Group by User22.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user22GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user22GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user22GroupByArgs['orderBy'] }
        : { orderBy?: user22GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user22GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser22GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user22 model
   */
  readonly fields: user22FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user22.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user22Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user22 model
   */
  interface user22FieldRefs {
    readonly id: FieldRef<"user22", 'Int'>
    readonly rfid: FieldRef<"user22", 'BigInt'>
    readonly fname: FieldRef<"user22", 'String'>
    readonly mname: FieldRef<"user22", 'String'>
    readonly lname: FieldRef<"user22", 'String'>
    readonly gender: FieldRef<"user22", 'String'>
    readonly position: FieldRef<"user22", 'String'>
    readonly grade: FieldRef<"user22", 'String'>
    readonly section: FieldRef<"user22", 'String'>
    readonly dob: FieldRef<"user22", 'DateTime'>
    readonly email: FieldRef<"user22", 'String'>
    readonly mobile: FieldRef<"user22", 'String'>
    readonly vacchist: FieldRef<"user22", 'String'>
    readonly photo: FieldRef<"user22", 'String'>
    readonly manager: FieldRef<"user22", 'String'>
    readonly isactive: FieldRef<"user22", 'Int'>
    readonly username: FieldRef<"user22", 'String'>
    readonly password: FieldRef<"user22", 'String'>
    readonly level: FieldRef<"user22", 'Int'>
    readonly status: FieldRef<"user22", 'Int'>
    readonly prevsch: FieldRef<"user22", 'String'>
    readonly prevschcountry: FieldRef<"user22", 'String'>
    readonly lrn: FieldRef<"user22", 'String'>
    readonly uniqid: FieldRef<"user22", 'String'>
    readonly tf: FieldRef<"user22", 'String'>
    readonly country: FieldRef<"user22", 'String'>
    readonly nationality: FieldRef<"user22", 'String'>
    readonly guardianname: FieldRef<"user22", 'String'>
    readonly guardianemail: FieldRef<"user22", 'String'>
    readonly guardianphone: FieldRef<"user22", 'String'>
    readonly referral: FieldRef<"user22", 'String'>
    readonly apptype: FieldRef<"user22", 'String'>
    readonly sy: FieldRef<"user22", 'String'>
    readonly strand: FieldRef<"user22", 'String'>
    readonly visa: FieldRef<"user22", 'String'>
    readonly earlybird: FieldRef<"user22", 'Int'>
    readonly modelrelease: FieldRef<"user22", 'Int'>
    readonly feepolicy: FieldRef<"user22", 'Int'>
    readonly refund: FieldRef<"user22", 'Int'>
    readonly tos: FieldRef<"user22", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * user22 findUnique
   */
  export type user22FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user22
     */
    select?: user22Select<ExtArgs> | null
    /**
     * Omit specific fields from the user22
     */
    omit?: user22Omit<ExtArgs> | null
    /**
     * Filter, which user22 to fetch.
     */
    where: user22WhereUniqueInput
  }

  /**
   * user22 findUniqueOrThrow
   */
  export type user22FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user22
     */
    select?: user22Select<ExtArgs> | null
    /**
     * Omit specific fields from the user22
     */
    omit?: user22Omit<ExtArgs> | null
    /**
     * Filter, which user22 to fetch.
     */
    where: user22WhereUniqueInput
  }

  /**
   * user22 findFirst
   */
  export type user22FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user22
     */
    select?: user22Select<ExtArgs> | null
    /**
     * Omit specific fields from the user22
     */
    omit?: user22Omit<ExtArgs> | null
    /**
     * Filter, which user22 to fetch.
     */
    where?: user22WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user22s to fetch.
     */
    orderBy?: user22OrderByWithRelationInput | user22OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user22s.
     */
    cursor?: user22WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user22s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user22s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user22s.
     */
    distinct?: User22ScalarFieldEnum | User22ScalarFieldEnum[]
  }

  /**
   * user22 findFirstOrThrow
   */
  export type user22FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user22
     */
    select?: user22Select<ExtArgs> | null
    /**
     * Omit specific fields from the user22
     */
    omit?: user22Omit<ExtArgs> | null
    /**
     * Filter, which user22 to fetch.
     */
    where?: user22WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user22s to fetch.
     */
    orderBy?: user22OrderByWithRelationInput | user22OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user22s.
     */
    cursor?: user22WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user22s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user22s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user22s.
     */
    distinct?: User22ScalarFieldEnum | User22ScalarFieldEnum[]
  }

  /**
   * user22 findMany
   */
  export type user22FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user22
     */
    select?: user22Select<ExtArgs> | null
    /**
     * Omit specific fields from the user22
     */
    omit?: user22Omit<ExtArgs> | null
    /**
     * Filter, which user22s to fetch.
     */
    where?: user22WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user22s to fetch.
     */
    orderBy?: user22OrderByWithRelationInput | user22OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user22s.
     */
    cursor?: user22WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user22s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user22s.
     */
    skip?: number
    distinct?: User22ScalarFieldEnum | User22ScalarFieldEnum[]
  }

  /**
   * user22 create
   */
  export type user22CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user22
     */
    select?: user22Select<ExtArgs> | null
    /**
     * Omit specific fields from the user22
     */
    omit?: user22Omit<ExtArgs> | null
    /**
     * The data needed to create a user22.
     */
    data: XOR<user22CreateInput, user22UncheckedCreateInput>
  }

  /**
   * user22 createMany
   */
  export type user22CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user22s.
     */
    data: user22CreateManyInput | user22CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user22 update
   */
  export type user22UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user22
     */
    select?: user22Select<ExtArgs> | null
    /**
     * Omit specific fields from the user22
     */
    omit?: user22Omit<ExtArgs> | null
    /**
     * The data needed to update a user22.
     */
    data: XOR<user22UpdateInput, user22UncheckedUpdateInput>
    /**
     * Choose, which user22 to update.
     */
    where: user22WhereUniqueInput
  }

  /**
   * user22 updateMany
   */
  export type user22UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user22s.
     */
    data: XOR<user22UpdateManyMutationInput, user22UncheckedUpdateManyInput>
    /**
     * Filter which user22s to update
     */
    where?: user22WhereInput
    /**
     * Limit how many user22s to update.
     */
    limit?: number
  }

  /**
   * user22 upsert
   */
  export type user22UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user22
     */
    select?: user22Select<ExtArgs> | null
    /**
     * Omit specific fields from the user22
     */
    omit?: user22Omit<ExtArgs> | null
    /**
     * The filter to search for the user22 to update in case it exists.
     */
    where: user22WhereUniqueInput
    /**
     * In case the user22 found by the `where` argument doesn't exist, create a new user22 with this data.
     */
    create: XOR<user22CreateInput, user22UncheckedCreateInput>
    /**
     * In case the user22 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user22UpdateInput, user22UncheckedUpdateInput>
  }

  /**
   * user22 delete
   */
  export type user22DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user22
     */
    select?: user22Select<ExtArgs> | null
    /**
     * Omit specific fields from the user22
     */
    omit?: user22Omit<ExtArgs> | null
    /**
     * Filter which user22 to delete.
     */
    where: user22WhereUniqueInput
  }

  /**
   * user22 deleteMany
   */
  export type user22DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user22s to delete
     */
    where?: user22WhereInput
    /**
     * Limit how many user22s to delete.
     */
    limit?: number
  }

  /**
   * user22 without action
   */
  export type user22DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user22
     */
    select?: user22Select<ExtArgs> | null
    /**
     * Omit specific fields from the user22
     */
    omit?: user22Omit<ExtArgs> | null
  }


  /**
   * Model users24
   */

  export type AggregateUsers24 = {
    _count: Users24CountAggregateOutputType | null
    _avg: Users24AvgAggregateOutputType | null
    _sum: Users24SumAggregateOutputType | null
    _min: Users24MinAggregateOutputType | null
    _max: Users24MaxAggregateOutputType | null
  }

  export type Users24AvgAggregateOutputType = {
    id: number | null
    rfid: number | null
    isactive: number | null
    level: number | null
    status: number | null
    earlybird: number | null
    modelrelease: number | null
    feepolicy: number | null
    refund: number | null
    tos: number | null
    isESL: number | null
    isofficial: number | null
  }

  export type Users24SumAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    isactive: number | null
    level: number | null
    status: number | null
    earlybird: number | null
    modelrelease: number | null
    feepolicy: number | null
    refund: number | null
    tos: number | null
    isESL: number | null
    isofficial: number | null
  }

  export type Users24MinAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    fname: string | null
    mname: string | null
    lname: string | null
    type: string | null
    gender: string | null
    position: string | null
    grade: string | null
    section: string | null
    dob: Date | null
    email: string | null
    mobile: string | null
    vacchist: string | null
    photo: string | null
    manager: string | null
    isactive: number | null
    is_situation: string | null
    username: string | null
    password: string | null
    level: number | null
    status: number | null
    prevsch: string | null
    prevschcountry: string | null
    lrn: string | null
    uniqid: string | null
    tf: string | null
    country: string | null
    nationality: string | null
    nationalities: string | null
    religion: string | null
    guardianname: string | null
    guardianemail: string | null
    guardianphone: string | null
    referral: string | null
    apptype: string | null
    sy: string | null
    strand: string | null
    visa: string | null
    earlybird: number | null
    modelrelease: number | null
    feepolicy: number | null
    refund: number | null
    tos: number | null
    empno: string | null
    isESL: number | null
    house: string | null
    isofficial: number | null
  }

  export type Users24MaxAggregateOutputType = {
    id: number | null
    rfid: bigint | null
    fname: string | null
    mname: string | null
    lname: string | null
    type: string | null
    gender: string | null
    position: string | null
    grade: string | null
    section: string | null
    dob: Date | null
    email: string | null
    mobile: string | null
    vacchist: string | null
    photo: string | null
    manager: string | null
    isactive: number | null
    is_situation: string | null
    username: string | null
    password: string | null
    level: number | null
    status: number | null
    prevsch: string | null
    prevschcountry: string | null
    lrn: string | null
    uniqid: string | null
    tf: string | null
    country: string | null
    nationality: string | null
    nationalities: string | null
    religion: string | null
    guardianname: string | null
    guardianemail: string | null
    guardianphone: string | null
    referral: string | null
    apptype: string | null
    sy: string | null
    strand: string | null
    visa: string | null
    earlybird: number | null
    modelrelease: number | null
    feepolicy: number | null
    refund: number | null
    tos: number | null
    empno: string | null
    isESL: number | null
    house: string | null
    isofficial: number | null
  }

  export type Users24CountAggregateOutputType = {
    id: number
    rfid: number
    fname: number
    mname: number
    lname: number
    type: number
    gender: number
    position: number
    grade: number
    section: number
    dob: number
    email: number
    mobile: number
    vacchist: number
    photo: number
    manager: number
    isactive: number
    is_situation: number
    username: number
    password: number
    level: number
    status: number
    prevsch: number
    prevschcountry: number
    lrn: number
    uniqid: number
    tf: number
    country: number
    nationality: number
    nationalities: number
    religion: number
    guardianname: number
    guardianemail: number
    guardianphone: number
    referral: number
    apptype: number
    sy: number
    strand: number
    visa: number
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: number
    isESL: number
    house: number
    isofficial: number
    _all: number
  }


  export type Users24AvgAggregateInputType = {
    id?: true
    rfid?: true
    isactive?: true
    level?: true
    status?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
    isESL?: true
    isofficial?: true
  }

  export type Users24SumAggregateInputType = {
    id?: true
    rfid?: true
    isactive?: true
    level?: true
    status?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
    isESL?: true
    isofficial?: true
  }

  export type Users24MinAggregateInputType = {
    id?: true
    rfid?: true
    fname?: true
    mname?: true
    lname?: true
    type?: true
    gender?: true
    position?: true
    grade?: true
    section?: true
    dob?: true
    email?: true
    mobile?: true
    vacchist?: true
    photo?: true
    manager?: true
    isactive?: true
    is_situation?: true
    username?: true
    password?: true
    level?: true
    status?: true
    prevsch?: true
    prevschcountry?: true
    lrn?: true
    uniqid?: true
    tf?: true
    country?: true
    nationality?: true
    nationalities?: true
    religion?: true
    guardianname?: true
    guardianemail?: true
    guardianphone?: true
    referral?: true
    apptype?: true
    sy?: true
    strand?: true
    visa?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
    empno?: true
    isESL?: true
    house?: true
    isofficial?: true
  }

  export type Users24MaxAggregateInputType = {
    id?: true
    rfid?: true
    fname?: true
    mname?: true
    lname?: true
    type?: true
    gender?: true
    position?: true
    grade?: true
    section?: true
    dob?: true
    email?: true
    mobile?: true
    vacchist?: true
    photo?: true
    manager?: true
    isactive?: true
    is_situation?: true
    username?: true
    password?: true
    level?: true
    status?: true
    prevsch?: true
    prevschcountry?: true
    lrn?: true
    uniqid?: true
    tf?: true
    country?: true
    nationality?: true
    nationalities?: true
    religion?: true
    guardianname?: true
    guardianemail?: true
    guardianphone?: true
    referral?: true
    apptype?: true
    sy?: true
    strand?: true
    visa?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
    empno?: true
    isESL?: true
    house?: true
    isofficial?: true
  }

  export type Users24CountAggregateInputType = {
    id?: true
    rfid?: true
    fname?: true
    mname?: true
    lname?: true
    type?: true
    gender?: true
    position?: true
    grade?: true
    section?: true
    dob?: true
    email?: true
    mobile?: true
    vacchist?: true
    photo?: true
    manager?: true
    isactive?: true
    is_situation?: true
    username?: true
    password?: true
    level?: true
    status?: true
    prevsch?: true
    prevschcountry?: true
    lrn?: true
    uniqid?: true
    tf?: true
    country?: true
    nationality?: true
    nationalities?: true
    religion?: true
    guardianname?: true
    guardianemail?: true
    guardianphone?: true
    referral?: true
    apptype?: true
    sy?: true
    strand?: true
    visa?: true
    earlybird?: true
    modelrelease?: true
    feepolicy?: true
    refund?: true
    tos?: true
    empno?: true
    isESL?: true
    house?: true
    isofficial?: true
    _all?: true
  }

  export type Users24AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users24 to aggregate.
     */
    where?: users24WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users24s to fetch.
     */
    orderBy?: users24OrderByWithRelationInput | users24OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: users24WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users24s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users24s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users24s
    **/
    _count?: true | Users24CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Users24AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Users24SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users24MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users24MaxAggregateInputType
  }

  export type GetUsers24AggregateType<T extends Users24AggregateArgs> = {
        [P in keyof T & keyof AggregateUsers24]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers24[P]>
      : GetScalarType<T[P], AggregateUsers24[P]>
  }




  export type users24GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: users24WhereInput
    orderBy?: users24OrderByWithAggregationInput | users24OrderByWithAggregationInput[]
    by: Users24ScalarFieldEnum[] | Users24ScalarFieldEnum
    having?: users24ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users24CountAggregateInputType | true
    _avg?: Users24AvgAggregateInputType
    _sum?: Users24SumAggregateInputType
    _min?: Users24MinAggregateInputType
    _max?: Users24MaxAggregateInputType
  }

  export type Users24GroupByOutputType = {
    id: number
    rfid: bigint
    fname: string
    mname: string
    lname: string
    type: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    is_situation: string
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    nationalities: string
    religion: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: string
    isESL: number
    house: string
    isofficial: number
    _count: Users24CountAggregateOutputType | null
    _avg: Users24AvgAggregateOutputType | null
    _sum: Users24SumAggregateOutputType | null
    _min: Users24MinAggregateOutputType | null
    _max: Users24MaxAggregateOutputType | null
  }

  type GetUsers24GroupByPayload<T extends users24GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users24GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users24GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users24GroupByOutputType[P]>
            : GetScalarType<T[P], Users24GroupByOutputType[P]>
        }
      >
    >


  export type users24Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rfid?: boolean
    fname?: boolean
    mname?: boolean
    lname?: boolean
    type?: boolean
    gender?: boolean
    position?: boolean
    grade?: boolean
    section?: boolean
    dob?: boolean
    email?: boolean
    mobile?: boolean
    vacchist?: boolean
    photo?: boolean
    manager?: boolean
    isactive?: boolean
    is_situation?: boolean
    username?: boolean
    password?: boolean
    level?: boolean
    status?: boolean
    prevsch?: boolean
    prevschcountry?: boolean
    lrn?: boolean
    uniqid?: boolean
    tf?: boolean
    country?: boolean
    nationality?: boolean
    nationalities?: boolean
    religion?: boolean
    guardianname?: boolean
    guardianemail?: boolean
    guardianphone?: boolean
    referral?: boolean
    apptype?: boolean
    sy?: boolean
    strand?: boolean
    visa?: boolean
    earlybird?: boolean
    modelrelease?: boolean
    feepolicy?: boolean
    refund?: boolean
    tos?: boolean
    empno?: boolean
    isESL?: boolean
    house?: boolean
    isofficial?: boolean
  }, ExtArgs["result"]["users24"]>



  export type users24SelectScalar = {
    id?: boolean
    rfid?: boolean
    fname?: boolean
    mname?: boolean
    lname?: boolean
    type?: boolean
    gender?: boolean
    position?: boolean
    grade?: boolean
    section?: boolean
    dob?: boolean
    email?: boolean
    mobile?: boolean
    vacchist?: boolean
    photo?: boolean
    manager?: boolean
    isactive?: boolean
    is_situation?: boolean
    username?: boolean
    password?: boolean
    level?: boolean
    status?: boolean
    prevsch?: boolean
    prevschcountry?: boolean
    lrn?: boolean
    uniqid?: boolean
    tf?: boolean
    country?: boolean
    nationality?: boolean
    nationalities?: boolean
    religion?: boolean
    guardianname?: boolean
    guardianemail?: boolean
    guardianphone?: boolean
    referral?: boolean
    apptype?: boolean
    sy?: boolean
    strand?: boolean
    visa?: boolean
    earlybird?: boolean
    modelrelease?: boolean
    feepolicy?: boolean
    refund?: boolean
    tos?: boolean
    empno?: boolean
    isESL?: boolean
    house?: boolean
    isofficial?: boolean
  }

  export type users24Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rfid" | "fname" | "mname" | "lname" | "type" | "gender" | "position" | "grade" | "section" | "dob" | "email" | "mobile" | "vacchist" | "photo" | "manager" | "isactive" | "is_situation" | "username" | "password" | "level" | "status" | "prevsch" | "prevschcountry" | "lrn" | "uniqid" | "tf" | "country" | "nationality" | "nationalities" | "religion" | "guardianname" | "guardianemail" | "guardianphone" | "referral" | "apptype" | "sy" | "strand" | "visa" | "earlybird" | "modelrelease" | "feepolicy" | "refund" | "tos" | "empno" | "isESL" | "house" | "isofficial", ExtArgs["result"]["users24"]>

  export type $users24Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users24"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rfid: bigint
      fname: string
      mname: string
      lname: string
      type: string
      gender: string
      position: string
      grade: string
      section: string
      dob: Date
      email: string
      mobile: string
      vacchist: string
      photo: string
      manager: string
      isactive: number
      is_situation: string
      username: string
      password: string
      level: number
      status: number
      prevsch: string
      prevschcountry: string
      lrn: string
      uniqid: string
      tf: string
      country: string
      nationality: string
      nationalities: string
      religion: string
      guardianname: string
      guardianemail: string
      guardianphone: string
      referral: string
      apptype: string
      sy: string
      strand: string
      visa: string
      earlybird: number
      modelrelease: number
      feepolicy: number
      refund: number
      tos: number
      empno: string
      isESL: number
      house: string
      isofficial: number
    }, ExtArgs["result"]["users24"]>
    composites: {}
  }

  type users24GetPayload<S extends boolean | null | undefined | users24DefaultArgs> = $Result.GetResult<Prisma.$users24Payload, S>

  type users24CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<users24FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Users24CountAggregateInputType | true
    }

  export interface users24Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users24'], meta: { name: 'users24' } }
    /**
     * Find zero or one Users24 that matches the filter.
     * @param {users24FindUniqueArgs} args - Arguments to find a Users24
     * @example
     * // Get one Users24
     * const users24 = await prisma.users24.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends users24FindUniqueArgs>(args: SelectSubset<T, users24FindUniqueArgs<ExtArgs>>): Prisma__users24Client<$Result.GetResult<Prisma.$users24Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users24 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {users24FindUniqueOrThrowArgs} args - Arguments to find a Users24
     * @example
     * // Get one Users24
     * const users24 = await prisma.users24.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends users24FindUniqueOrThrowArgs>(args: SelectSubset<T, users24FindUniqueOrThrowArgs<ExtArgs>>): Prisma__users24Client<$Result.GetResult<Prisma.$users24Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users24 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users24FindFirstArgs} args - Arguments to find a Users24
     * @example
     * // Get one Users24
     * const users24 = await prisma.users24.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends users24FindFirstArgs>(args?: SelectSubset<T, users24FindFirstArgs<ExtArgs>>): Prisma__users24Client<$Result.GetResult<Prisma.$users24Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users24 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users24FindFirstOrThrowArgs} args - Arguments to find a Users24
     * @example
     * // Get one Users24
     * const users24 = await prisma.users24.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends users24FindFirstOrThrowArgs>(args?: SelectSubset<T, users24FindFirstOrThrowArgs<ExtArgs>>): Prisma__users24Client<$Result.GetResult<Prisma.$users24Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users24s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users24FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users24s
     * const users24s = await prisma.users24.findMany()
     * 
     * // Get first 10 Users24s
     * const users24s = await prisma.users24.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const users24WithIdOnly = await prisma.users24.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends users24FindManyArgs>(args?: SelectSubset<T, users24FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$users24Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users24.
     * @param {users24CreateArgs} args - Arguments to create a Users24.
     * @example
     * // Create one Users24
     * const Users24 = await prisma.users24.create({
     *   data: {
     *     // ... data to create a Users24
     *   }
     * })
     * 
     */
    create<T extends users24CreateArgs>(args: SelectSubset<T, users24CreateArgs<ExtArgs>>): Prisma__users24Client<$Result.GetResult<Prisma.$users24Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users24s.
     * @param {users24CreateManyArgs} args - Arguments to create many Users24s.
     * @example
     * // Create many Users24s
     * const users24 = await prisma.users24.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends users24CreateManyArgs>(args?: SelectSubset<T, users24CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users24.
     * @param {users24DeleteArgs} args - Arguments to delete one Users24.
     * @example
     * // Delete one Users24
     * const Users24 = await prisma.users24.delete({
     *   where: {
     *     // ... filter to delete one Users24
     *   }
     * })
     * 
     */
    delete<T extends users24DeleteArgs>(args: SelectSubset<T, users24DeleteArgs<ExtArgs>>): Prisma__users24Client<$Result.GetResult<Prisma.$users24Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users24.
     * @param {users24UpdateArgs} args - Arguments to update one Users24.
     * @example
     * // Update one Users24
     * const users24 = await prisma.users24.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends users24UpdateArgs>(args: SelectSubset<T, users24UpdateArgs<ExtArgs>>): Prisma__users24Client<$Result.GetResult<Prisma.$users24Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users24s.
     * @param {users24DeleteManyArgs} args - Arguments to filter Users24s to delete.
     * @example
     * // Delete a few Users24s
     * const { count } = await prisma.users24.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends users24DeleteManyArgs>(args?: SelectSubset<T, users24DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users24s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users24UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users24s
     * const users24 = await prisma.users24.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends users24UpdateManyArgs>(args: SelectSubset<T, users24UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users24.
     * @param {users24UpsertArgs} args - Arguments to update or create a Users24.
     * @example
     * // Update or create a Users24
     * const users24 = await prisma.users24.upsert({
     *   create: {
     *     // ... data to create a Users24
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users24 we want to update
     *   }
     * })
     */
    upsert<T extends users24UpsertArgs>(args: SelectSubset<T, users24UpsertArgs<ExtArgs>>): Prisma__users24Client<$Result.GetResult<Prisma.$users24Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users24s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users24CountArgs} args - Arguments to filter Users24s to count.
     * @example
     * // Count the number of Users24s
     * const count = await prisma.users24.count({
     *   where: {
     *     // ... the filter for the Users24s we want to count
     *   }
     * })
    **/
    count<T extends users24CountArgs>(
      args?: Subset<T, users24CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users24CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users24.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users24AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users24AggregateArgs>(args: Subset<T, Users24AggregateArgs>): Prisma.PrismaPromise<GetUsers24AggregateType<T>>

    /**
     * Group by Users24.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users24GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends users24GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: users24GroupByArgs['orderBy'] }
        : { orderBy?: users24GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, users24GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers24GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users24 model
   */
  readonly fields: users24FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users24.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__users24Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users24 model
   */
  interface users24FieldRefs {
    readonly id: FieldRef<"users24", 'Int'>
    readonly rfid: FieldRef<"users24", 'BigInt'>
    readonly fname: FieldRef<"users24", 'String'>
    readonly mname: FieldRef<"users24", 'String'>
    readonly lname: FieldRef<"users24", 'String'>
    readonly type: FieldRef<"users24", 'String'>
    readonly gender: FieldRef<"users24", 'String'>
    readonly position: FieldRef<"users24", 'String'>
    readonly grade: FieldRef<"users24", 'String'>
    readonly section: FieldRef<"users24", 'String'>
    readonly dob: FieldRef<"users24", 'DateTime'>
    readonly email: FieldRef<"users24", 'String'>
    readonly mobile: FieldRef<"users24", 'String'>
    readonly vacchist: FieldRef<"users24", 'String'>
    readonly photo: FieldRef<"users24", 'String'>
    readonly manager: FieldRef<"users24", 'String'>
    readonly isactive: FieldRef<"users24", 'Int'>
    readonly is_situation: FieldRef<"users24", 'String'>
    readonly username: FieldRef<"users24", 'String'>
    readonly password: FieldRef<"users24", 'String'>
    readonly level: FieldRef<"users24", 'Int'>
    readonly status: FieldRef<"users24", 'Int'>
    readonly prevsch: FieldRef<"users24", 'String'>
    readonly prevschcountry: FieldRef<"users24", 'String'>
    readonly lrn: FieldRef<"users24", 'String'>
    readonly uniqid: FieldRef<"users24", 'String'>
    readonly tf: FieldRef<"users24", 'String'>
    readonly country: FieldRef<"users24", 'String'>
    readonly nationality: FieldRef<"users24", 'String'>
    readonly nationalities: FieldRef<"users24", 'String'>
    readonly religion: FieldRef<"users24", 'String'>
    readonly guardianname: FieldRef<"users24", 'String'>
    readonly guardianemail: FieldRef<"users24", 'String'>
    readonly guardianphone: FieldRef<"users24", 'String'>
    readonly referral: FieldRef<"users24", 'String'>
    readonly apptype: FieldRef<"users24", 'String'>
    readonly sy: FieldRef<"users24", 'String'>
    readonly strand: FieldRef<"users24", 'String'>
    readonly visa: FieldRef<"users24", 'String'>
    readonly earlybird: FieldRef<"users24", 'Int'>
    readonly modelrelease: FieldRef<"users24", 'Int'>
    readonly feepolicy: FieldRef<"users24", 'Int'>
    readonly refund: FieldRef<"users24", 'Int'>
    readonly tos: FieldRef<"users24", 'Int'>
    readonly empno: FieldRef<"users24", 'String'>
    readonly isESL: FieldRef<"users24", 'Int'>
    readonly house: FieldRef<"users24", 'String'>
    readonly isofficial: FieldRef<"users24", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * users24 findUnique
   */
  export type users24FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users24
     */
    select?: users24Select<ExtArgs> | null
    /**
     * Omit specific fields from the users24
     */
    omit?: users24Omit<ExtArgs> | null
    /**
     * Filter, which users24 to fetch.
     */
    where: users24WhereUniqueInput
  }

  /**
   * users24 findUniqueOrThrow
   */
  export type users24FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users24
     */
    select?: users24Select<ExtArgs> | null
    /**
     * Omit specific fields from the users24
     */
    omit?: users24Omit<ExtArgs> | null
    /**
     * Filter, which users24 to fetch.
     */
    where: users24WhereUniqueInput
  }

  /**
   * users24 findFirst
   */
  export type users24FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users24
     */
    select?: users24Select<ExtArgs> | null
    /**
     * Omit specific fields from the users24
     */
    omit?: users24Omit<ExtArgs> | null
    /**
     * Filter, which users24 to fetch.
     */
    where?: users24WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users24s to fetch.
     */
    orderBy?: users24OrderByWithRelationInput | users24OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users24s.
     */
    cursor?: users24WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users24s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users24s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users24s.
     */
    distinct?: Users24ScalarFieldEnum | Users24ScalarFieldEnum[]
  }

  /**
   * users24 findFirstOrThrow
   */
  export type users24FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users24
     */
    select?: users24Select<ExtArgs> | null
    /**
     * Omit specific fields from the users24
     */
    omit?: users24Omit<ExtArgs> | null
    /**
     * Filter, which users24 to fetch.
     */
    where?: users24WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users24s to fetch.
     */
    orderBy?: users24OrderByWithRelationInput | users24OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users24s.
     */
    cursor?: users24WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users24s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users24s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users24s.
     */
    distinct?: Users24ScalarFieldEnum | Users24ScalarFieldEnum[]
  }

  /**
   * users24 findMany
   */
  export type users24FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users24
     */
    select?: users24Select<ExtArgs> | null
    /**
     * Omit specific fields from the users24
     */
    omit?: users24Omit<ExtArgs> | null
    /**
     * Filter, which users24s to fetch.
     */
    where?: users24WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users24s to fetch.
     */
    orderBy?: users24OrderByWithRelationInput | users24OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users24s.
     */
    cursor?: users24WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users24s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users24s.
     */
    skip?: number
    distinct?: Users24ScalarFieldEnum | Users24ScalarFieldEnum[]
  }

  /**
   * users24 create
   */
  export type users24CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users24
     */
    select?: users24Select<ExtArgs> | null
    /**
     * Omit specific fields from the users24
     */
    omit?: users24Omit<ExtArgs> | null
    /**
     * The data needed to create a users24.
     */
    data: XOR<users24CreateInput, users24UncheckedCreateInput>
  }

  /**
   * users24 createMany
   */
  export type users24CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users24s.
     */
    data: users24CreateManyInput | users24CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users24 update
   */
  export type users24UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users24
     */
    select?: users24Select<ExtArgs> | null
    /**
     * Omit specific fields from the users24
     */
    omit?: users24Omit<ExtArgs> | null
    /**
     * The data needed to update a users24.
     */
    data: XOR<users24UpdateInput, users24UncheckedUpdateInput>
    /**
     * Choose, which users24 to update.
     */
    where: users24WhereUniqueInput
  }

  /**
   * users24 updateMany
   */
  export type users24UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users24s.
     */
    data: XOR<users24UpdateManyMutationInput, users24UncheckedUpdateManyInput>
    /**
     * Filter which users24s to update
     */
    where?: users24WhereInput
    /**
     * Limit how many users24s to update.
     */
    limit?: number
  }

  /**
   * users24 upsert
   */
  export type users24UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users24
     */
    select?: users24Select<ExtArgs> | null
    /**
     * Omit specific fields from the users24
     */
    omit?: users24Omit<ExtArgs> | null
    /**
     * The filter to search for the users24 to update in case it exists.
     */
    where: users24WhereUniqueInput
    /**
     * In case the users24 found by the `where` argument doesn't exist, create a new users24 with this data.
     */
    create: XOR<users24CreateInput, users24UncheckedCreateInput>
    /**
     * In case the users24 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<users24UpdateInput, users24UncheckedUpdateInput>
  }

  /**
   * users24 delete
   */
  export type users24DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users24
     */
    select?: users24Select<ExtArgs> | null
    /**
     * Omit specific fields from the users24
     */
    omit?: users24Omit<ExtArgs> | null
    /**
     * Filter which users24 to delete.
     */
    where: users24WhereUniqueInput
  }

  /**
   * users24 deleteMany
   */
  export type users24DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users24s to delete
     */
    where?: users24WhereInput
    /**
     * Limit how many users24s to delete.
     */
    limit?: number
  }

  /**
   * users24 without action
   */
  export type users24DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users24
     */
    select?: users24Select<ExtArgs> | null
    /**
     * Omit specific fields from the users24
     */
    omit?: users24Omit<ExtArgs> | null
  }


  /**
   * Model visitorlog
   */

  export type AggregateVisitorlog = {
    _count: VisitorlogCountAggregateOutputType | null
    _avg: VisitorlogAvgAggregateOutputType | null
    _sum: VisitorlogSumAggregateOutputType | null
    _min: VisitorlogMinAggregateOutputType | null
    _max: VisitorlogMaxAggregateOutputType | null
  }

  export type VisitorlogAvgAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type VisitorlogSumAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type VisitorlogMinAggregateOutputType = {
    id: number | null
    name: string | null
    rfid: string | null
    comment: string | null
    registerdate: Date | null
    status: number | null
  }

  export type VisitorlogMaxAggregateOutputType = {
    id: number | null
    name: string | null
    rfid: string | null
    comment: string | null
    registerdate: Date | null
    status: number | null
  }

  export type VisitorlogCountAggregateOutputType = {
    id: number
    name: number
    rfid: number
    comment: number
    registerdate: number
    status: number
    _all: number
  }


  export type VisitorlogAvgAggregateInputType = {
    id?: true
    status?: true
  }

  export type VisitorlogSumAggregateInputType = {
    id?: true
    status?: true
  }

  export type VisitorlogMinAggregateInputType = {
    id?: true
    name?: true
    rfid?: true
    comment?: true
    registerdate?: true
    status?: true
  }

  export type VisitorlogMaxAggregateInputType = {
    id?: true
    name?: true
    rfid?: true
    comment?: true
    registerdate?: true
    status?: true
  }

  export type VisitorlogCountAggregateInputType = {
    id?: true
    name?: true
    rfid?: true
    comment?: true
    registerdate?: true
    status?: true
    _all?: true
  }

  export type VisitorlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which visitorlog to aggregate.
     */
    where?: visitorlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitorlogs to fetch.
     */
    orderBy?: visitorlogOrderByWithRelationInput | visitorlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: visitorlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitorlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitorlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned visitorlogs
    **/
    _count?: true | VisitorlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitorlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitorlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitorlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitorlogMaxAggregateInputType
  }

  export type GetVisitorlogAggregateType<T extends VisitorlogAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitorlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitorlog[P]>
      : GetScalarType<T[P], AggregateVisitorlog[P]>
  }




  export type visitorlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: visitorlogWhereInput
    orderBy?: visitorlogOrderByWithAggregationInput | visitorlogOrderByWithAggregationInput[]
    by: VisitorlogScalarFieldEnum[] | VisitorlogScalarFieldEnum
    having?: visitorlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitorlogCountAggregateInputType | true
    _avg?: VisitorlogAvgAggregateInputType
    _sum?: VisitorlogSumAggregateInputType
    _min?: VisitorlogMinAggregateInputType
    _max?: VisitorlogMaxAggregateInputType
  }

  export type VisitorlogGroupByOutputType = {
    id: number
    name: string
    rfid: string
    comment: string
    registerdate: Date
    status: number
    _count: VisitorlogCountAggregateOutputType | null
    _avg: VisitorlogAvgAggregateOutputType | null
    _sum: VisitorlogSumAggregateOutputType | null
    _min: VisitorlogMinAggregateOutputType | null
    _max: VisitorlogMaxAggregateOutputType | null
  }

  type GetVisitorlogGroupByPayload<T extends visitorlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitorlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitorlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitorlogGroupByOutputType[P]>
            : GetScalarType<T[P], VisitorlogGroupByOutputType[P]>
        }
      >
    >


  export type visitorlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rfid?: boolean
    comment?: boolean
    registerdate?: boolean
    status?: boolean
  }, ExtArgs["result"]["visitorlog"]>



  export type visitorlogSelectScalar = {
    id?: boolean
    name?: boolean
    rfid?: boolean
    comment?: boolean
    registerdate?: boolean
    status?: boolean
  }

  export type visitorlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "rfid" | "comment" | "registerdate" | "status", ExtArgs["result"]["visitorlog"]>

  export type $visitorlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "visitorlog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      rfid: string
      comment: string
      registerdate: Date
      status: number
    }, ExtArgs["result"]["visitorlog"]>
    composites: {}
  }

  type visitorlogGetPayload<S extends boolean | null | undefined | visitorlogDefaultArgs> = $Result.GetResult<Prisma.$visitorlogPayload, S>

  type visitorlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<visitorlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitorlogCountAggregateInputType | true
    }

  export interface visitorlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['visitorlog'], meta: { name: 'visitorlog' } }
    /**
     * Find zero or one Visitorlog that matches the filter.
     * @param {visitorlogFindUniqueArgs} args - Arguments to find a Visitorlog
     * @example
     * // Get one Visitorlog
     * const visitorlog = await prisma.visitorlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends visitorlogFindUniqueArgs>(args: SelectSubset<T, visitorlogFindUniqueArgs<ExtArgs>>): Prisma__visitorlogClient<$Result.GetResult<Prisma.$visitorlogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Visitorlog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {visitorlogFindUniqueOrThrowArgs} args - Arguments to find a Visitorlog
     * @example
     * // Get one Visitorlog
     * const visitorlog = await prisma.visitorlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends visitorlogFindUniqueOrThrowArgs>(args: SelectSubset<T, visitorlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__visitorlogClient<$Result.GetResult<Prisma.$visitorlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitorlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitorlogFindFirstArgs} args - Arguments to find a Visitorlog
     * @example
     * // Get one Visitorlog
     * const visitorlog = await prisma.visitorlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends visitorlogFindFirstArgs>(args?: SelectSubset<T, visitorlogFindFirstArgs<ExtArgs>>): Prisma__visitorlogClient<$Result.GetResult<Prisma.$visitorlogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitorlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitorlogFindFirstOrThrowArgs} args - Arguments to find a Visitorlog
     * @example
     * // Get one Visitorlog
     * const visitorlog = await prisma.visitorlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends visitorlogFindFirstOrThrowArgs>(args?: SelectSubset<T, visitorlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__visitorlogClient<$Result.GetResult<Prisma.$visitorlogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visitorlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitorlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visitorlogs
     * const visitorlogs = await prisma.visitorlog.findMany()
     * 
     * // Get first 10 Visitorlogs
     * const visitorlogs = await prisma.visitorlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitorlogWithIdOnly = await prisma.visitorlog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends visitorlogFindManyArgs>(args?: SelectSubset<T, visitorlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$visitorlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Visitorlog.
     * @param {visitorlogCreateArgs} args - Arguments to create a Visitorlog.
     * @example
     * // Create one Visitorlog
     * const Visitorlog = await prisma.visitorlog.create({
     *   data: {
     *     // ... data to create a Visitorlog
     *   }
     * })
     * 
     */
    create<T extends visitorlogCreateArgs>(args: SelectSubset<T, visitorlogCreateArgs<ExtArgs>>): Prisma__visitorlogClient<$Result.GetResult<Prisma.$visitorlogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Visitorlogs.
     * @param {visitorlogCreateManyArgs} args - Arguments to create many Visitorlogs.
     * @example
     * // Create many Visitorlogs
     * const visitorlog = await prisma.visitorlog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends visitorlogCreateManyArgs>(args?: SelectSubset<T, visitorlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Visitorlog.
     * @param {visitorlogDeleteArgs} args - Arguments to delete one Visitorlog.
     * @example
     * // Delete one Visitorlog
     * const Visitorlog = await prisma.visitorlog.delete({
     *   where: {
     *     // ... filter to delete one Visitorlog
     *   }
     * })
     * 
     */
    delete<T extends visitorlogDeleteArgs>(args: SelectSubset<T, visitorlogDeleteArgs<ExtArgs>>): Prisma__visitorlogClient<$Result.GetResult<Prisma.$visitorlogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Visitorlog.
     * @param {visitorlogUpdateArgs} args - Arguments to update one Visitorlog.
     * @example
     * // Update one Visitorlog
     * const visitorlog = await prisma.visitorlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends visitorlogUpdateArgs>(args: SelectSubset<T, visitorlogUpdateArgs<ExtArgs>>): Prisma__visitorlogClient<$Result.GetResult<Prisma.$visitorlogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Visitorlogs.
     * @param {visitorlogDeleteManyArgs} args - Arguments to filter Visitorlogs to delete.
     * @example
     * // Delete a few Visitorlogs
     * const { count } = await prisma.visitorlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends visitorlogDeleteManyArgs>(args?: SelectSubset<T, visitorlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitorlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitorlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visitorlogs
     * const visitorlog = await prisma.visitorlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends visitorlogUpdateManyArgs>(args: SelectSubset<T, visitorlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visitorlog.
     * @param {visitorlogUpsertArgs} args - Arguments to update or create a Visitorlog.
     * @example
     * // Update or create a Visitorlog
     * const visitorlog = await prisma.visitorlog.upsert({
     *   create: {
     *     // ... data to create a Visitorlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visitorlog we want to update
     *   }
     * })
     */
    upsert<T extends visitorlogUpsertArgs>(args: SelectSubset<T, visitorlogUpsertArgs<ExtArgs>>): Prisma__visitorlogClient<$Result.GetResult<Prisma.$visitorlogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Visitorlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitorlogCountArgs} args - Arguments to filter Visitorlogs to count.
     * @example
     * // Count the number of Visitorlogs
     * const count = await prisma.visitorlog.count({
     *   where: {
     *     // ... the filter for the Visitorlogs we want to count
     *   }
     * })
    **/
    count<T extends visitorlogCountArgs>(
      args?: Subset<T, visitorlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitorlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visitorlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitorlogAggregateArgs>(args: Subset<T, VisitorlogAggregateArgs>): Prisma.PrismaPromise<GetVisitorlogAggregateType<T>>

    /**
     * Group by Visitorlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitorlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends visitorlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: visitorlogGroupByArgs['orderBy'] }
        : { orderBy?: visitorlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, visitorlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitorlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the visitorlog model
   */
  readonly fields: visitorlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for visitorlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__visitorlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the visitorlog model
   */
  interface visitorlogFieldRefs {
    readonly id: FieldRef<"visitorlog", 'Int'>
    readonly name: FieldRef<"visitorlog", 'String'>
    readonly rfid: FieldRef<"visitorlog", 'String'>
    readonly comment: FieldRef<"visitorlog", 'String'>
    readonly registerdate: FieldRef<"visitorlog", 'DateTime'>
    readonly status: FieldRef<"visitorlog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * visitorlog findUnique
   */
  export type visitorlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitorlog
     */
    select?: visitorlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visitorlog
     */
    omit?: visitorlogOmit<ExtArgs> | null
    /**
     * Filter, which visitorlog to fetch.
     */
    where: visitorlogWhereUniqueInput
  }

  /**
   * visitorlog findUniqueOrThrow
   */
  export type visitorlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitorlog
     */
    select?: visitorlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visitorlog
     */
    omit?: visitorlogOmit<ExtArgs> | null
    /**
     * Filter, which visitorlog to fetch.
     */
    where: visitorlogWhereUniqueInput
  }

  /**
   * visitorlog findFirst
   */
  export type visitorlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitorlog
     */
    select?: visitorlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visitorlog
     */
    omit?: visitorlogOmit<ExtArgs> | null
    /**
     * Filter, which visitorlog to fetch.
     */
    where?: visitorlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitorlogs to fetch.
     */
    orderBy?: visitorlogOrderByWithRelationInput | visitorlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for visitorlogs.
     */
    cursor?: visitorlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitorlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitorlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of visitorlogs.
     */
    distinct?: VisitorlogScalarFieldEnum | VisitorlogScalarFieldEnum[]
  }

  /**
   * visitorlog findFirstOrThrow
   */
  export type visitorlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitorlog
     */
    select?: visitorlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visitorlog
     */
    omit?: visitorlogOmit<ExtArgs> | null
    /**
     * Filter, which visitorlog to fetch.
     */
    where?: visitorlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitorlogs to fetch.
     */
    orderBy?: visitorlogOrderByWithRelationInput | visitorlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for visitorlogs.
     */
    cursor?: visitorlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitorlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitorlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of visitorlogs.
     */
    distinct?: VisitorlogScalarFieldEnum | VisitorlogScalarFieldEnum[]
  }

  /**
   * visitorlog findMany
   */
  export type visitorlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitorlog
     */
    select?: visitorlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visitorlog
     */
    omit?: visitorlogOmit<ExtArgs> | null
    /**
     * Filter, which visitorlogs to fetch.
     */
    where?: visitorlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitorlogs to fetch.
     */
    orderBy?: visitorlogOrderByWithRelationInput | visitorlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing visitorlogs.
     */
    cursor?: visitorlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitorlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitorlogs.
     */
    skip?: number
    distinct?: VisitorlogScalarFieldEnum | VisitorlogScalarFieldEnum[]
  }

  /**
   * visitorlog create
   */
  export type visitorlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitorlog
     */
    select?: visitorlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visitorlog
     */
    omit?: visitorlogOmit<ExtArgs> | null
    /**
     * The data needed to create a visitorlog.
     */
    data: XOR<visitorlogCreateInput, visitorlogUncheckedCreateInput>
  }

  /**
   * visitorlog createMany
   */
  export type visitorlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many visitorlogs.
     */
    data: visitorlogCreateManyInput | visitorlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * visitorlog update
   */
  export type visitorlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitorlog
     */
    select?: visitorlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visitorlog
     */
    omit?: visitorlogOmit<ExtArgs> | null
    /**
     * The data needed to update a visitorlog.
     */
    data: XOR<visitorlogUpdateInput, visitorlogUncheckedUpdateInput>
    /**
     * Choose, which visitorlog to update.
     */
    where: visitorlogWhereUniqueInput
  }

  /**
   * visitorlog updateMany
   */
  export type visitorlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update visitorlogs.
     */
    data: XOR<visitorlogUpdateManyMutationInput, visitorlogUncheckedUpdateManyInput>
    /**
     * Filter which visitorlogs to update
     */
    where?: visitorlogWhereInput
    /**
     * Limit how many visitorlogs to update.
     */
    limit?: number
  }

  /**
   * visitorlog upsert
   */
  export type visitorlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitorlog
     */
    select?: visitorlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visitorlog
     */
    omit?: visitorlogOmit<ExtArgs> | null
    /**
     * The filter to search for the visitorlog to update in case it exists.
     */
    where: visitorlogWhereUniqueInput
    /**
     * In case the visitorlog found by the `where` argument doesn't exist, create a new visitorlog with this data.
     */
    create: XOR<visitorlogCreateInput, visitorlogUncheckedCreateInput>
    /**
     * In case the visitorlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<visitorlogUpdateInput, visitorlogUncheckedUpdateInput>
  }

  /**
   * visitorlog delete
   */
  export type visitorlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitorlog
     */
    select?: visitorlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visitorlog
     */
    omit?: visitorlogOmit<ExtArgs> | null
    /**
     * Filter which visitorlog to delete.
     */
    where: visitorlogWhereUniqueInput
  }

  /**
   * visitorlog deleteMany
   */
  export type visitorlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which visitorlogs to delete
     */
    where?: visitorlogWhereInput
    /**
     * Limit how many visitorlogs to delete.
     */
    limit?: number
  }

  /**
   * visitorlog without action
   */
  export type visitorlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitorlog
     */
    select?: visitorlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the visitorlog
     */
    omit?: visitorlogOmit<ExtArgs> | null
  }


  /**
   * Model wispay
   */

  export type AggregateWispay = {
    _count: WispayCountAggregateOutputType | null
    _avg: WispayAvgAggregateOutputType | null
    _sum: WispaySumAggregateOutputType | null
    _min: WispayMinAggregateOutputType | null
    _max: WispayMaxAggregateOutputType | null
  }

  export type WispayAvgAggregateOutputType = {
    id: number | null
    debit: Decimal | null
    credit: Decimal | null
    rfid: number | null
    quantity: number | null
  }

  export type WispaySumAggregateOutputType = {
    id: number | null
    debit: Decimal | null
    credit: Decimal | null
    rfid: bigint | null
    quantity: number | null
  }

  export type WispayMinAggregateOutputType = {
    id: number | null
    debit: Decimal | null
    credit: Decimal | null
    rfid: bigint | null
    empid: string | null
    username: string | null
    refcode: string | null
    transdate: Date | null
    processedby: string | null
    product_type: string | null
    product_name: string | null
    quantity: number | null
    isAfterSchoolPayment: boolean | null
  }

  export type WispayMaxAggregateOutputType = {
    id: number | null
    debit: Decimal | null
    credit: Decimal | null
    rfid: bigint | null
    empid: string | null
    username: string | null
    refcode: string | null
    transdate: Date | null
    processedby: string | null
    product_type: string | null
    product_name: string | null
    quantity: number | null
    isAfterSchoolPayment: boolean | null
  }

  export type WispayCountAggregateOutputType = {
    id: number
    debit: number
    credit: number
    rfid: number
    empid: number
    username: number
    refcode: number
    transdate: number
    processedby: number
    product_type: number
    product_name: number
    quantity: number
    isAfterSchoolPayment: number
    _all: number
  }


  export type WispayAvgAggregateInputType = {
    id?: true
    debit?: true
    credit?: true
    rfid?: true
    quantity?: true
  }

  export type WispaySumAggregateInputType = {
    id?: true
    debit?: true
    credit?: true
    rfid?: true
    quantity?: true
  }

  export type WispayMinAggregateInputType = {
    id?: true
    debit?: true
    credit?: true
    rfid?: true
    empid?: true
    username?: true
    refcode?: true
    transdate?: true
    processedby?: true
    product_type?: true
    product_name?: true
    quantity?: true
    isAfterSchoolPayment?: true
  }

  export type WispayMaxAggregateInputType = {
    id?: true
    debit?: true
    credit?: true
    rfid?: true
    empid?: true
    username?: true
    refcode?: true
    transdate?: true
    processedby?: true
    product_type?: true
    product_name?: true
    quantity?: true
    isAfterSchoolPayment?: true
  }

  export type WispayCountAggregateInputType = {
    id?: true
    debit?: true
    credit?: true
    rfid?: true
    empid?: true
    username?: true
    refcode?: true
    transdate?: true
    processedby?: true
    product_type?: true
    product_name?: true
    quantity?: true
    isAfterSchoolPayment?: true
    _all?: true
  }

  export type WispayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wispay to aggregate.
     */
    where?: wispayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wispays to fetch.
     */
    orderBy?: wispayOrderByWithRelationInput | wispayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wispayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wispays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wispays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wispays
    **/
    _count?: true | WispayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WispayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WispaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WispayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WispayMaxAggregateInputType
  }

  export type GetWispayAggregateType<T extends WispayAggregateArgs> = {
        [P in keyof T & keyof AggregateWispay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWispay[P]>
      : GetScalarType<T[P], AggregateWispay[P]>
  }




  export type wispayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wispayWhereInput
    orderBy?: wispayOrderByWithAggregationInput | wispayOrderByWithAggregationInput[]
    by: WispayScalarFieldEnum[] | WispayScalarFieldEnum
    having?: wispayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WispayCountAggregateInputType | true
    _avg?: WispayAvgAggregateInputType
    _sum?: WispaySumAggregateInputType
    _min?: WispayMinAggregateInputType
    _max?: WispayMaxAggregateInputType
  }

  export type WispayGroupByOutputType = {
    id: number
    debit: Decimal
    credit: Decimal
    rfid: bigint
    empid: string
    username: string
    refcode: string
    transdate: Date
    processedby: string
    product_type: string
    product_name: string
    quantity: number
    isAfterSchoolPayment: boolean
    _count: WispayCountAggregateOutputType | null
    _avg: WispayAvgAggregateOutputType | null
    _sum: WispaySumAggregateOutputType | null
    _min: WispayMinAggregateOutputType | null
    _max: WispayMaxAggregateOutputType | null
  }

  type GetWispayGroupByPayload<T extends wispayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WispayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WispayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WispayGroupByOutputType[P]>
            : GetScalarType<T[P], WispayGroupByOutputType[P]>
        }
      >
    >


  export type wispaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debit?: boolean
    credit?: boolean
    rfid?: boolean
    empid?: boolean
    username?: boolean
    refcode?: boolean
    transdate?: boolean
    processedby?: boolean
    product_type?: boolean
    product_name?: boolean
    quantity?: boolean
    isAfterSchoolPayment?: boolean
  }, ExtArgs["result"]["wispay"]>



  export type wispaySelectScalar = {
    id?: boolean
    debit?: boolean
    credit?: boolean
    rfid?: boolean
    empid?: boolean
    username?: boolean
    refcode?: boolean
    transdate?: boolean
    processedby?: boolean
    product_type?: boolean
    product_name?: boolean
    quantity?: boolean
    isAfterSchoolPayment?: boolean
  }

  export type wispayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "debit" | "credit" | "rfid" | "empid" | "username" | "refcode" | "transdate" | "processedby" | "product_type" | "product_name" | "quantity" | "isAfterSchoolPayment", ExtArgs["result"]["wispay"]>

  export type $wispayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wispay"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      debit: Prisma.Decimal
      credit: Prisma.Decimal
      rfid: bigint
      empid: string
      username: string
      refcode: string
      transdate: Date
      processedby: string
      product_type: string
      product_name: string
      quantity: number
      isAfterSchoolPayment: boolean
    }, ExtArgs["result"]["wispay"]>
    composites: {}
  }

  type wispayGetPayload<S extends boolean | null | undefined | wispayDefaultArgs> = $Result.GetResult<Prisma.$wispayPayload, S>

  type wispayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<wispayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WispayCountAggregateInputType | true
    }

  export interface wispayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wispay'], meta: { name: 'wispay' } }
    /**
     * Find zero or one Wispay that matches the filter.
     * @param {wispayFindUniqueArgs} args - Arguments to find a Wispay
     * @example
     * // Get one Wispay
     * const wispay = await prisma.wispay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wispayFindUniqueArgs>(args: SelectSubset<T, wispayFindUniqueArgs<ExtArgs>>): Prisma__wispayClient<$Result.GetResult<Prisma.$wispayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wispay that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {wispayFindUniqueOrThrowArgs} args - Arguments to find a Wispay
     * @example
     * // Get one Wispay
     * const wispay = await prisma.wispay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wispayFindUniqueOrThrowArgs>(args: SelectSubset<T, wispayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wispayClient<$Result.GetResult<Prisma.$wispayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wispay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wispayFindFirstArgs} args - Arguments to find a Wispay
     * @example
     * // Get one Wispay
     * const wispay = await prisma.wispay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wispayFindFirstArgs>(args?: SelectSubset<T, wispayFindFirstArgs<ExtArgs>>): Prisma__wispayClient<$Result.GetResult<Prisma.$wispayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wispay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wispayFindFirstOrThrowArgs} args - Arguments to find a Wispay
     * @example
     * // Get one Wispay
     * const wispay = await prisma.wispay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wispayFindFirstOrThrowArgs>(args?: SelectSubset<T, wispayFindFirstOrThrowArgs<ExtArgs>>): Prisma__wispayClient<$Result.GetResult<Prisma.$wispayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wispays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wispayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wispays
     * const wispays = await prisma.wispay.findMany()
     * 
     * // Get first 10 Wispays
     * const wispays = await prisma.wispay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wispayWithIdOnly = await prisma.wispay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wispayFindManyArgs>(args?: SelectSubset<T, wispayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wispayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wispay.
     * @param {wispayCreateArgs} args - Arguments to create a Wispay.
     * @example
     * // Create one Wispay
     * const Wispay = await prisma.wispay.create({
     *   data: {
     *     // ... data to create a Wispay
     *   }
     * })
     * 
     */
    create<T extends wispayCreateArgs>(args: SelectSubset<T, wispayCreateArgs<ExtArgs>>): Prisma__wispayClient<$Result.GetResult<Prisma.$wispayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wispays.
     * @param {wispayCreateManyArgs} args - Arguments to create many Wispays.
     * @example
     * // Create many Wispays
     * const wispay = await prisma.wispay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wispayCreateManyArgs>(args?: SelectSubset<T, wispayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wispay.
     * @param {wispayDeleteArgs} args - Arguments to delete one Wispay.
     * @example
     * // Delete one Wispay
     * const Wispay = await prisma.wispay.delete({
     *   where: {
     *     // ... filter to delete one Wispay
     *   }
     * })
     * 
     */
    delete<T extends wispayDeleteArgs>(args: SelectSubset<T, wispayDeleteArgs<ExtArgs>>): Prisma__wispayClient<$Result.GetResult<Prisma.$wispayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wispay.
     * @param {wispayUpdateArgs} args - Arguments to update one Wispay.
     * @example
     * // Update one Wispay
     * const wispay = await prisma.wispay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wispayUpdateArgs>(args: SelectSubset<T, wispayUpdateArgs<ExtArgs>>): Prisma__wispayClient<$Result.GetResult<Prisma.$wispayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wispays.
     * @param {wispayDeleteManyArgs} args - Arguments to filter Wispays to delete.
     * @example
     * // Delete a few Wispays
     * const { count } = await prisma.wispay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wispayDeleteManyArgs>(args?: SelectSubset<T, wispayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wispays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wispayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wispays
     * const wispay = await prisma.wispay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wispayUpdateManyArgs>(args: SelectSubset<T, wispayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wispay.
     * @param {wispayUpsertArgs} args - Arguments to update or create a Wispay.
     * @example
     * // Update or create a Wispay
     * const wispay = await prisma.wispay.upsert({
     *   create: {
     *     // ... data to create a Wispay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wispay we want to update
     *   }
     * })
     */
    upsert<T extends wispayUpsertArgs>(args: SelectSubset<T, wispayUpsertArgs<ExtArgs>>): Prisma__wispayClient<$Result.GetResult<Prisma.$wispayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wispays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wispayCountArgs} args - Arguments to filter Wispays to count.
     * @example
     * // Count the number of Wispays
     * const count = await prisma.wispay.count({
     *   where: {
     *     // ... the filter for the Wispays we want to count
     *   }
     * })
    **/
    count<T extends wispayCountArgs>(
      args?: Subset<T, wispayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WispayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wispay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WispayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WispayAggregateArgs>(args: Subset<T, WispayAggregateArgs>): Prisma.PrismaPromise<GetWispayAggregateType<T>>

    /**
     * Group by Wispay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wispayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wispayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wispayGroupByArgs['orderBy'] }
        : { orderBy?: wispayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wispayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWispayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wispay model
   */
  readonly fields: wispayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wispay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wispayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wispay model
   */
  interface wispayFieldRefs {
    readonly id: FieldRef<"wispay", 'Int'>
    readonly debit: FieldRef<"wispay", 'Decimal'>
    readonly credit: FieldRef<"wispay", 'Decimal'>
    readonly rfid: FieldRef<"wispay", 'BigInt'>
    readonly empid: FieldRef<"wispay", 'String'>
    readonly username: FieldRef<"wispay", 'String'>
    readonly refcode: FieldRef<"wispay", 'String'>
    readonly transdate: FieldRef<"wispay", 'DateTime'>
    readonly processedby: FieldRef<"wispay", 'String'>
    readonly product_type: FieldRef<"wispay", 'String'>
    readonly product_name: FieldRef<"wispay", 'String'>
    readonly quantity: FieldRef<"wispay", 'Float'>
    readonly isAfterSchoolPayment: FieldRef<"wispay", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * wispay findUnique
   */
  export type wispayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wispay
     */
    select?: wispaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wispay
     */
    omit?: wispayOmit<ExtArgs> | null
    /**
     * Filter, which wispay to fetch.
     */
    where: wispayWhereUniqueInput
  }

  /**
   * wispay findUniqueOrThrow
   */
  export type wispayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wispay
     */
    select?: wispaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wispay
     */
    omit?: wispayOmit<ExtArgs> | null
    /**
     * Filter, which wispay to fetch.
     */
    where: wispayWhereUniqueInput
  }

  /**
   * wispay findFirst
   */
  export type wispayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wispay
     */
    select?: wispaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wispay
     */
    omit?: wispayOmit<ExtArgs> | null
    /**
     * Filter, which wispay to fetch.
     */
    where?: wispayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wispays to fetch.
     */
    orderBy?: wispayOrderByWithRelationInput | wispayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wispays.
     */
    cursor?: wispayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wispays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wispays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wispays.
     */
    distinct?: WispayScalarFieldEnum | WispayScalarFieldEnum[]
  }

  /**
   * wispay findFirstOrThrow
   */
  export type wispayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wispay
     */
    select?: wispaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wispay
     */
    omit?: wispayOmit<ExtArgs> | null
    /**
     * Filter, which wispay to fetch.
     */
    where?: wispayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wispays to fetch.
     */
    orderBy?: wispayOrderByWithRelationInput | wispayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wispays.
     */
    cursor?: wispayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wispays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wispays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wispays.
     */
    distinct?: WispayScalarFieldEnum | WispayScalarFieldEnum[]
  }

  /**
   * wispay findMany
   */
  export type wispayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wispay
     */
    select?: wispaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wispay
     */
    omit?: wispayOmit<ExtArgs> | null
    /**
     * Filter, which wispays to fetch.
     */
    where?: wispayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wispays to fetch.
     */
    orderBy?: wispayOrderByWithRelationInput | wispayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wispays.
     */
    cursor?: wispayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wispays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wispays.
     */
    skip?: number
    distinct?: WispayScalarFieldEnum | WispayScalarFieldEnum[]
  }

  /**
   * wispay create
   */
  export type wispayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wispay
     */
    select?: wispaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wispay
     */
    omit?: wispayOmit<ExtArgs> | null
    /**
     * The data needed to create a wispay.
     */
    data: XOR<wispayCreateInput, wispayUncheckedCreateInput>
  }

  /**
   * wispay createMany
   */
  export type wispayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wispays.
     */
    data: wispayCreateManyInput | wispayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wispay update
   */
  export type wispayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wispay
     */
    select?: wispaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wispay
     */
    omit?: wispayOmit<ExtArgs> | null
    /**
     * The data needed to update a wispay.
     */
    data: XOR<wispayUpdateInput, wispayUncheckedUpdateInput>
    /**
     * Choose, which wispay to update.
     */
    where: wispayWhereUniqueInput
  }

  /**
   * wispay updateMany
   */
  export type wispayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wispays.
     */
    data: XOR<wispayUpdateManyMutationInput, wispayUncheckedUpdateManyInput>
    /**
     * Filter which wispays to update
     */
    where?: wispayWhereInput
    /**
     * Limit how many wispays to update.
     */
    limit?: number
  }

  /**
   * wispay upsert
   */
  export type wispayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wispay
     */
    select?: wispaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wispay
     */
    omit?: wispayOmit<ExtArgs> | null
    /**
     * The filter to search for the wispay to update in case it exists.
     */
    where: wispayWhereUniqueInput
    /**
     * In case the wispay found by the `where` argument doesn't exist, create a new wispay with this data.
     */
    create: XOR<wispayCreateInput, wispayUncheckedCreateInput>
    /**
     * In case the wispay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wispayUpdateInput, wispayUncheckedUpdateInput>
  }

  /**
   * wispay delete
   */
  export type wispayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wispay
     */
    select?: wispaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wispay
     */
    omit?: wispayOmit<ExtArgs> | null
    /**
     * Filter which wispay to delete.
     */
    where: wispayWhereUniqueInput
  }

  /**
   * wispay deleteMany
   */
  export type wispayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wispays to delete
     */
    where?: wispayWhereInput
    /**
     * Limit how many wispays to delete.
     */
    limit?: number
  }

  /**
   * wispay without action
   */
  export type wispayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wispay
     */
    select?: wispaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the wispay
     */
    omit?: wispayOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ActivitysessionScalarFieldEnum: {
    id: 'id',
    activityId: 'activityId',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivitysessionScalarFieldEnum = (typeof ActivitysessionScalarFieldEnum)[keyof typeof ActivitysessionScalarFieldEnum]


  export const AfterschoolactivityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    location: 'location',
    coachName: 'coachName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    photo: 'photo'
  };

  export type AfterschoolactivityScalarFieldEnum = (typeof AfterschoolactivityScalarFieldEnum)[keyof typeof AfterschoolactivityScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    status: 'status'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const Attendance_libraryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    date: 'date',
    rfid: 'rfid'
  };

  export type Attendance_libraryScalarFieldEnum = (typeof Attendance_libraryScalarFieldEnum)[keyof typeof Attendance_libraryScalarFieldEnum]


  export const BorrowersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    rfid: 'rfid',
    title: 'title',
    date_borrowed: 'date_borrowed',
    date_returned: 'date_returned',
    remarks: 'remarks'
  };

  export type BorrowersScalarFieldEnum = (typeof BorrowersScalarFieldEnum)[keyof typeof BorrowersScalarFieldEnum]


  export const BuyersScalarFieldEnum: {
    buyer_id: 'buyer_id',
    buyer_name: 'buyer_name',
    rfid: 'rfid'
  };

  export type BuyersScalarFieldEnum = (typeof BuyersScalarFieldEnum)[keyof typeof BuyersScalarFieldEnum]


  export const Clinic_historyScalarFieldEnum: {
    Id: 'Id',
    name: 'name',
    grade: 'grade',
    complaint: 'complaint',
    diagnose: 'diagnose',
    treatment: 'treatment',
    vital_signs: 'vital_signs',
    time_in: 'time_in',
    time_out: 'time_out',
    date: 'date',
    remarks: 'remarks'
  };

  export type Clinic_historyScalarFieldEnum = (typeof Clinic_historyScalarFieldEnum)[keyof typeof Clinic_historyScalarFieldEnum]


  export const CountriesScalarFieldEnum: {
    id: 'id',
    countryCode: 'countryCode',
    countryName: 'countryName',
    currencyCode: 'currencyCode',
    fipsCode: 'fipsCode',
    isoNumeric: 'isoNumeric',
    north: 'north',
    south: 'south',
    east: 'east',
    west: 'west',
    capital: 'capital',
    continentName: 'continentName',
    continent: 'continent',
    languages: 'languages'
  };

  export type CountriesScalarFieldEnum = (typeof CountriesScalarFieldEnum)[keyof typeof CountriesScalarFieldEnum]


  export const EnrolledactivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    activityId: 'activityId',
    enrollmentDate: 'enrollmentDate'
  };

  export type EnrolledactivityScalarFieldEnum = (typeof EnrolledactivityScalarFieldEnum)[keyof typeof EnrolledactivityScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    empno: 'empno',
    description: 'description',
    serial: 'serial',
    dateout: 'dateout',
    datein: 'datein',
    issuedby: 'issuedby',
    remarks: 'remarks'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const Inventory__suppliersScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    itemsProvided: 'itemsProvided',
    address: 'address',
    phoneNumber: 'phoneNumber',
    email: 'email',
    rating: 'rating'
  };

  export type Inventory__suppliersScalarFieldEnum = (typeof Inventory__suppliersScalarFieldEnum)[keyof typeof Inventory__suppliersScalarFieldEnum]


  export const Inventory_bookstoreScalarFieldEnum: {
    id: 'id',
    product_name: 'product_name',
    quantity: 'quantity',
    selling_price: 'selling_price',
    date: 'date'
  };

  export type Inventory_bookstoreScalarFieldEnum = (typeof Inventory_bookstoreScalarFieldEnum)[keyof typeof Inventory_bookstoreScalarFieldEnum]


  export const Library_loginScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password'
  };

  export type Library_loginScalarFieldEnum = (typeof Library_loginScalarFieldEnum)[keyof typeof Library_loginScalarFieldEnum]


  export const Logs_enrollScalarFieldEnum: {
    id: 'id',
    ern: 'ern',
    stage: 'stage',
    usertouch: 'usertouch',
    touch: 'touch',
    notes: 'notes'
  };

  export type Logs_enrollScalarFieldEnum = (typeof Logs_enrollScalarFieldEnum)[keyof typeof Logs_enrollScalarFieldEnum]


  export const NationalitiesScalarFieldEnum: {
    id: 'id',
    countryCode: 'countryCode',
    nationalityName: 'nationalityName',
    currencyCode: 'currencyCode',
    fipsCode: 'fipsCode',
    isoNumeric: 'isoNumeric',
    north: 'north',
    south: 'south',
    east: 'east',
    west: 'west',
    capital: 'capital',
    continentName: 'continentName',
    continent: 'continent'
  };

  export type NationalitiesScalarFieldEnum = (typeof NationalitiesScalarFieldEnum)[keyof typeof NationalitiesScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    product_code: 'product_code',
    type_of_product: 'type_of_product',
    name_of_product: 'name_of_product',
    price_of_product: 'price_of_product',
    date_created: 'date_created',
    last_touch: 'last_touch'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const RequestsScalarFieldEnum: {
    id: 'id',
    rfid: 'rfid',
    reqtype: 'reqtype',
    reqdate: 'reqdate',
    reqneed: 'reqneed',
    reqdetails: 'reqdetails',
    approvedby: 'approvedby',
    approvedate: 'approvedate',
    approvedfin: 'approvedfin',
    approvedfindate: 'approvedfindate',
    status: 'status'
  };

  export type RequestsScalarFieldEnum = (typeof RequestsScalarFieldEnum)[keyof typeof RequestsScalarFieldEnum]


  export const S_activitiesScalarFieldEnum: {
    id: 'id',
    actid: 'actid',
    subjcode: 'subjcode',
    actlvl: 'actlvl',
    actsection: 'actsection',
    actdate: 'actdate',
    actcreate: 'actcreate',
    actdesc: 'actdesc',
    acttype: 'acttype',
    actqtr: 'actqtr',
    maxscore: 'maxscore',
    flag: 'flag'
  };

  export type S_activitiesScalarFieldEnum = (typeof S_activitiesScalarFieldEnum)[keyof typeof S_activitiesScalarFieldEnum]


  export const S_classattendanceScalarFieldEnum: {
    id: 'id',
    attendance: 'attendance',
    subjid: 'subjid',
    studid: 'studid',
    adate: 'adate',
    tid: 'tid',
    notes: 'notes'
  };

  export type S_classattendanceScalarFieldEnum = (typeof S_classattendanceScalarFieldEnum)[keyof typeof S_classattendanceScalarFieldEnum]


  export const S_coretableScalarFieldEnum: {
    id: 'id',
    start: 'start',
    end: 'end',
    grade: 'grade'
  };

  export type S_coretableScalarFieldEnum = (typeof S_coretableScalarFieldEnum)[keyof typeof S_coretableScalarFieldEnum]


  export const S_corevaluesScalarFieldEnum: {
    id: 'id',
    corevalue: 'corevalue'
  };

  export type S_corevaluesScalarFieldEnum = (typeof S_corevaluesScalarFieldEnum)[keyof typeof S_corevaluesScalarFieldEnum]


  export const S_payablesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    reservation_fee: 'reservation_fee',
    tuition_fee: 'tuition_fee',
    other_fee: 'other_fee',
    assessment_fee: 'assessment_fee',
    registration_fee: 'registration_fee',
    special_permit: 'special_permit',
    international_fee_old: 'international_fee_old',
    international_fee_new: 'international_fee_new',
    pta: 'pta'
  };

  export type S_payablesScalarFieldEnum = (typeof S_payablesScalarFieldEnum)[keyof typeof S_payablesScalarFieldEnum]


  export const S_recommendationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    esl: 'esl',
    star: 'star',
    completion: 'completion'
  };

  export type S_recommendationsScalarFieldEnum = (typeof S_recommendationsScalarFieldEnum)[keyof typeof S_recommendationsScalarFieldEnum]


  export const S_scoresScalarFieldEnum: {
    id: 'id',
    subjcode: 'subjcode',
    actid: 'actid',
    acttype: 'acttype',
    sid: 'sid',
    score: 'score',
    maxscore: 'maxscore',
    qtr: 'qtr',
    flag: 'flag'
  };

  export type S_scoresScalarFieldEnum = (typeof S_scoresScalarFieldEnum)[keyof typeof S_scoresScalarFieldEnum]


  export const S_studentcvScalarFieldEnum: {
    id: 'id',
    sid: 'sid',
    tid: 'tid',
    subjid: 'subjid',
    qtr: 'qtr',
    independence: 'independence',
    confidence: 'confidence',
    respect: 'respect',
    empathy: 'empathy',
    appreciation: 'appreciation',
    tolerance: 'tolerance',
    enthusiasm: 'enthusiasm',
    conduct: 'conduct'
  };

  export type S_studentcvScalarFieldEnum = (typeof S_studentcvScalarFieldEnum)[keyof typeof S_studentcvScalarFieldEnum]


  export const S_subjectsScalarFieldEnum: {
    id: 'id',
    code: 'code',
    tid: 'tid',
    subjdesc: 'subjdesc',
    subjlevel: 'subjlevel',
    subjsection: 'subjsection',
    assignedby: 'assignedby',
    assigndate: 'assigndate',
    percentww: 'percentww',
    percentpt: 'percentpt',
    percentqt: 'percentqt'
  };

  export type S_subjectsScalarFieldEnum = (typeof S_subjectsScalarFieldEnum)[keyof typeof S_subjectsScalarFieldEnum]


  export const S_transmuteScalarFieldEnum: {
    id: 'id',
    lowerl: 'lowerl',
    upperl: 'upperl',
    transmuted: 'transmuted'
  };

  export type S_transmuteScalarFieldEnum = (typeof S_transmuteScalarFieldEnum)[keyof typeof S_transmuteScalarFieldEnum]


  export const S_verificationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    section: 'section',
    grade: 'grade',
    subject: 'subject',
    request_unlock: 'request_unlock',
    flag: 'flag',
    created_at: 'created_at'
  };

  export type S_verificationsScalarFieldEnum = (typeof S_verificationsScalarFieldEnum)[keyof typeof S_verificationsScalarFieldEnum]


  export const Sales_historyScalarFieldEnum: {
    sale_id: 'sale_id',
    buyer_id: 'buyer_id',
    product_name: 'product_name',
    quantity: 'quantity',
    sale_date: 'sale_date',
    rfid: 'rfid'
  };

  export type Sales_historyScalarFieldEnum = (typeof Sales_historyScalarFieldEnum)[keyof typeof Sales_historyScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    start: 'start',
    end: 'end'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const StudentdetailsScalarFieldEnum: {
    id: 'id',
    uniqid: 'uniqid',
    visa: 'visa',
    father: 'father',
    fathermail: 'fathermail',
    fathernumber: 'fathernumber',
    fatherwork: 'fatherwork',
    fcompany: 'fcompany',
    fsalary: 'fsalary',
    mother: 'mother',
    mothermail: 'mothermail',
    mothernumber: 'mothernumber',
    motherwork: 'motherwork',
    mcompany: 'mcompany',
    msalary: 'msalary',
    street: 'street',
    barangay: 'barangay',
    city: 'city',
    postal: 'postal',
    englishrw: 'englishrw',
    englishv: 'englishv',
    languages: 'languages',
    advclasses: 'advclasses',
    remedial: 'remedial',
    skill: 'skill',
    ashtma: 'ashtma',
    ashtmar: 'ashtmar',
    allergy: 'allergy',
    allergyr: 'allergyr',
    drug: 'drug',
    drugr: 'drugr',
    speech: 'speech',
    speechr: 'speechr',
    vision: 'vision',
    visionr: 'visionr',
    hearing: 'hearing',
    hearingr: 'hearingr',
    adhd: 'adhd',
    adhdr: 'adhdr',
    healthcond: 'healthcond',
    hospitalization: 'hospitalization',
    injuries: 'injuries',
    medication: 'medication',
    general: 'general',
    generaldets: 'generaldets',
    psych: 'psych',
    psychdets: 'psychdets',
    minor: 'minor',
    emergency: 'emergency',
    hospital: 'hospital',
    otc: 'otc',
    conforme: 'conforme',
    conformedate: 'conformedate'
  };

  export type StudentdetailsScalarFieldEnum = (typeof StudentdetailsScalarFieldEnum)[keyof typeof StudentdetailsScalarFieldEnum]


  export const TimeoffScalarFieldEnum: {
    id: 'id',
    rfid: 'rfid',
    leavetype: 'leavetype',
    datefrom: 'datefrom',
    dateto: 'dateto',
    ishalfday: 'ishalfday',
    details: 'details',
    credit: 'credit',
    approval: 'approval',
    approvedate: 'approvedate',
    hrnote: 'hrnote',
    hrdate: 'hrdate'
  };

  export type TimeoffScalarFieldEnum = (typeof TimeoffScalarFieldEnum)[keyof typeof TimeoffScalarFieldEnum]


  export const Type_of_productsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Type_of_productsScalarFieldEnum = (typeof Type_of_productsScalarFieldEnum)[keyof typeof Type_of_productsScalarFieldEnum]


  export const UniformScalarFieldEnum: {
    id: 'id',
    rfid: 'rfid',
    size: 'size',
    basic: 'basic',
    activity: 'activity',
    formal: 'formal',
    qtybasic: 'qtybasic',
    qtyact: 'qtyact',
    qtyform: 'qtyform',
    iscomplete: 'iscomplete',
    lasttouch: 'lasttouch',
    dateordered: 'dateordered',
    datereleased: 'datereleased',
    comment: 'comment'
  };

  export type UniformScalarFieldEnum = (typeof UniformScalarFieldEnum)[keyof typeof UniformScalarFieldEnum]


  export const Uniform_inventoryScalarFieldEnum: {
    id: 'id',
    uniform_type_id: 'uniform_type_id',
    uniform_size_id: 'uniform_size_id',
    qty: 'qty',
    gender: 'gender',
    date: 'date',
    user: 'user'
  };

  export type Uniform_inventoryScalarFieldEnum = (typeof Uniform_inventoryScalarFieldEnum)[keyof typeof Uniform_inventoryScalarFieldEnum]


  export const Uniform_issuedScalarFieldEnum: {
    id: 'id',
    rfid: 'rfid',
    releasedby: 'releasedby',
    uniform_type_id: 'uniform_type_id',
    uniform_size_id: 'uniform_size_id',
    date: 'date'
  };

  export type Uniform_issuedScalarFieldEnum = (typeof Uniform_issuedScalarFieldEnum)[keyof typeof Uniform_issuedScalarFieldEnum]


  export const Uniform_sizesScalarFieldEnum: {
    id: 'id',
    size: 'size',
    created_at: 'created_at'
  };

  export type Uniform_sizesScalarFieldEnum = (typeof Uniform_sizesScalarFieldEnum)[keyof typeof Uniform_sizesScalarFieldEnum]


  export const Uniform_typesScalarFieldEnum: {
    id: 'id',
    type: 'type',
    created_at: 'created_at'
  };

  export type Uniform_typesScalarFieldEnum = (typeof Uniform_typesScalarFieldEnum)[keyof typeof Uniform_typesScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    rfid: 'rfid',
    fname: 'fname',
    mname: 'mname',
    lname: 'lname',
    type: 'type',
    gender: 'gender',
    position: 'position',
    grade: 'grade',
    section: 'section',
    dob: 'dob',
    email: 'email',
    mobile: 'mobile',
    vacchist: 'vacchist',
    photo: 'photo',
    manager: 'manager',
    isactive: 'isactive',
    is_situation: 'is_situation',
    username: 'username',
    password: 'password',
    level: 'level',
    status: 'status',
    prevsch: 'prevsch',
    prevschcountry: 'prevschcountry',
    lrn: 'lrn',
    uniqid: 'uniqid',
    tf: 'tf',
    country: 'country',
    nationality: 'nationality',
    nationalities: 'nationalities',
    guardianname: 'guardianname',
    guardianemail: 'guardianemail',
    guardianphone: 'guardianphone',
    referral: 'referral',
    apptype: 'apptype',
    sy: 'sy',
    strand: 'strand',
    religion: 'religion',
    visa: 'visa',
    earlybird: 'earlybird',
    modelrelease: 'modelrelease',
    feepolicy: 'feepolicy',
    refund: 'refund',
    tos: 'tos',
    empno: 'empno',
    isESL: 'isESL',
    house: 'house',
    isofficial: 'isofficial',
    isEnrolledInAfterSchool: 'isEnrolledInAfterSchool'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const User22ScalarFieldEnum: {
    id: 'id',
    rfid: 'rfid',
    fname: 'fname',
    mname: 'mname',
    lname: 'lname',
    gender: 'gender',
    position: 'position',
    grade: 'grade',
    section: 'section',
    dob: 'dob',
    email: 'email',
    mobile: 'mobile',
    vacchist: 'vacchist',
    photo: 'photo',
    manager: 'manager',
    isactive: 'isactive',
    username: 'username',
    password: 'password',
    level: 'level',
    status: 'status',
    prevsch: 'prevsch',
    prevschcountry: 'prevschcountry',
    lrn: 'lrn',
    uniqid: 'uniqid',
    tf: 'tf',
    country: 'country',
    nationality: 'nationality',
    guardianname: 'guardianname',
    guardianemail: 'guardianemail',
    guardianphone: 'guardianphone',
    referral: 'referral',
    apptype: 'apptype',
    sy: 'sy',
    strand: 'strand',
    visa: 'visa',
    earlybird: 'earlybird',
    modelrelease: 'modelrelease',
    feepolicy: 'feepolicy',
    refund: 'refund',
    tos: 'tos'
  };

  export type User22ScalarFieldEnum = (typeof User22ScalarFieldEnum)[keyof typeof User22ScalarFieldEnum]


  export const Users24ScalarFieldEnum: {
    id: 'id',
    rfid: 'rfid',
    fname: 'fname',
    mname: 'mname',
    lname: 'lname',
    type: 'type',
    gender: 'gender',
    position: 'position',
    grade: 'grade',
    section: 'section',
    dob: 'dob',
    email: 'email',
    mobile: 'mobile',
    vacchist: 'vacchist',
    photo: 'photo',
    manager: 'manager',
    isactive: 'isactive',
    is_situation: 'is_situation',
    username: 'username',
    password: 'password',
    level: 'level',
    status: 'status',
    prevsch: 'prevsch',
    prevschcountry: 'prevschcountry',
    lrn: 'lrn',
    uniqid: 'uniqid',
    tf: 'tf',
    country: 'country',
    nationality: 'nationality',
    nationalities: 'nationalities',
    religion: 'religion',
    guardianname: 'guardianname',
    guardianemail: 'guardianemail',
    guardianphone: 'guardianphone',
    referral: 'referral',
    apptype: 'apptype',
    sy: 'sy',
    strand: 'strand',
    visa: 'visa',
    earlybird: 'earlybird',
    modelrelease: 'modelrelease',
    feepolicy: 'feepolicy',
    refund: 'refund',
    tos: 'tos',
    empno: 'empno',
    isESL: 'isESL',
    house: 'house',
    isofficial: 'isofficial'
  };

  export type Users24ScalarFieldEnum = (typeof Users24ScalarFieldEnum)[keyof typeof Users24ScalarFieldEnum]


  export const VisitorlogScalarFieldEnum: {
    id: 'id',
    name: 'name',
    rfid: 'rfid',
    comment: 'comment',
    registerdate: 'registerdate',
    status: 'status'
  };

  export type VisitorlogScalarFieldEnum = (typeof VisitorlogScalarFieldEnum)[keyof typeof VisitorlogScalarFieldEnum]


  export const WispayScalarFieldEnum: {
    id: 'id',
    debit: 'debit',
    credit: 'credit',
    rfid: 'rfid',
    empid: 'empid',
    username: 'username',
    refcode: 'refcode',
    transdate: 'transdate',
    processedby: 'processedby',
    product_type: 'product_type',
    product_name: 'product_name',
    quantity: 'quantity',
    isAfterSchoolPayment: 'isAfterSchoolPayment'
  };

  export type WispayScalarFieldEnum = (typeof WispayScalarFieldEnum)[keyof typeof WispayScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const afterschoolactivityOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    dayOfWeek: 'dayOfWeek',
    location: 'location',
    coachName: 'coachName',
    photo: 'photo'
  };

  export type afterschoolactivityOrderByRelevanceFieldEnum = (typeof afterschoolactivityOrderByRelevanceFieldEnum)[keyof typeof afterschoolactivityOrderByRelevanceFieldEnum]


  export const attendanceOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type attendanceOrderByRelevanceFieldEnum = (typeof attendanceOrderByRelevanceFieldEnum)[keyof typeof attendanceOrderByRelevanceFieldEnum]


  export const attendance_libraryOrderByRelevanceFieldEnum: {
    name: 'name',
    rfid: 'rfid'
  };

  export type attendance_libraryOrderByRelevanceFieldEnum = (typeof attendance_libraryOrderByRelevanceFieldEnum)[keyof typeof attendance_libraryOrderByRelevanceFieldEnum]


  export const borrowersOrderByRelevanceFieldEnum: {
    name: 'name',
    rfid: 'rfid',
    title: 'title',
    remarks: 'remarks'
  };

  export type borrowersOrderByRelevanceFieldEnum = (typeof borrowersOrderByRelevanceFieldEnum)[keyof typeof borrowersOrderByRelevanceFieldEnum]


  export const buyersOrderByRelevanceFieldEnum: {
    buyer_name: 'buyer_name'
  };

  export type buyersOrderByRelevanceFieldEnum = (typeof buyersOrderByRelevanceFieldEnum)[keyof typeof buyersOrderByRelevanceFieldEnum]


  export const clinic_historyOrderByRelevanceFieldEnum: {
    name: 'name',
    grade: 'grade',
    complaint: 'complaint',
    diagnose: 'diagnose',
    treatment: 'treatment',
    vital_signs: 'vital_signs',
    date: 'date',
    remarks: 'remarks'
  };

  export type clinic_historyOrderByRelevanceFieldEnum = (typeof clinic_historyOrderByRelevanceFieldEnum)[keyof typeof clinic_historyOrderByRelevanceFieldEnum]


  export const countriesOrderByRelevanceFieldEnum: {
    countryCode: 'countryCode',
    countryName: 'countryName',
    currencyCode: 'currencyCode',
    fipsCode: 'fipsCode',
    isoNumeric: 'isoNumeric',
    north: 'north',
    south: 'south',
    east: 'east',
    west: 'west',
    capital: 'capital',
    continentName: 'continentName',
    continent: 'continent',
    languages: 'languages'
  };

  export type countriesOrderByRelevanceFieldEnum = (typeof countriesOrderByRelevanceFieldEnum)[keyof typeof countriesOrderByRelevanceFieldEnum]


  export const inventoryOrderByRelevanceFieldEnum: {
    empno: 'empno',
    description: 'description',
    serial: 'serial',
    issuedby: 'issuedby',
    remarks: 'remarks'
  };

  export type inventoryOrderByRelevanceFieldEnum = (typeof inventoryOrderByRelevanceFieldEnum)[keyof typeof inventoryOrderByRelevanceFieldEnum]


  export const inventory__suppliersOrderByRelevanceFieldEnum: {
    companyName: 'companyName',
    itemsProvided: 'itemsProvided',
    address: 'address',
    phoneNumber: 'phoneNumber',
    email: 'email'
  };

  export type inventory__suppliersOrderByRelevanceFieldEnum = (typeof inventory__suppliersOrderByRelevanceFieldEnum)[keyof typeof inventory__suppliersOrderByRelevanceFieldEnum]


  export const inventory_bookstoreOrderByRelevanceFieldEnum: {
    product_name: 'product_name'
  };

  export type inventory_bookstoreOrderByRelevanceFieldEnum = (typeof inventory_bookstoreOrderByRelevanceFieldEnum)[keyof typeof inventory_bookstoreOrderByRelevanceFieldEnum]


  export const library_loginOrderByRelevanceFieldEnum: {
    username: 'username',
    password: 'password'
  };

  export type library_loginOrderByRelevanceFieldEnum = (typeof library_loginOrderByRelevanceFieldEnum)[keyof typeof library_loginOrderByRelevanceFieldEnum]


  export const logs_enrollOrderByRelevanceFieldEnum: {
    ern: 'ern',
    usertouch: 'usertouch',
    notes: 'notes'
  };

  export type logs_enrollOrderByRelevanceFieldEnum = (typeof logs_enrollOrderByRelevanceFieldEnum)[keyof typeof logs_enrollOrderByRelevanceFieldEnum]


  export const nationalitiesOrderByRelevanceFieldEnum: {
    countryCode: 'countryCode',
    nationalityName: 'nationalityName',
    currencyCode: 'currencyCode',
    fipsCode: 'fipsCode',
    isoNumeric: 'isoNumeric',
    north: 'north',
    south: 'south',
    east: 'east',
    west: 'west',
    capital: 'capital',
    continentName: 'continentName',
    continent: 'continent'
  };

  export type nationalitiesOrderByRelevanceFieldEnum = (typeof nationalitiesOrderByRelevanceFieldEnum)[keyof typeof nationalitiesOrderByRelevanceFieldEnum]


  export const productsOrderByRelevanceFieldEnum: {
    product_code: 'product_code',
    type_of_product: 'type_of_product',
    name_of_product: 'name_of_product',
    last_touch: 'last_touch'
  };

  export type productsOrderByRelevanceFieldEnum = (typeof productsOrderByRelevanceFieldEnum)[keyof typeof productsOrderByRelevanceFieldEnum]


  export const requestsOrderByRelevanceFieldEnum: {
    reqtype: 'reqtype',
    reqdetails: 'reqdetails',
    status: 'status'
  };

  export type requestsOrderByRelevanceFieldEnum = (typeof requestsOrderByRelevanceFieldEnum)[keyof typeof requestsOrderByRelevanceFieldEnum]


  export const s_activitiesOrderByRelevanceFieldEnum: {
    actid: 'actid',
    subjcode: 'subjcode',
    actsection: 'actsection',
    actcreate: 'actcreate',
    actdesc: 'actdesc'
  };

  export type s_activitiesOrderByRelevanceFieldEnum = (typeof s_activitiesOrderByRelevanceFieldEnum)[keyof typeof s_activitiesOrderByRelevanceFieldEnum]


  export const s_classattendanceOrderByRelevanceFieldEnum: {
    subjid: 'subjid',
    studid: 'studid',
    tid: 'tid',
    notes: 'notes'
  };

  export type s_classattendanceOrderByRelevanceFieldEnum = (typeof s_classattendanceOrderByRelevanceFieldEnum)[keyof typeof s_classattendanceOrderByRelevanceFieldEnum]


  export const s_coretableOrderByRelevanceFieldEnum: {
    grade: 'grade'
  };

  export type s_coretableOrderByRelevanceFieldEnum = (typeof s_coretableOrderByRelevanceFieldEnum)[keyof typeof s_coretableOrderByRelevanceFieldEnum]


  export const s_corevaluesOrderByRelevanceFieldEnum: {
    corevalue: 'corevalue'
  };

  export type s_corevaluesOrderByRelevanceFieldEnum = (typeof s_corevaluesOrderByRelevanceFieldEnum)[keyof typeof s_corevaluesOrderByRelevanceFieldEnum]


  export const s_payablesOrderByRelevanceFieldEnum: {
    user_id: 'user_id'
  };

  export type s_payablesOrderByRelevanceFieldEnum = (typeof s_payablesOrderByRelevanceFieldEnum)[keyof typeof s_payablesOrderByRelevanceFieldEnum]


  export const s_recommendationsOrderByRelevanceFieldEnum: {
    user_id: 'user_id'
  };

  export type s_recommendationsOrderByRelevanceFieldEnum = (typeof s_recommendationsOrderByRelevanceFieldEnum)[keyof typeof s_recommendationsOrderByRelevanceFieldEnum]


  export const s_scoresOrderByRelevanceFieldEnum: {
    subjcode: 'subjcode',
    actid: 'actid',
    sid: 'sid'
  };

  export type s_scoresOrderByRelevanceFieldEnum = (typeof s_scoresOrderByRelevanceFieldEnum)[keyof typeof s_scoresOrderByRelevanceFieldEnum]


  export const s_studentcvOrderByRelevanceFieldEnum: {
    sid: 'sid',
    tid: 'tid',
    subjid: 'subjid'
  };

  export type s_studentcvOrderByRelevanceFieldEnum = (typeof s_studentcvOrderByRelevanceFieldEnum)[keyof typeof s_studentcvOrderByRelevanceFieldEnum]


  export const s_subjectsOrderByRelevanceFieldEnum: {
    code: 'code',
    tid: 'tid',
    subjdesc: 'subjdesc',
    subjlevel: 'subjlevel',
    subjsection: 'subjsection',
    assignedby: 'assignedby'
  };

  export type s_subjectsOrderByRelevanceFieldEnum = (typeof s_subjectsOrderByRelevanceFieldEnum)[keyof typeof s_subjectsOrderByRelevanceFieldEnum]


  export const s_verificationsOrderByRelevanceFieldEnum: {
    user_id: 'user_id',
    section: 'section',
    subject: 'subject'
  };

  export type s_verificationsOrderByRelevanceFieldEnum = (typeof s_verificationsOrderByRelevanceFieldEnum)[keyof typeof s_verificationsOrderByRelevanceFieldEnum]


  export const sales_historyOrderByRelevanceFieldEnum: {
    product_name: 'product_name'
  };

  export type sales_historyOrderByRelevanceFieldEnum = (typeof sales_historyOrderByRelevanceFieldEnum)[keyof typeof sales_historyOrderByRelevanceFieldEnum]


  export const scheduleOrderByRelevanceFieldEnum: {
    title: 'title'
  };

  export type scheduleOrderByRelevanceFieldEnum = (typeof scheduleOrderByRelevanceFieldEnum)[keyof typeof scheduleOrderByRelevanceFieldEnum]


  export const studentdetailsOrderByRelevanceFieldEnum: {
    uniqid: 'uniqid',
    visa: 'visa',
    father: 'father',
    fathermail: 'fathermail',
    fathernumber: 'fathernumber',
    fatherwork: 'fatherwork',
    fcompany: 'fcompany',
    fsalary: 'fsalary',
    mother: 'mother',
    mothermail: 'mothermail',
    mothernumber: 'mothernumber',
    motherwork: 'motherwork',
    mcompany: 'mcompany',
    msalary: 'msalary',
    street: 'street',
    barangay: 'barangay',
    city: 'city',
    postal: 'postal',
    englishrw: 'englishrw',
    englishv: 'englishv',
    languages: 'languages',
    advclasses: 'advclasses',
    remedial: 'remedial',
    skill: 'skill',
    ashtma: 'ashtma',
    ashtmar: 'ashtmar',
    allergy: 'allergy',
    allergyr: 'allergyr',
    drug: 'drug',
    drugr: 'drugr',
    speech: 'speech',
    speechr: 'speechr',
    vision: 'vision',
    visionr: 'visionr',
    hearing: 'hearing',
    hearingr: 'hearingr',
    adhd: 'adhd',
    adhdr: 'adhdr',
    healthcond: 'healthcond',
    hospitalization: 'hospitalization',
    injuries: 'injuries',
    medication: 'medication',
    general: 'general',
    generaldets: 'generaldets',
    psych: 'psych',
    psychdets: 'psychdets',
    minor: 'minor',
    emergency: 'emergency',
    hospital: 'hospital',
    otc: 'otc',
    conforme: 'conforme',
    conformedate: 'conformedate'
  };

  export type studentdetailsOrderByRelevanceFieldEnum = (typeof studentdetailsOrderByRelevanceFieldEnum)[keyof typeof studentdetailsOrderByRelevanceFieldEnum]


  export const timeoffOrderByRelevanceFieldEnum: {
    leavetype: 'leavetype',
    details: 'details',
    approval: 'approval',
    hrnote: 'hrnote'
  };

  export type timeoffOrderByRelevanceFieldEnum = (typeof timeoffOrderByRelevanceFieldEnum)[keyof typeof timeoffOrderByRelevanceFieldEnum]


  export const type_of_productsOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type type_of_productsOrderByRelevanceFieldEnum = (typeof type_of_productsOrderByRelevanceFieldEnum)[keyof typeof type_of_productsOrderByRelevanceFieldEnum]


  export const uniformOrderByRelevanceFieldEnum: {
    rfid: 'rfid',
    size: 'size',
    basic: 'basic',
    activity: 'activity',
    formal: 'formal',
    qtybasic: 'qtybasic',
    qtyact: 'qtyact',
    qtyform: 'qtyform',
    lasttouch: 'lasttouch',
    dateordered: 'dateordered',
    datereleased: 'datereleased',
    comment: 'comment'
  };

  export type uniformOrderByRelevanceFieldEnum = (typeof uniformOrderByRelevanceFieldEnum)[keyof typeof uniformOrderByRelevanceFieldEnum]


  export const uniform_inventoryOrderByRelevanceFieldEnum: {
    uniform_type_id: 'uniform_type_id',
    uniform_size_id: 'uniform_size_id',
    gender: 'gender',
    user: 'user'
  };

  export type uniform_inventoryOrderByRelevanceFieldEnum = (typeof uniform_inventoryOrderByRelevanceFieldEnum)[keyof typeof uniform_inventoryOrderByRelevanceFieldEnum]


  export const uniform_issuedOrderByRelevanceFieldEnum: {
    rfid: 'rfid',
    releasedby: 'releasedby',
    uniform_type_id: 'uniform_type_id',
    uniform_size_id: 'uniform_size_id'
  };

  export type uniform_issuedOrderByRelevanceFieldEnum = (typeof uniform_issuedOrderByRelevanceFieldEnum)[keyof typeof uniform_issuedOrderByRelevanceFieldEnum]


  export const uniform_sizesOrderByRelevanceFieldEnum: {
    size: 'size'
  };

  export type uniform_sizesOrderByRelevanceFieldEnum = (typeof uniform_sizesOrderByRelevanceFieldEnum)[keyof typeof uniform_sizesOrderByRelevanceFieldEnum]


  export const uniform_typesOrderByRelevanceFieldEnum: {
    type: 'type'
  };

  export type uniform_typesOrderByRelevanceFieldEnum = (typeof uniform_typesOrderByRelevanceFieldEnum)[keyof typeof uniform_typesOrderByRelevanceFieldEnum]


  export const userOrderByRelevanceFieldEnum: {
    fname: 'fname',
    mname: 'mname',
    lname: 'lname',
    type: 'type',
    gender: 'gender',
    position: 'position',
    grade: 'grade',
    section: 'section',
    email: 'email',
    mobile: 'mobile',
    vacchist: 'vacchist',
    photo: 'photo',
    manager: 'manager',
    is_situation: 'is_situation',
    username: 'username',
    password: 'password',
    prevsch: 'prevsch',
    prevschcountry: 'prevschcountry',
    lrn: 'lrn',
    uniqid: 'uniqid',
    tf: 'tf',
    country: 'country',
    nationality: 'nationality',
    nationalities: 'nationalities',
    guardianname: 'guardianname',
    guardianemail: 'guardianemail',
    guardianphone: 'guardianphone',
    referral: 'referral',
    apptype: 'apptype',
    sy: 'sy',
    strand: 'strand',
    religion: 'religion',
    visa: 'visa',
    empno: 'empno',
    house: 'house'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  export const user22OrderByRelevanceFieldEnum: {
    fname: 'fname',
    mname: 'mname',
    lname: 'lname',
    gender: 'gender',
    position: 'position',
    grade: 'grade',
    section: 'section',
    email: 'email',
    mobile: 'mobile',
    vacchist: 'vacchist',
    photo: 'photo',
    manager: 'manager',
    username: 'username',
    password: 'password',
    prevsch: 'prevsch',
    prevschcountry: 'prevschcountry',
    lrn: 'lrn',
    uniqid: 'uniqid',
    tf: 'tf',
    country: 'country',
    nationality: 'nationality',
    guardianname: 'guardianname',
    guardianemail: 'guardianemail',
    guardianphone: 'guardianphone',
    referral: 'referral',
    apptype: 'apptype',
    sy: 'sy',
    strand: 'strand',
    visa: 'visa'
  };

  export type user22OrderByRelevanceFieldEnum = (typeof user22OrderByRelevanceFieldEnum)[keyof typeof user22OrderByRelevanceFieldEnum]


  export const users24OrderByRelevanceFieldEnum: {
    fname: 'fname',
    mname: 'mname',
    lname: 'lname',
    type: 'type',
    gender: 'gender',
    position: 'position',
    grade: 'grade',
    section: 'section',
    email: 'email',
    mobile: 'mobile',
    vacchist: 'vacchist',
    photo: 'photo',
    manager: 'manager',
    is_situation: 'is_situation',
    username: 'username',
    password: 'password',
    prevsch: 'prevsch',
    prevschcountry: 'prevschcountry',
    lrn: 'lrn',
    uniqid: 'uniqid',
    tf: 'tf',
    country: 'country',
    nationality: 'nationality',
    nationalities: 'nationalities',
    religion: 'religion',
    guardianname: 'guardianname',
    guardianemail: 'guardianemail',
    guardianphone: 'guardianphone',
    referral: 'referral',
    apptype: 'apptype',
    sy: 'sy',
    strand: 'strand',
    visa: 'visa',
    empno: 'empno',
    house: 'house'
  };

  export type users24OrderByRelevanceFieldEnum = (typeof users24OrderByRelevanceFieldEnum)[keyof typeof users24OrderByRelevanceFieldEnum]


  export const visitorlogOrderByRelevanceFieldEnum: {
    name: 'name',
    rfid: 'rfid',
    comment: 'comment'
  };

  export type visitorlogOrderByRelevanceFieldEnum = (typeof visitorlogOrderByRelevanceFieldEnum)[keyof typeof visitorlogOrderByRelevanceFieldEnum]


  export const wispayOrderByRelevanceFieldEnum: {
    empid: 'empid',
    username: 'username',
    refcode: 'refcode',
    processedby: 'processedby',
    product_type: 'product_type',
    product_name: 'product_name'
  };

  export type wispayOrderByRelevanceFieldEnum = (typeof wispayOrderByRelevanceFieldEnum)[keyof typeof wispayOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type activitysessionWhereInput = {
    AND?: activitysessionWhereInput | activitysessionWhereInput[]
    OR?: activitysessionWhereInput[]
    NOT?: activitysessionWhereInput | activitysessionWhereInput[]
    id?: IntFilter<"activitysession"> | number
    activityId?: IntFilter<"activitysession"> | number
    date?: DateTimeFilter<"activitysession"> | Date | string
    createdAt?: DateTimeFilter<"activitysession"> | Date | string
    updatedAt?: DateTimeFilter<"activitysession"> | Date | string
    afterschoolactivity?: XOR<AfterschoolactivityScalarRelationFilter, afterschoolactivityWhereInput>
    attendance?: AttendanceListRelationFilter
  }

  export type activitysessionOrderByWithRelationInput = {
    id?: SortOrder
    activityId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    afterschoolactivity?: afterschoolactivityOrderByWithRelationInput
    attendance?: attendanceOrderByRelationAggregateInput
  }

  export type activitysessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: activitysessionWhereInput | activitysessionWhereInput[]
    OR?: activitysessionWhereInput[]
    NOT?: activitysessionWhereInput | activitysessionWhereInput[]
    activityId?: IntFilter<"activitysession"> | number
    date?: DateTimeFilter<"activitysession"> | Date | string
    createdAt?: DateTimeFilter<"activitysession"> | Date | string
    updatedAt?: DateTimeFilter<"activitysession"> | Date | string
    afterschoolactivity?: XOR<AfterschoolactivityScalarRelationFilter, afterschoolactivityWhereInput>
    attendance?: AttendanceListRelationFilter
  }, "id">

  export type activitysessionOrderByWithAggregationInput = {
    id?: SortOrder
    activityId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: activitysessionCountOrderByAggregateInput
    _avg?: activitysessionAvgOrderByAggregateInput
    _max?: activitysessionMaxOrderByAggregateInput
    _min?: activitysessionMinOrderByAggregateInput
    _sum?: activitysessionSumOrderByAggregateInput
  }

  export type activitysessionScalarWhereWithAggregatesInput = {
    AND?: activitysessionScalarWhereWithAggregatesInput | activitysessionScalarWhereWithAggregatesInput[]
    OR?: activitysessionScalarWhereWithAggregatesInput[]
    NOT?: activitysessionScalarWhereWithAggregatesInput | activitysessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"activitysession"> | number
    activityId?: IntWithAggregatesFilter<"activitysession"> | number
    date?: DateTimeWithAggregatesFilter<"activitysession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"activitysession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"activitysession"> | Date | string
  }

  export type afterschoolactivityWhereInput = {
    AND?: afterschoolactivityWhereInput | afterschoolactivityWhereInput[]
    OR?: afterschoolactivityWhereInput[]
    NOT?: afterschoolactivityWhereInput | afterschoolactivityWhereInput[]
    id?: IntFilter<"afterschoolactivity"> | number
    name?: StringFilter<"afterschoolactivity"> | string
    description?: StringNullableFilter<"afterschoolactivity"> | string | null
    dayOfWeek?: StringFilter<"afterschoolactivity"> | string
    startTime?: DateTimeFilter<"afterschoolactivity"> | Date | string
    endTime?: DateTimeFilter<"afterschoolactivity"> | Date | string
    location?: StringNullableFilter<"afterschoolactivity"> | string | null
    coachName?: StringNullableFilter<"afterschoolactivity"> | string | null
    createdAt?: DateTimeFilter<"afterschoolactivity"> | Date | string
    updatedAt?: DateTimeFilter<"afterschoolactivity"> | Date | string
    photo?: StringNullableFilter<"afterschoolactivity"> | string | null
    activitysession?: ActivitysessionListRelationFilter
    enrolledactivity?: EnrolledactivityListRelationFilter
  }

  export type afterschoolactivityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrderInput | SortOrder
    coachName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photo?: SortOrderInput | SortOrder
    activitysession?: activitysessionOrderByRelationAggregateInput
    enrolledactivity?: enrolledactivityOrderByRelationAggregateInput
    _relevance?: afterschoolactivityOrderByRelevanceInput
  }

  export type afterschoolactivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: afterschoolactivityWhereInput | afterschoolactivityWhereInput[]
    OR?: afterschoolactivityWhereInput[]
    NOT?: afterschoolactivityWhereInput | afterschoolactivityWhereInput[]
    name?: StringFilter<"afterschoolactivity"> | string
    description?: StringNullableFilter<"afterschoolactivity"> | string | null
    dayOfWeek?: StringFilter<"afterschoolactivity"> | string
    startTime?: DateTimeFilter<"afterschoolactivity"> | Date | string
    endTime?: DateTimeFilter<"afterschoolactivity"> | Date | string
    location?: StringNullableFilter<"afterschoolactivity"> | string | null
    coachName?: StringNullableFilter<"afterschoolactivity"> | string | null
    createdAt?: DateTimeFilter<"afterschoolactivity"> | Date | string
    updatedAt?: DateTimeFilter<"afterschoolactivity"> | Date | string
    photo?: StringNullableFilter<"afterschoolactivity"> | string | null
    activitysession?: ActivitysessionListRelationFilter
    enrolledactivity?: EnrolledactivityListRelationFilter
  }, "id">

  export type afterschoolactivityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrderInput | SortOrder
    coachName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photo?: SortOrderInput | SortOrder
    _count?: afterschoolactivityCountOrderByAggregateInput
    _avg?: afterschoolactivityAvgOrderByAggregateInput
    _max?: afterschoolactivityMaxOrderByAggregateInput
    _min?: afterschoolactivityMinOrderByAggregateInput
    _sum?: afterschoolactivitySumOrderByAggregateInput
  }

  export type afterschoolactivityScalarWhereWithAggregatesInput = {
    AND?: afterschoolactivityScalarWhereWithAggregatesInput | afterschoolactivityScalarWhereWithAggregatesInput[]
    OR?: afterschoolactivityScalarWhereWithAggregatesInput[]
    NOT?: afterschoolactivityScalarWhereWithAggregatesInput | afterschoolactivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"afterschoolactivity"> | number
    name?: StringWithAggregatesFilter<"afterschoolactivity"> | string
    description?: StringNullableWithAggregatesFilter<"afterschoolactivity"> | string | null
    dayOfWeek?: StringWithAggregatesFilter<"afterschoolactivity"> | string
    startTime?: DateTimeWithAggregatesFilter<"afterschoolactivity"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"afterschoolactivity"> | Date | string
    location?: StringNullableWithAggregatesFilter<"afterschoolactivity"> | string | null
    coachName?: StringNullableWithAggregatesFilter<"afterschoolactivity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"afterschoolactivity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"afterschoolactivity"> | Date | string
    photo?: StringNullableWithAggregatesFilter<"afterschoolactivity"> | string | null
  }

  export type attendanceWhereInput = {
    AND?: attendanceWhereInput | attendanceWhereInput[]
    OR?: attendanceWhereInput[]
    NOT?: attendanceWhereInput | attendanceWhereInput[]
    id?: IntFilter<"attendance"> | number
    sessionId?: IntFilter<"attendance"> | number
    userId?: IntFilter<"attendance"> | number
    status?: StringFilter<"attendance"> | string
    activitysession?: XOR<ActivitysessionScalarRelationFilter, activitysessionWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type attendanceOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    activitysession?: activitysessionOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: attendanceOrderByRelevanceInput
  }

  export type attendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionId_userId?: attendanceSessionIdUserIdCompoundUniqueInput
    AND?: attendanceWhereInput | attendanceWhereInput[]
    OR?: attendanceWhereInput[]
    NOT?: attendanceWhereInput | attendanceWhereInput[]
    sessionId?: IntFilter<"attendance"> | number
    userId?: IntFilter<"attendance"> | number
    status?: StringFilter<"attendance"> | string
    activitysession?: XOR<ActivitysessionScalarRelationFilter, activitysessionWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "sessionId_userId">

  export type attendanceOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    _count?: attendanceCountOrderByAggregateInput
    _avg?: attendanceAvgOrderByAggregateInput
    _max?: attendanceMaxOrderByAggregateInput
    _min?: attendanceMinOrderByAggregateInput
    _sum?: attendanceSumOrderByAggregateInput
  }

  export type attendanceScalarWhereWithAggregatesInput = {
    AND?: attendanceScalarWhereWithAggregatesInput | attendanceScalarWhereWithAggregatesInput[]
    OR?: attendanceScalarWhereWithAggregatesInput[]
    NOT?: attendanceScalarWhereWithAggregatesInput | attendanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"attendance"> | number
    sessionId?: IntWithAggregatesFilter<"attendance"> | number
    userId?: IntWithAggregatesFilter<"attendance"> | number
    status?: StringWithAggregatesFilter<"attendance"> | string
  }

  export type attendance_libraryWhereInput = {
    AND?: attendance_libraryWhereInput | attendance_libraryWhereInput[]
    OR?: attendance_libraryWhereInput[]
    NOT?: attendance_libraryWhereInput | attendance_libraryWhereInput[]
    id?: IntFilter<"attendance_library"> | number
    name?: StringNullableFilter<"attendance_library"> | string | null
    date?: DateTimeNullableFilter<"attendance_library"> | Date | string | null
    rfid?: StringNullableFilter<"attendance_library"> | string | null
  }

  export type attendance_libraryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    rfid?: SortOrderInput | SortOrder
    _relevance?: attendance_libraryOrderByRelevanceInput
  }

  export type attendance_libraryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: attendance_libraryWhereInput | attendance_libraryWhereInput[]
    OR?: attendance_libraryWhereInput[]
    NOT?: attendance_libraryWhereInput | attendance_libraryWhereInput[]
    name?: StringNullableFilter<"attendance_library"> | string | null
    date?: DateTimeNullableFilter<"attendance_library"> | Date | string | null
    rfid?: StringNullableFilter<"attendance_library"> | string | null
  }, "id">

  export type attendance_libraryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    rfid?: SortOrderInput | SortOrder
    _count?: attendance_libraryCountOrderByAggregateInput
    _avg?: attendance_libraryAvgOrderByAggregateInput
    _max?: attendance_libraryMaxOrderByAggregateInput
    _min?: attendance_libraryMinOrderByAggregateInput
    _sum?: attendance_librarySumOrderByAggregateInput
  }

  export type attendance_libraryScalarWhereWithAggregatesInput = {
    AND?: attendance_libraryScalarWhereWithAggregatesInput | attendance_libraryScalarWhereWithAggregatesInput[]
    OR?: attendance_libraryScalarWhereWithAggregatesInput[]
    NOT?: attendance_libraryScalarWhereWithAggregatesInput | attendance_libraryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"attendance_library"> | number
    name?: StringNullableWithAggregatesFilter<"attendance_library"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"attendance_library"> | Date | string | null
    rfid?: StringNullableWithAggregatesFilter<"attendance_library"> | string | null
  }

  export type borrowersWhereInput = {
    AND?: borrowersWhereInput | borrowersWhereInput[]
    OR?: borrowersWhereInput[]
    NOT?: borrowersWhereInput | borrowersWhereInput[]
    id?: IntFilter<"borrowers"> | number
    name?: StringNullableFilter<"borrowers"> | string | null
    rfid?: StringNullableFilter<"borrowers"> | string | null
    title?: StringNullableFilter<"borrowers"> | string | null
    date_borrowed?: DateTimeNullableFilter<"borrowers"> | Date | string | null
    date_returned?: DateTimeNullableFilter<"borrowers"> | Date | string | null
    remarks?: StringNullableFilter<"borrowers"> | string | null
  }

  export type borrowersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    rfid?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    date_borrowed?: SortOrderInput | SortOrder
    date_returned?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    _relevance?: borrowersOrderByRelevanceInput
  }

  export type borrowersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: borrowersWhereInput | borrowersWhereInput[]
    OR?: borrowersWhereInput[]
    NOT?: borrowersWhereInput | borrowersWhereInput[]
    name?: StringNullableFilter<"borrowers"> | string | null
    rfid?: StringNullableFilter<"borrowers"> | string | null
    title?: StringNullableFilter<"borrowers"> | string | null
    date_borrowed?: DateTimeNullableFilter<"borrowers"> | Date | string | null
    date_returned?: DateTimeNullableFilter<"borrowers"> | Date | string | null
    remarks?: StringNullableFilter<"borrowers"> | string | null
  }, "id">

  export type borrowersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    rfid?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    date_borrowed?: SortOrderInput | SortOrder
    date_returned?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    _count?: borrowersCountOrderByAggregateInput
    _avg?: borrowersAvgOrderByAggregateInput
    _max?: borrowersMaxOrderByAggregateInput
    _min?: borrowersMinOrderByAggregateInput
    _sum?: borrowersSumOrderByAggregateInput
  }

  export type borrowersScalarWhereWithAggregatesInput = {
    AND?: borrowersScalarWhereWithAggregatesInput | borrowersScalarWhereWithAggregatesInput[]
    OR?: borrowersScalarWhereWithAggregatesInput[]
    NOT?: borrowersScalarWhereWithAggregatesInput | borrowersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"borrowers"> | number
    name?: StringNullableWithAggregatesFilter<"borrowers"> | string | null
    rfid?: StringNullableWithAggregatesFilter<"borrowers"> | string | null
    title?: StringNullableWithAggregatesFilter<"borrowers"> | string | null
    date_borrowed?: DateTimeNullableWithAggregatesFilter<"borrowers"> | Date | string | null
    date_returned?: DateTimeNullableWithAggregatesFilter<"borrowers"> | Date | string | null
    remarks?: StringNullableWithAggregatesFilter<"borrowers"> | string | null
  }

  export type buyersWhereInput = {
    AND?: buyersWhereInput | buyersWhereInput[]
    OR?: buyersWhereInput[]
    NOT?: buyersWhereInput | buyersWhereInput[]
    buyer_id?: IntFilter<"buyers"> | number
    buyer_name?: StringFilter<"buyers"> | string
    rfid?: BigIntNullableFilter<"buyers"> | bigint | number | null
  }

  export type buyersOrderByWithRelationInput = {
    buyer_id?: SortOrder
    buyer_name?: SortOrder
    rfid?: SortOrderInput | SortOrder
    _relevance?: buyersOrderByRelevanceInput
  }

  export type buyersWhereUniqueInput = Prisma.AtLeast<{
    buyer_id?: number
    buyer_name?: string
    rfid?: bigint | number
    AND?: buyersWhereInput | buyersWhereInput[]
    OR?: buyersWhereInput[]
    NOT?: buyersWhereInput | buyersWhereInput[]
  }, "buyer_id" | "buyer_name" | "rfid">

  export type buyersOrderByWithAggregationInput = {
    buyer_id?: SortOrder
    buyer_name?: SortOrder
    rfid?: SortOrderInput | SortOrder
    _count?: buyersCountOrderByAggregateInput
    _avg?: buyersAvgOrderByAggregateInput
    _max?: buyersMaxOrderByAggregateInput
    _min?: buyersMinOrderByAggregateInput
    _sum?: buyersSumOrderByAggregateInput
  }

  export type buyersScalarWhereWithAggregatesInput = {
    AND?: buyersScalarWhereWithAggregatesInput | buyersScalarWhereWithAggregatesInput[]
    OR?: buyersScalarWhereWithAggregatesInput[]
    NOT?: buyersScalarWhereWithAggregatesInput | buyersScalarWhereWithAggregatesInput[]
    buyer_id?: IntWithAggregatesFilter<"buyers"> | number
    buyer_name?: StringWithAggregatesFilter<"buyers"> | string
    rfid?: BigIntNullableWithAggregatesFilter<"buyers"> | bigint | number | null
  }

  export type clinic_historyWhereInput = {
    AND?: clinic_historyWhereInput | clinic_historyWhereInput[]
    OR?: clinic_historyWhereInput[]
    NOT?: clinic_historyWhereInput | clinic_historyWhereInput[]
    Id?: IntFilter<"clinic_history"> | number
    name?: StringFilter<"clinic_history"> | string
    grade?: StringFilter<"clinic_history"> | string
    complaint?: StringFilter<"clinic_history"> | string
    diagnose?: StringFilter<"clinic_history"> | string
    treatment?: StringFilter<"clinic_history"> | string
    vital_signs?: StringFilter<"clinic_history"> | string
    time_in?: DateTimeFilter<"clinic_history"> | Date | string
    time_out?: DateTimeFilter<"clinic_history"> | Date | string
    date?: StringFilter<"clinic_history"> | string
    remarks?: StringFilter<"clinic_history"> | string
  }

  export type clinic_historyOrderByWithRelationInput = {
    Id?: SortOrder
    name?: SortOrder
    grade?: SortOrder
    complaint?: SortOrder
    diagnose?: SortOrder
    treatment?: SortOrder
    vital_signs?: SortOrder
    time_in?: SortOrder
    time_out?: SortOrder
    date?: SortOrder
    remarks?: SortOrder
    _relevance?: clinic_historyOrderByRelevanceInput
  }

  export type clinic_historyWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: clinic_historyWhereInput | clinic_historyWhereInput[]
    OR?: clinic_historyWhereInput[]
    NOT?: clinic_historyWhereInput | clinic_historyWhereInput[]
    name?: StringFilter<"clinic_history"> | string
    grade?: StringFilter<"clinic_history"> | string
    complaint?: StringFilter<"clinic_history"> | string
    diagnose?: StringFilter<"clinic_history"> | string
    treatment?: StringFilter<"clinic_history"> | string
    vital_signs?: StringFilter<"clinic_history"> | string
    time_in?: DateTimeFilter<"clinic_history"> | Date | string
    time_out?: DateTimeFilter<"clinic_history"> | Date | string
    date?: StringFilter<"clinic_history"> | string
    remarks?: StringFilter<"clinic_history"> | string
  }, "Id">

  export type clinic_historyOrderByWithAggregationInput = {
    Id?: SortOrder
    name?: SortOrder
    grade?: SortOrder
    complaint?: SortOrder
    diagnose?: SortOrder
    treatment?: SortOrder
    vital_signs?: SortOrder
    time_in?: SortOrder
    time_out?: SortOrder
    date?: SortOrder
    remarks?: SortOrder
    _count?: clinic_historyCountOrderByAggregateInput
    _avg?: clinic_historyAvgOrderByAggregateInput
    _max?: clinic_historyMaxOrderByAggregateInput
    _min?: clinic_historyMinOrderByAggregateInput
    _sum?: clinic_historySumOrderByAggregateInput
  }

  export type clinic_historyScalarWhereWithAggregatesInput = {
    AND?: clinic_historyScalarWhereWithAggregatesInput | clinic_historyScalarWhereWithAggregatesInput[]
    OR?: clinic_historyScalarWhereWithAggregatesInput[]
    NOT?: clinic_historyScalarWhereWithAggregatesInput | clinic_historyScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"clinic_history"> | number
    name?: StringWithAggregatesFilter<"clinic_history"> | string
    grade?: StringWithAggregatesFilter<"clinic_history"> | string
    complaint?: StringWithAggregatesFilter<"clinic_history"> | string
    diagnose?: StringWithAggregatesFilter<"clinic_history"> | string
    treatment?: StringWithAggregatesFilter<"clinic_history"> | string
    vital_signs?: StringWithAggregatesFilter<"clinic_history"> | string
    time_in?: DateTimeWithAggregatesFilter<"clinic_history"> | Date | string
    time_out?: DateTimeWithAggregatesFilter<"clinic_history"> | Date | string
    date?: StringWithAggregatesFilter<"clinic_history"> | string
    remarks?: StringWithAggregatesFilter<"clinic_history"> | string
  }

  export type countriesWhereInput = {
    AND?: countriesWhereInput | countriesWhereInput[]
    OR?: countriesWhereInput[]
    NOT?: countriesWhereInput | countriesWhereInput[]
    id?: IntFilter<"countries"> | number
    countryCode?: StringFilter<"countries"> | string
    countryName?: StringFilter<"countries"> | string
    currencyCode?: StringNullableFilter<"countries"> | string | null
    fipsCode?: StringNullableFilter<"countries"> | string | null
    isoNumeric?: StringNullableFilter<"countries"> | string | null
    north?: StringNullableFilter<"countries"> | string | null
    south?: StringNullableFilter<"countries"> | string | null
    east?: StringNullableFilter<"countries"> | string | null
    west?: StringNullableFilter<"countries"> | string | null
    capital?: StringNullableFilter<"countries"> | string | null
    continentName?: StringNullableFilter<"countries"> | string | null
    continent?: StringNullableFilter<"countries"> | string | null
    languages?: StringNullableFilter<"countries"> | string | null
  }

  export type countriesOrderByWithRelationInput = {
    id?: SortOrder
    countryCode?: SortOrder
    countryName?: SortOrder
    currencyCode?: SortOrderInput | SortOrder
    fipsCode?: SortOrderInput | SortOrder
    isoNumeric?: SortOrderInput | SortOrder
    north?: SortOrderInput | SortOrder
    south?: SortOrderInput | SortOrder
    east?: SortOrderInput | SortOrder
    west?: SortOrderInput | SortOrder
    capital?: SortOrderInput | SortOrder
    continentName?: SortOrderInput | SortOrder
    continent?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    _relevance?: countriesOrderByRelevanceInput
  }

  export type countriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: countriesWhereInput | countriesWhereInput[]
    OR?: countriesWhereInput[]
    NOT?: countriesWhereInput | countriesWhereInput[]
    countryCode?: StringFilter<"countries"> | string
    countryName?: StringFilter<"countries"> | string
    currencyCode?: StringNullableFilter<"countries"> | string | null
    fipsCode?: StringNullableFilter<"countries"> | string | null
    isoNumeric?: StringNullableFilter<"countries"> | string | null
    north?: StringNullableFilter<"countries"> | string | null
    south?: StringNullableFilter<"countries"> | string | null
    east?: StringNullableFilter<"countries"> | string | null
    west?: StringNullableFilter<"countries"> | string | null
    capital?: StringNullableFilter<"countries"> | string | null
    continentName?: StringNullableFilter<"countries"> | string | null
    continent?: StringNullableFilter<"countries"> | string | null
    languages?: StringNullableFilter<"countries"> | string | null
  }, "id">

  export type countriesOrderByWithAggregationInput = {
    id?: SortOrder
    countryCode?: SortOrder
    countryName?: SortOrder
    currencyCode?: SortOrderInput | SortOrder
    fipsCode?: SortOrderInput | SortOrder
    isoNumeric?: SortOrderInput | SortOrder
    north?: SortOrderInput | SortOrder
    south?: SortOrderInput | SortOrder
    east?: SortOrderInput | SortOrder
    west?: SortOrderInput | SortOrder
    capital?: SortOrderInput | SortOrder
    continentName?: SortOrderInput | SortOrder
    continent?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    _count?: countriesCountOrderByAggregateInput
    _avg?: countriesAvgOrderByAggregateInput
    _max?: countriesMaxOrderByAggregateInput
    _min?: countriesMinOrderByAggregateInput
    _sum?: countriesSumOrderByAggregateInput
  }

  export type countriesScalarWhereWithAggregatesInput = {
    AND?: countriesScalarWhereWithAggregatesInput | countriesScalarWhereWithAggregatesInput[]
    OR?: countriesScalarWhereWithAggregatesInput[]
    NOT?: countriesScalarWhereWithAggregatesInput | countriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"countries"> | number
    countryCode?: StringWithAggregatesFilter<"countries"> | string
    countryName?: StringWithAggregatesFilter<"countries"> | string
    currencyCode?: StringNullableWithAggregatesFilter<"countries"> | string | null
    fipsCode?: StringNullableWithAggregatesFilter<"countries"> | string | null
    isoNumeric?: StringNullableWithAggregatesFilter<"countries"> | string | null
    north?: StringNullableWithAggregatesFilter<"countries"> | string | null
    south?: StringNullableWithAggregatesFilter<"countries"> | string | null
    east?: StringNullableWithAggregatesFilter<"countries"> | string | null
    west?: StringNullableWithAggregatesFilter<"countries"> | string | null
    capital?: StringNullableWithAggregatesFilter<"countries"> | string | null
    continentName?: StringNullableWithAggregatesFilter<"countries"> | string | null
    continent?: StringNullableWithAggregatesFilter<"countries"> | string | null
    languages?: StringNullableWithAggregatesFilter<"countries"> | string | null
  }

  export type enrolledactivityWhereInput = {
    AND?: enrolledactivityWhereInput | enrolledactivityWhereInput[]
    OR?: enrolledactivityWhereInput[]
    NOT?: enrolledactivityWhereInput | enrolledactivityWhereInput[]
    id?: IntFilter<"enrolledactivity"> | number
    userId?: IntFilter<"enrolledactivity"> | number
    activityId?: IntFilter<"enrolledactivity"> | number
    enrollmentDate?: DateTimeFilter<"enrolledactivity"> | Date | string
    afterschoolactivity?: XOR<AfterschoolactivityScalarRelationFilter, afterschoolactivityWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type enrolledactivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    enrollmentDate?: SortOrder
    afterschoolactivity?: afterschoolactivityOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type enrolledactivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_activityId?: enrolledactivityUserIdActivityIdCompoundUniqueInput
    AND?: enrolledactivityWhereInput | enrolledactivityWhereInput[]
    OR?: enrolledactivityWhereInput[]
    NOT?: enrolledactivityWhereInput | enrolledactivityWhereInput[]
    userId?: IntFilter<"enrolledactivity"> | number
    activityId?: IntFilter<"enrolledactivity"> | number
    enrollmentDate?: DateTimeFilter<"enrolledactivity"> | Date | string
    afterschoolactivity?: XOR<AfterschoolactivityScalarRelationFilter, afterschoolactivityWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "userId_activityId">

  export type enrolledactivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    enrollmentDate?: SortOrder
    _count?: enrolledactivityCountOrderByAggregateInput
    _avg?: enrolledactivityAvgOrderByAggregateInput
    _max?: enrolledactivityMaxOrderByAggregateInput
    _min?: enrolledactivityMinOrderByAggregateInput
    _sum?: enrolledactivitySumOrderByAggregateInput
  }

  export type enrolledactivityScalarWhereWithAggregatesInput = {
    AND?: enrolledactivityScalarWhereWithAggregatesInput | enrolledactivityScalarWhereWithAggregatesInput[]
    OR?: enrolledactivityScalarWhereWithAggregatesInput[]
    NOT?: enrolledactivityScalarWhereWithAggregatesInput | enrolledactivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"enrolledactivity"> | number
    userId?: IntWithAggregatesFilter<"enrolledactivity"> | number
    activityId?: IntWithAggregatesFilter<"enrolledactivity"> | number
    enrollmentDate?: DateTimeWithAggregatesFilter<"enrolledactivity"> | Date | string
  }

  export type inventoryWhereInput = {
    AND?: inventoryWhereInput | inventoryWhereInput[]
    OR?: inventoryWhereInput[]
    NOT?: inventoryWhereInput | inventoryWhereInput[]
    id?: IntFilter<"inventory"> | number
    empno?: StringFilter<"inventory"> | string
    description?: StringFilter<"inventory"> | string
    serial?: StringFilter<"inventory"> | string
    dateout?: DateTimeFilter<"inventory"> | Date | string
    datein?: DateTimeFilter<"inventory"> | Date | string
    issuedby?: StringFilter<"inventory"> | string
    remarks?: StringFilter<"inventory"> | string
  }

  export type inventoryOrderByWithRelationInput = {
    id?: SortOrder
    empno?: SortOrder
    description?: SortOrder
    serial?: SortOrder
    dateout?: SortOrder
    datein?: SortOrder
    issuedby?: SortOrder
    remarks?: SortOrder
    _relevance?: inventoryOrderByRelevanceInput
  }

  export type inventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: inventoryWhereInput | inventoryWhereInput[]
    OR?: inventoryWhereInput[]
    NOT?: inventoryWhereInput | inventoryWhereInput[]
    empno?: StringFilter<"inventory"> | string
    description?: StringFilter<"inventory"> | string
    serial?: StringFilter<"inventory"> | string
    dateout?: DateTimeFilter<"inventory"> | Date | string
    datein?: DateTimeFilter<"inventory"> | Date | string
    issuedby?: StringFilter<"inventory"> | string
    remarks?: StringFilter<"inventory"> | string
  }, "id">

  export type inventoryOrderByWithAggregationInput = {
    id?: SortOrder
    empno?: SortOrder
    description?: SortOrder
    serial?: SortOrder
    dateout?: SortOrder
    datein?: SortOrder
    issuedby?: SortOrder
    remarks?: SortOrder
    _count?: inventoryCountOrderByAggregateInput
    _avg?: inventoryAvgOrderByAggregateInput
    _max?: inventoryMaxOrderByAggregateInput
    _min?: inventoryMinOrderByAggregateInput
    _sum?: inventorySumOrderByAggregateInput
  }

  export type inventoryScalarWhereWithAggregatesInput = {
    AND?: inventoryScalarWhereWithAggregatesInput | inventoryScalarWhereWithAggregatesInput[]
    OR?: inventoryScalarWhereWithAggregatesInput[]
    NOT?: inventoryScalarWhereWithAggregatesInput | inventoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"inventory"> | number
    empno?: StringWithAggregatesFilter<"inventory"> | string
    description?: StringWithAggregatesFilter<"inventory"> | string
    serial?: StringWithAggregatesFilter<"inventory"> | string
    dateout?: DateTimeWithAggregatesFilter<"inventory"> | Date | string
    datein?: DateTimeWithAggregatesFilter<"inventory"> | Date | string
    issuedby?: StringWithAggregatesFilter<"inventory"> | string
    remarks?: StringWithAggregatesFilter<"inventory"> | string
  }

  export type inventory__suppliersWhereInput = {
    AND?: inventory__suppliersWhereInput | inventory__suppliersWhereInput[]
    OR?: inventory__suppliersWhereInput[]
    NOT?: inventory__suppliersWhereInput | inventory__suppliersWhereInput[]
    id?: IntFilter<"inventory__suppliers"> | number
    companyName?: StringFilter<"inventory__suppliers"> | string
    itemsProvided?: StringNullableFilter<"inventory__suppliers"> | string | null
    address?: StringNullableFilter<"inventory__suppliers"> | string | null
    phoneNumber?: StringNullableFilter<"inventory__suppliers"> | string | null
    email?: StringNullableFilter<"inventory__suppliers"> | string | null
    rating?: DecimalNullableFilter<"inventory__suppliers"> | Decimal | DecimalJsLike | number | string | null
  }

  export type inventory__suppliersOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    itemsProvided?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    _relevance?: inventory__suppliersOrderByRelevanceInput
  }

  export type inventory__suppliersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: inventory__suppliersWhereInput | inventory__suppliersWhereInput[]
    OR?: inventory__suppliersWhereInput[]
    NOT?: inventory__suppliersWhereInput | inventory__suppliersWhereInput[]
    companyName?: StringFilter<"inventory__suppliers"> | string
    itemsProvided?: StringNullableFilter<"inventory__suppliers"> | string | null
    address?: StringNullableFilter<"inventory__suppliers"> | string | null
    phoneNumber?: StringNullableFilter<"inventory__suppliers"> | string | null
    email?: StringNullableFilter<"inventory__suppliers"> | string | null
    rating?: DecimalNullableFilter<"inventory__suppliers"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type inventory__suppliersOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    itemsProvided?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    _count?: inventory__suppliersCountOrderByAggregateInput
    _avg?: inventory__suppliersAvgOrderByAggregateInput
    _max?: inventory__suppliersMaxOrderByAggregateInput
    _min?: inventory__suppliersMinOrderByAggregateInput
    _sum?: inventory__suppliersSumOrderByAggregateInput
  }

  export type inventory__suppliersScalarWhereWithAggregatesInput = {
    AND?: inventory__suppliersScalarWhereWithAggregatesInput | inventory__suppliersScalarWhereWithAggregatesInput[]
    OR?: inventory__suppliersScalarWhereWithAggregatesInput[]
    NOT?: inventory__suppliersScalarWhereWithAggregatesInput | inventory__suppliersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"inventory__suppliers"> | number
    companyName?: StringWithAggregatesFilter<"inventory__suppliers"> | string
    itemsProvided?: StringNullableWithAggregatesFilter<"inventory__suppliers"> | string | null
    address?: StringNullableWithAggregatesFilter<"inventory__suppliers"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"inventory__suppliers"> | string | null
    email?: StringNullableWithAggregatesFilter<"inventory__suppliers"> | string | null
    rating?: DecimalNullableWithAggregatesFilter<"inventory__suppliers"> | Decimal | DecimalJsLike | number | string | null
  }

  export type inventory_bookstoreWhereInput = {
    AND?: inventory_bookstoreWhereInput | inventory_bookstoreWhereInput[]
    OR?: inventory_bookstoreWhereInput[]
    NOT?: inventory_bookstoreWhereInput | inventory_bookstoreWhereInput[]
    id?: IntFilter<"inventory_bookstore"> | number
    product_name?: StringFilter<"inventory_bookstore"> | string
    quantity?: IntFilter<"inventory_bookstore"> | number
    selling_price?: FloatFilter<"inventory_bookstore"> | number
    date?: DateTimeFilter<"inventory_bookstore"> | Date | string
  }

  export type inventory_bookstoreOrderByWithRelationInput = {
    id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    selling_price?: SortOrder
    date?: SortOrder
    _relevance?: inventory_bookstoreOrderByRelevanceInput
  }

  export type inventory_bookstoreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: inventory_bookstoreWhereInput | inventory_bookstoreWhereInput[]
    OR?: inventory_bookstoreWhereInput[]
    NOT?: inventory_bookstoreWhereInput | inventory_bookstoreWhereInput[]
    product_name?: StringFilter<"inventory_bookstore"> | string
    quantity?: IntFilter<"inventory_bookstore"> | number
    selling_price?: FloatFilter<"inventory_bookstore"> | number
    date?: DateTimeFilter<"inventory_bookstore"> | Date | string
  }, "id">

  export type inventory_bookstoreOrderByWithAggregationInput = {
    id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    selling_price?: SortOrder
    date?: SortOrder
    _count?: inventory_bookstoreCountOrderByAggregateInput
    _avg?: inventory_bookstoreAvgOrderByAggregateInput
    _max?: inventory_bookstoreMaxOrderByAggregateInput
    _min?: inventory_bookstoreMinOrderByAggregateInput
    _sum?: inventory_bookstoreSumOrderByAggregateInput
  }

  export type inventory_bookstoreScalarWhereWithAggregatesInput = {
    AND?: inventory_bookstoreScalarWhereWithAggregatesInput | inventory_bookstoreScalarWhereWithAggregatesInput[]
    OR?: inventory_bookstoreScalarWhereWithAggregatesInput[]
    NOT?: inventory_bookstoreScalarWhereWithAggregatesInput | inventory_bookstoreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"inventory_bookstore"> | number
    product_name?: StringWithAggregatesFilter<"inventory_bookstore"> | string
    quantity?: IntWithAggregatesFilter<"inventory_bookstore"> | number
    selling_price?: FloatWithAggregatesFilter<"inventory_bookstore"> | number
    date?: DateTimeWithAggregatesFilter<"inventory_bookstore"> | Date | string
  }

  export type library_loginWhereInput = {
    AND?: library_loginWhereInput | library_loginWhereInput[]
    OR?: library_loginWhereInput[]
    NOT?: library_loginWhereInput | library_loginWhereInput[]
    id?: IntFilter<"library_login"> | number
    username?: StringNullableFilter<"library_login"> | string | null
    password?: StringNullableFilter<"library_login"> | string | null
  }

  export type library_loginOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    _relevance?: library_loginOrderByRelevanceInput
  }

  export type library_loginWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: library_loginWhereInput | library_loginWhereInput[]
    OR?: library_loginWhereInput[]
    NOT?: library_loginWhereInput | library_loginWhereInput[]
    username?: StringNullableFilter<"library_login"> | string | null
    password?: StringNullableFilter<"library_login"> | string | null
  }, "id">

  export type library_loginOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    _count?: library_loginCountOrderByAggregateInput
    _avg?: library_loginAvgOrderByAggregateInput
    _max?: library_loginMaxOrderByAggregateInput
    _min?: library_loginMinOrderByAggregateInput
    _sum?: library_loginSumOrderByAggregateInput
  }

  export type library_loginScalarWhereWithAggregatesInput = {
    AND?: library_loginScalarWhereWithAggregatesInput | library_loginScalarWhereWithAggregatesInput[]
    OR?: library_loginScalarWhereWithAggregatesInput[]
    NOT?: library_loginScalarWhereWithAggregatesInput | library_loginScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"library_login"> | number
    username?: StringNullableWithAggregatesFilter<"library_login"> | string | null
    password?: StringNullableWithAggregatesFilter<"library_login"> | string | null
  }

  export type logs_enrollWhereInput = {
    AND?: logs_enrollWhereInput | logs_enrollWhereInput[]
    OR?: logs_enrollWhereInput[]
    NOT?: logs_enrollWhereInput | logs_enrollWhereInput[]
    id?: IntFilter<"logs_enroll"> | number
    ern?: StringFilter<"logs_enroll"> | string
    stage?: IntFilter<"logs_enroll"> | number
    usertouch?: StringFilter<"logs_enroll"> | string
    touch?: DateTimeFilter<"logs_enroll"> | Date | string
    notes?: StringFilter<"logs_enroll"> | string
  }

  export type logs_enrollOrderByWithRelationInput = {
    id?: SortOrder
    ern?: SortOrder
    stage?: SortOrder
    usertouch?: SortOrder
    touch?: SortOrder
    notes?: SortOrder
    _relevance?: logs_enrollOrderByRelevanceInput
  }

  export type logs_enrollWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: logs_enrollWhereInput | logs_enrollWhereInput[]
    OR?: logs_enrollWhereInput[]
    NOT?: logs_enrollWhereInput | logs_enrollWhereInput[]
    ern?: StringFilter<"logs_enroll"> | string
    stage?: IntFilter<"logs_enroll"> | number
    usertouch?: StringFilter<"logs_enroll"> | string
    touch?: DateTimeFilter<"logs_enroll"> | Date | string
    notes?: StringFilter<"logs_enroll"> | string
  }, "id">

  export type logs_enrollOrderByWithAggregationInput = {
    id?: SortOrder
    ern?: SortOrder
    stage?: SortOrder
    usertouch?: SortOrder
    touch?: SortOrder
    notes?: SortOrder
    _count?: logs_enrollCountOrderByAggregateInput
    _avg?: logs_enrollAvgOrderByAggregateInput
    _max?: logs_enrollMaxOrderByAggregateInput
    _min?: logs_enrollMinOrderByAggregateInput
    _sum?: logs_enrollSumOrderByAggregateInput
  }

  export type logs_enrollScalarWhereWithAggregatesInput = {
    AND?: logs_enrollScalarWhereWithAggregatesInput | logs_enrollScalarWhereWithAggregatesInput[]
    OR?: logs_enrollScalarWhereWithAggregatesInput[]
    NOT?: logs_enrollScalarWhereWithAggregatesInput | logs_enrollScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"logs_enroll"> | number
    ern?: StringWithAggregatesFilter<"logs_enroll"> | string
    stage?: IntWithAggregatesFilter<"logs_enroll"> | number
    usertouch?: StringWithAggregatesFilter<"logs_enroll"> | string
    touch?: DateTimeWithAggregatesFilter<"logs_enroll"> | Date | string
    notes?: StringWithAggregatesFilter<"logs_enroll"> | string
  }

  export type nationalitiesWhereInput = {
    AND?: nationalitiesWhereInput | nationalitiesWhereInput[]
    OR?: nationalitiesWhereInput[]
    NOT?: nationalitiesWhereInput | nationalitiesWhereInput[]
    id?: IntFilter<"nationalities"> | number
    countryCode?: StringFilter<"nationalities"> | string
    nationalityName?: StringFilter<"nationalities"> | string
    currencyCode?: StringNullableFilter<"nationalities"> | string | null
    fipsCode?: StringNullableFilter<"nationalities"> | string | null
    isoNumeric?: StringNullableFilter<"nationalities"> | string | null
    north?: StringNullableFilter<"nationalities"> | string | null
    south?: StringNullableFilter<"nationalities"> | string | null
    east?: StringNullableFilter<"nationalities"> | string | null
    west?: StringNullableFilter<"nationalities"> | string | null
    capital?: StringNullableFilter<"nationalities"> | string | null
    continentName?: StringNullableFilter<"nationalities"> | string | null
    continent?: StringNullableFilter<"nationalities"> | string | null
  }

  export type nationalitiesOrderByWithRelationInput = {
    id?: SortOrder
    countryCode?: SortOrder
    nationalityName?: SortOrder
    currencyCode?: SortOrderInput | SortOrder
    fipsCode?: SortOrderInput | SortOrder
    isoNumeric?: SortOrderInput | SortOrder
    north?: SortOrderInput | SortOrder
    south?: SortOrderInput | SortOrder
    east?: SortOrderInput | SortOrder
    west?: SortOrderInput | SortOrder
    capital?: SortOrderInput | SortOrder
    continentName?: SortOrderInput | SortOrder
    continent?: SortOrderInput | SortOrder
    _relevance?: nationalitiesOrderByRelevanceInput
  }

  export type nationalitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: nationalitiesWhereInput | nationalitiesWhereInput[]
    OR?: nationalitiesWhereInput[]
    NOT?: nationalitiesWhereInput | nationalitiesWhereInput[]
    countryCode?: StringFilter<"nationalities"> | string
    nationalityName?: StringFilter<"nationalities"> | string
    currencyCode?: StringNullableFilter<"nationalities"> | string | null
    fipsCode?: StringNullableFilter<"nationalities"> | string | null
    isoNumeric?: StringNullableFilter<"nationalities"> | string | null
    north?: StringNullableFilter<"nationalities"> | string | null
    south?: StringNullableFilter<"nationalities"> | string | null
    east?: StringNullableFilter<"nationalities"> | string | null
    west?: StringNullableFilter<"nationalities"> | string | null
    capital?: StringNullableFilter<"nationalities"> | string | null
    continentName?: StringNullableFilter<"nationalities"> | string | null
    continent?: StringNullableFilter<"nationalities"> | string | null
  }, "id">

  export type nationalitiesOrderByWithAggregationInput = {
    id?: SortOrder
    countryCode?: SortOrder
    nationalityName?: SortOrder
    currencyCode?: SortOrderInput | SortOrder
    fipsCode?: SortOrderInput | SortOrder
    isoNumeric?: SortOrderInput | SortOrder
    north?: SortOrderInput | SortOrder
    south?: SortOrderInput | SortOrder
    east?: SortOrderInput | SortOrder
    west?: SortOrderInput | SortOrder
    capital?: SortOrderInput | SortOrder
    continentName?: SortOrderInput | SortOrder
    continent?: SortOrderInput | SortOrder
    _count?: nationalitiesCountOrderByAggregateInput
    _avg?: nationalitiesAvgOrderByAggregateInput
    _max?: nationalitiesMaxOrderByAggregateInput
    _min?: nationalitiesMinOrderByAggregateInput
    _sum?: nationalitiesSumOrderByAggregateInput
  }

  export type nationalitiesScalarWhereWithAggregatesInput = {
    AND?: nationalitiesScalarWhereWithAggregatesInput | nationalitiesScalarWhereWithAggregatesInput[]
    OR?: nationalitiesScalarWhereWithAggregatesInput[]
    NOT?: nationalitiesScalarWhereWithAggregatesInput | nationalitiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"nationalities"> | number
    countryCode?: StringWithAggregatesFilter<"nationalities"> | string
    nationalityName?: StringWithAggregatesFilter<"nationalities"> | string
    currencyCode?: StringNullableWithAggregatesFilter<"nationalities"> | string | null
    fipsCode?: StringNullableWithAggregatesFilter<"nationalities"> | string | null
    isoNumeric?: StringNullableWithAggregatesFilter<"nationalities"> | string | null
    north?: StringNullableWithAggregatesFilter<"nationalities"> | string | null
    south?: StringNullableWithAggregatesFilter<"nationalities"> | string | null
    east?: StringNullableWithAggregatesFilter<"nationalities"> | string | null
    west?: StringNullableWithAggregatesFilter<"nationalities"> | string | null
    capital?: StringNullableWithAggregatesFilter<"nationalities"> | string | null
    continentName?: StringNullableWithAggregatesFilter<"nationalities"> | string | null
    continent?: StringNullableWithAggregatesFilter<"nationalities"> | string | null
  }

  export type productsWhereInput = {
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    id?: IntFilter<"products"> | number
    product_code?: StringFilter<"products"> | string
    type_of_product?: StringFilter<"products"> | string
    name_of_product?: StringFilter<"products"> | string
    price_of_product?: FloatFilter<"products"> | number
    date_created?: DateTimeFilter<"products"> | Date | string
    last_touch?: StringFilter<"products"> | string
  }

  export type productsOrderByWithRelationInput = {
    id?: SortOrder
    product_code?: SortOrder
    type_of_product?: SortOrder
    name_of_product?: SortOrder
    price_of_product?: SortOrder
    date_created?: SortOrder
    last_touch?: SortOrder
    _relevance?: productsOrderByRelevanceInput
  }

  export type productsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    product_code?: StringFilter<"products"> | string
    type_of_product?: StringFilter<"products"> | string
    name_of_product?: StringFilter<"products"> | string
    price_of_product?: FloatFilter<"products"> | number
    date_created?: DateTimeFilter<"products"> | Date | string
    last_touch?: StringFilter<"products"> | string
  }, "id">

  export type productsOrderByWithAggregationInput = {
    id?: SortOrder
    product_code?: SortOrder
    type_of_product?: SortOrder
    name_of_product?: SortOrder
    price_of_product?: SortOrder
    date_created?: SortOrder
    last_touch?: SortOrder
    _count?: productsCountOrderByAggregateInput
    _avg?: productsAvgOrderByAggregateInput
    _max?: productsMaxOrderByAggregateInput
    _min?: productsMinOrderByAggregateInput
    _sum?: productsSumOrderByAggregateInput
  }

  export type productsScalarWhereWithAggregatesInput = {
    AND?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    OR?: productsScalarWhereWithAggregatesInput[]
    NOT?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"products"> | number
    product_code?: StringWithAggregatesFilter<"products"> | string
    type_of_product?: StringWithAggregatesFilter<"products"> | string
    name_of_product?: StringWithAggregatesFilter<"products"> | string
    price_of_product?: FloatWithAggregatesFilter<"products"> | number
    date_created?: DateTimeWithAggregatesFilter<"products"> | Date | string
    last_touch?: StringWithAggregatesFilter<"products"> | string
  }

  export type requestsWhereInput = {
    AND?: requestsWhereInput | requestsWhereInput[]
    OR?: requestsWhereInput[]
    NOT?: requestsWhereInput | requestsWhereInput[]
    id?: IntFilter<"requests"> | number
    rfid?: BigIntFilter<"requests"> | bigint | number
    reqtype?: StringFilter<"requests"> | string
    reqdate?: DateTimeFilter<"requests"> | Date | string
    reqneed?: DateTimeFilter<"requests"> | Date | string
    reqdetails?: StringFilter<"requests"> | string
    approvedby?: BigIntFilter<"requests"> | bigint | number
    approvedate?: DateTimeFilter<"requests"> | Date | string
    approvedfin?: BigIntFilter<"requests"> | bigint | number
    approvedfindate?: DateTimeFilter<"requests"> | Date | string
    status?: StringFilter<"requests"> | string
  }

  export type requestsOrderByWithRelationInput = {
    id?: SortOrder
    rfid?: SortOrder
    reqtype?: SortOrder
    reqdate?: SortOrder
    reqneed?: SortOrder
    reqdetails?: SortOrder
    approvedby?: SortOrder
    approvedate?: SortOrder
    approvedfin?: SortOrder
    approvedfindate?: SortOrder
    status?: SortOrder
    _relevance?: requestsOrderByRelevanceInput
  }

  export type requestsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: requestsWhereInput | requestsWhereInput[]
    OR?: requestsWhereInput[]
    NOT?: requestsWhereInput | requestsWhereInput[]
    rfid?: BigIntFilter<"requests"> | bigint | number
    reqtype?: StringFilter<"requests"> | string
    reqdate?: DateTimeFilter<"requests"> | Date | string
    reqneed?: DateTimeFilter<"requests"> | Date | string
    reqdetails?: StringFilter<"requests"> | string
    approvedby?: BigIntFilter<"requests"> | bigint | number
    approvedate?: DateTimeFilter<"requests"> | Date | string
    approvedfin?: BigIntFilter<"requests"> | bigint | number
    approvedfindate?: DateTimeFilter<"requests"> | Date | string
    status?: StringFilter<"requests"> | string
  }, "id">

  export type requestsOrderByWithAggregationInput = {
    id?: SortOrder
    rfid?: SortOrder
    reqtype?: SortOrder
    reqdate?: SortOrder
    reqneed?: SortOrder
    reqdetails?: SortOrder
    approvedby?: SortOrder
    approvedate?: SortOrder
    approvedfin?: SortOrder
    approvedfindate?: SortOrder
    status?: SortOrder
    _count?: requestsCountOrderByAggregateInput
    _avg?: requestsAvgOrderByAggregateInput
    _max?: requestsMaxOrderByAggregateInput
    _min?: requestsMinOrderByAggregateInput
    _sum?: requestsSumOrderByAggregateInput
  }

  export type requestsScalarWhereWithAggregatesInput = {
    AND?: requestsScalarWhereWithAggregatesInput | requestsScalarWhereWithAggregatesInput[]
    OR?: requestsScalarWhereWithAggregatesInput[]
    NOT?: requestsScalarWhereWithAggregatesInput | requestsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"requests"> | number
    rfid?: BigIntWithAggregatesFilter<"requests"> | bigint | number
    reqtype?: StringWithAggregatesFilter<"requests"> | string
    reqdate?: DateTimeWithAggregatesFilter<"requests"> | Date | string
    reqneed?: DateTimeWithAggregatesFilter<"requests"> | Date | string
    reqdetails?: StringWithAggregatesFilter<"requests"> | string
    approvedby?: BigIntWithAggregatesFilter<"requests"> | bigint | number
    approvedate?: DateTimeWithAggregatesFilter<"requests"> | Date | string
    approvedfin?: BigIntWithAggregatesFilter<"requests"> | bigint | number
    approvedfindate?: DateTimeWithAggregatesFilter<"requests"> | Date | string
    status?: StringWithAggregatesFilter<"requests"> | string
  }

  export type s_activitiesWhereInput = {
    AND?: s_activitiesWhereInput | s_activitiesWhereInput[]
    OR?: s_activitiesWhereInput[]
    NOT?: s_activitiesWhereInput | s_activitiesWhereInput[]
    id?: IntFilter<"s_activities"> | number
    actid?: StringFilter<"s_activities"> | string
    subjcode?: StringFilter<"s_activities"> | string
    actlvl?: IntFilter<"s_activities"> | number
    actsection?: StringFilter<"s_activities"> | string
    actdate?: DateTimeFilter<"s_activities"> | Date | string
    actcreate?: StringFilter<"s_activities"> | string
    actdesc?: StringFilter<"s_activities"> | string
    acttype?: IntFilter<"s_activities"> | number
    actqtr?: IntFilter<"s_activities"> | number
    maxscore?: IntFilter<"s_activities"> | number
    flag?: IntFilter<"s_activities"> | number
  }

  export type s_activitiesOrderByWithRelationInput = {
    id?: SortOrder
    actid?: SortOrder
    subjcode?: SortOrder
    actlvl?: SortOrder
    actsection?: SortOrder
    actdate?: SortOrder
    actcreate?: SortOrder
    actdesc?: SortOrder
    acttype?: SortOrder
    actqtr?: SortOrder
    maxscore?: SortOrder
    flag?: SortOrder
    _relevance?: s_activitiesOrderByRelevanceInput
  }

  export type s_activitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: s_activitiesWhereInput | s_activitiesWhereInput[]
    OR?: s_activitiesWhereInput[]
    NOT?: s_activitiesWhereInput | s_activitiesWhereInput[]
    actid?: StringFilter<"s_activities"> | string
    subjcode?: StringFilter<"s_activities"> | string
    actlvl?: IntFilter<"s_activities"> | number
    actsection?: StringFilter<"s_activities"> | string
    actdate?: DateTimeFilter<"s_activities"> | Date | string
    actcreate?: StringFilter<"s_activities"> | string
    actdesc?: StringFilter<"s_activities"> | string
    acttype?: IntFilter<"s_activities"> | number
    actqtr?: IntFilter<"s_activities"> | number
    maxscore?: IntFilter<"s_activities"> | number
    flag?: IntFilter<"s_activities"> | number
  }, "id">

  export type s_activitiesOrderByWithAggregationInput = {
    id?: SortOrder
    actid?: SortOrder
    subjcode?: SortOrder
    actlvl?: SortOrder
    actsection?: SortOrder
    actdate?: SortOrder
    actcreate?: SortOrder
    actdesc?: SortOrder
    acttype?: SortOrder
    actqtr?: SortOrder
    maxscore?: SortOrder
    flag?: SortOrder
    _count?: s_activitiesCountOrderByAggregateInput
    _avg?: s_activitiesAvgOrderByAggregateInput
    _max?: s_activitiesMaxOrderByAggregateInput
    _min?: s_activitiesMinOrderByAggregateInput
    _sum?: s_activitiesSumOrderByAggregateInput
  }

  export type s_activitiesScalarWhereWithAggregatesInput = {
    AND?: s_activitiesScalarWhereWithAggregatesInput | s_activitiesScalarWhereWithAggregatesInput[]
    OR?: s_activitiesScalarWhereWithAggregatesInput[]
    NOT?: s_activitiesScalarWhereWithAggregatesInput | s_activitiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"s_activities"> | number
    actid?: StringWithAggregatesFilter<"s_activities"> | string
    subjcode?: StringWithAggregatesFilter<"s_activities"> | string
    actlvl?: IntWithAggregatesFilter<"s_activities"> | number
    actsection?: StringWithAggregatesFilter<"s_activities"> | string
    actdate?: DateTimeWithAggregatesFilter<"s_activities"> | Date | string
    actcreate?: StringWithAggregatesFilter<"s_activities"> | string
    actdesc?: StringWithAggregatesFilter<"s_activities"> | string
    acttype?: IntWithAggregatesFilter<"s_activities"> | number
    actqtr?: IntWithAggregatesFilter<"s_activities"> | number
    maxscore?: IntWithAggregatesFilter<"s_activities"> | number
    flag?: IntWithAggregatesFilter<"s_activities"> | number
  }

  export type s_classattendanceWhereInput = {
    AND?: s_classattendanceWhereInput | s_classattendanceWhereInput[]
    OR?: s_classattendanceWhereInput[]
    NOT?: s_classattendanceWhereInput | s_classattendanceWhereInput[]
    id?: IntFilter<"s_classattendance"> | number
    attendance?: IntFilter<"s_classattendance"> | number
    subjid?: StringFilter<"s_classattendance"> | string
    studid?: StringFilter<"s_classattendance"> | string
    adate?: DateTimeFilter<"s_classattendance"> | Date | string
    tid?: StringFilter<"s_classattendance"> | string
    notes?: StringFilter<"s_classattendance"> | string
  }

  export type s_classattendanceOrderByWithRelationInput = {
    id?: SortOrder
    attendance?: SortOrder
    subjid?: SortOrder
    studid?: SortOrder
    adate?: SortOrder
    tid?: SortOrder
    notes?: SortOrder
    _relevance?: s_classattendanceOrderByRelevanceInput
  }

  export type s_classattendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: s_classattendanceWhereInput | s_classattendanceWhereInput[]
    OR?: s_classattendanceWhereInput[]
    NOT?: s_classattendanceWhereInput | s_classattendanceWhereInput[]
    attendance?: IntFilter<"s_classattendance"> | number
    subjid?: StringFilter<"s_classattendance"> | string
    studid?: StringFilter<"s_classattendance"> | string
    adate?: DateTimeFilter<"s_classattendance"> | Date | string
    tid?: StringFilter<"s_classattendance"> | string
    notes?: StringFilter<"s_classattendance"> | string
  }, "id">

  export type s_classattendanceOrderByWithAggregationInput = {
    id?: SortOrder
    attendance?: SortOrder
    subjid?: SortOrder
    studid?: SortOrder
    adate?: SortOrder
    tid?: SortOrder
    notes?: SortOrder
    _count?: s_classattendanceCountOrderByAggregateInput
    _avg?: s_classattendanceAvgOrderByAggregateInput
    _max?: s_classattendanceMaxOrderByAggregateInput
    _min?: s_classattendanceMinOrderByAggregateInput
    _sum?: s_classattendanceSumOrderByAggregateInput
  }

  export type s_classattendanceScalarWhereWithAggregatesInput = {
    AND?: s_classattendanceScalarWhereWithAggregatesInput | s_classattendanceScalarWhereWithAggregatesInput[]
    OR?: s_classattendanceScalarWhereWithAggregatesInput[]
    NOT?: s_classattendanceScalarWhereWithAggregatesInput | s_classattendanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"s_classattendance"> | number
    attendance?: IntWithAggregatesFilter<"s_classattendance"> | number
    subjid?: StringWithAggregatesFilter<"s_classattendance"> | string
    studid?: StringWithAggregatesFilter<"s_classattendance"> | string
    adate?: DateTimeWithAggregatesFilter<"s_classattendance"> | Date | string
    tid?: StringWithAggregatesFilter<"s_classattendance"> | string
    notes?: StringWithAggregatesFilter<"s_classattendance"> | string
  }

  export type s_coretableWhereInput = {
    AND?: s_coretableWhereInput | s_coretableWhereInput[]
    OR?: s_coretableWhereInput[]
    NOT?: s_coretableWhereInput | s_coretableWhereInput[]
    id?: IntFilter<"s_coretable"> | number
    start?: DecimalFilter<"s_coretable"> | Decimal | DecimalJsLike | number | string
    end?: DecimalFilter<"s_coretable"> | Decimal | DecimalJsLike | number | string
    grade?: StringFilter<"s_coretable"> | string
  }

  export type s_coretableOrderByWithRelationInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    grade?: SortOrder
    _relevance?: s_coretableOrderByRelevanceInput
  }

  export type s_coretableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: s_coretableWhereInput | s_coretableWhereInput[]
    OR?: s_coretableWhereInput[]
    NOT?: s_coretableWhereInput | s_coretableWhereInput[]
    start?: DecimalFilter<"s_coretable"> | Decimal | DecimalJsLike | number | string
    end?: DecimalFilter<"s_coretable"> | Decimal | DecimalJsLike | number | string
    grade?: StringFilter<"s_coretable"> | string
  }, "id">

  export type s_coretableOrderByWithAggregationInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    grade?: SortOrder
    _count?: s_coretableCountOrderByAggregateInput
    _avg?: s_coretableAvgOrderByAggregateInput
    _max?: s_coretableMaxOrderByAggregateInput
    _min?: s_coretableMinOrderByAggregateInput
    _sum?: s_coretableSumOrderByAggregateInput
  }

  export type s_coretableScalarWhereWithAggregatesInput = {
    AND?: s_coretableScalarWhereWithAggregatesInput | s_coretableScalarWhereWithAggregatesInput[]
    OR?: s_coretableScalarWhereWithAggregatesInput[]
    NOT?: s_coretableScalarWhereWithAggregatesInput | s_coretableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"s_coretable"> | number
    start?: DecimalWithAggregatesFilter<"s_coretable"> | Decimal | DecimalJsLike | number | string
    end?: DecimalWithAggregatesFilter<"s_coretable"> | Decimal | DecimalJsLike | number | string
    grade?: StringWithAggregatesFilter<"s_coretable"> | string
  }

  export type s_corevaluesWhereInput = {
    AND?: s_corevaluesWhereInput | s_corevaluesWhereInput[]
    OR?: s_corevaluesWhereInput[]
    NOT?: s_corevaluesWhereInput | s_corevaluesWhereInput[]
    id?: IntFilter<"s_corevalues"> | number
    corevalue?: StringFilter<"s_corevalues"> | string
  }

  export type s_corevaluesOrderByWithRelationInput = {
    id?: SortOrder
    corevalue?: SortOrder
    _relevance?: s_corevaluesOrderByRelevanceInput
  }

  export type s_corevaluesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: s_corevaluesWhereInput | s_corevaluesWhereInput[]
    OR?: s_corevaluesWhereInput[]
    NOT?: s_corevaluesWhereInput | s_corevaluesWhereInput[]
    corevalue?: StringFilter<"s_corevalues"> | string
  }, "id">

  export type s_corevaluesOrderByWithAggregationInput = {
    id?: SortOrder
    corevalue?: SortOrder
    _count?: s_corevaluesCountOrderByAggregateInput
    _avg?: s_corevaluesAvgOrderByAggregateInput
    _max?: s_corevaluesMaxOrderByAggregateInput
    _min?: s_corevaluesMinOrderByAggregateInput
    _sum?: s_corevaluesSumOrderByAggregateInput
  }

  export type s_corevaluesScalarWhereWithAggregatesInput = {
    AND?: s_corevaluesScalarWhereWithAggregatesInput | s_corevaluesScalarWhereWithAggregatesInput[]
    OR?: s_corevaluesScalarWhereWithAggregatesInput[]
    NOT?: s_corevaluesScalarWhereWithAggregatesInput | s_corevaluesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"s_corevalues"> | number
    corevalue?: StringWithAggregatesFilter<"s_corevalues"> | string
  }

  export type s_payablesWhereInput = {
    AND?: s_payablesWhereInput | s_payablesWhereInput[]
    OR?: s_payablesWhereInput[]
    NOT?: s_payablesWhereInput | s_payablesWhereInput[]
    id?: IntFilter<"s_payables"> | number
    user_id?: StringFilter<"s_payables"> | string
    reservation_fee?: IntNullableFilter<"s_payables"> | number | null
    tuition_fee?: IntNullableFilter<"s_payables"> | number | null
    other_fee?: IntNullableFilter<"s_payables"> | number | null
    assessment_fee?: IntNullableFilter<"s_payables"> | number | null
    registration_fee?: IntNullableFilter<"s_payables"> | number | null
    special_permit?: IntNullableFilter<"s_payables"> | number | null
    international_fee_old?: IntNullableFilter<"s_payables"> | number | null
    international_fee_new?: IntNullableFilter<"s_payables"> | number | null
    pta?: IntNullableFilter<"s_payables"> | number | null
  }

  export type s_payablesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    reservation_fee?: SortOrderInput | SortOrder
    tuition_fee?: SortOrderInput | SortOrder
    other_fee?: SortOrderInput | SortOrder
    assessment_fee?: SortOrderInput | SortOrder
    registration_fee?: SortOrderInput | SortOrder
    special_permit?: SortOrderInput | SortOrder
    international_fee_old?: SortOrderInput | SortOrder
    international_fee_new?: SortOrderInput | SortOrder
    pta?: SortOrderInput | SortOrder
    _relevance?: s_payablesOrderByRelevanceInput
  }

  export type s_payablesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: s_payablesWhereInput | s_payablesWhereInput[]
    OR?: s_payablesWhereInput[]
    NOT?: s_payablesWhereInput | s_payablesWhereInput[]
    user_id?: StringFilter<"s_payables"> | string
    reservation_fee?: IntNullableFilter<"s_payables"> | number | null
    tuition_fee?: IntNullableFilter<"s_payables"> | number | null
    other_fee?: IntNullableFilter<"s_payables"> | number | null
    assessment_fee?: IntNullableFilter<"s_payables"> | number | null
    registration_fee?: IntNullableFilter<"s_payables"> | number | null
    special_permit?: IntNullableFilter<"s_payables"> | number | null
    international_fee_old?: IntNullableFilter<"s_payables"> | number | null
    international_fee_new?: IntNullableFilter<"s_payables"> | number | null
    pta?: IntNullableFilter<"s_payables"> | number | null
  }, "id">

  export type s_payablesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    reservation_fee?: SortOrderInput | SortOrder
    tuition_fee?: SortOrderInput | SortOrder
    other_fee?: SortOrderInput | SortOrder
    assessment_fee?: SortOrderInput | SortOrder
    registration_fee?: SortOrderInput | SortOrder
    special_permit?: SortOrderInput | SortOrder
    international_fee_old?: SortOrderInput | SortOrder
    international_fee_new?: SortOrderInput | SortOrder
    pta?: SortOrderInput | SortOrder
    _count?: s_payablesCountOrderByAggregateInput
    _avg?: s_payablesAvgOrderByAggregateInput
    _max?: s_payablesMaxOrderByAggregateInput
    _min?: s_payablesMinOrderByAggregateInput
    _sum?: s_payablesSumOrderByAggregateInput
  }

  export type s_payablesScalarWhereWithAggregatesInput = {
    AND?: s_payablesScalarWhereWithAggregatesInput | s_payablesScalarWhereWithAggregatesInput[]
    OR?: s_payablesScalarWhereWithAggregatesInput[]
    NOT?: s_payablesScalarWhereWithAggregatesInput | s_payablesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"s_payables"> | number
    user_id?: StringWithAggregatesFilter<"s_payables"> | string
    reservation_fee?: IntNullableWithAggregatesFilter<"s_payables"> | number | null
    tuition_fee?: IntNullableWithAggregatesFilter<"s_payables"> | number | null
    other_fee?: IntNullableWithAggregatesFilter<"s_payables"> | number | null
    assessment_fee?: IntNullableWithAggregatesFilter<"s_payables"> | number | null
    registration_fee?: IntNullableWithAggregatesFilter<"s_payables"> | number | null
    special_permit?: IntNullableWithAggregatesFilter<"s_payables"> | number | null
    international_fee_old?: IntNullableWithAggregatesFilter<"s_payables"> | number | null
    international_fee_new?: IntNullableWithAggregatesFilter<"s_payables"> | number | null
    pta?: IntNullableWithAggregatesFilter<"s_payables"> | number | null
  }

  export type s_recommendationsWhereInput = {
    AND?: s_recommendationsWhereInput | s_recommendationsWhereInput[]
    OR?: s_recommendationsWhereInput[]
    NOT?: s_recommendationsWhereInput | s_recommendationsWhereInput[]
    id?: IntFilter<"s_recommendations"> | number
    user_id?: StringFilter<"s_recommendations"> | string
    esl?: IntNullableFilter<"s_recommendations"> | number | null
    star?: IntNullableFilter<"s_recommendations"> | number | null
    completion?: IntNullableFilter<"s_recommendations"> | number | null
  }

  export type s_recommendationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    esl?: SortOrderInput | SortOrder
    star?: SortOrderInput | SortOrder
    completion?: SortOrderInput | SortOrder
    _relevance?: s_recommendationsOrderByRelevanceInput
  }

  export type s_recommendationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: s_recommendationsWhereInput | s_recommendationsWhereInput[]
    OR?: s_recommendationsWhereInput[]
    NOT?: s_recommendationsWhereInput | s_recommendationsWhereInput[]
    user_id?: StringFilter<"s_recommendations"> | string
    esl?: IntNullableFilter<"s_recommendations"> | number | null
    star?: IntNullableFilter<"s_recommendations"> | number | null
    completion?: IntNullableFilter<"s_recommendations"> | number | null
  }, "id">

  export type s_recommendationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    esl?: SortOrderInput | SortOrder
    star?: SortOrderInput | SortOrder
    completion?: SortOrderInput | SortOrder
    _count?: s_recommendationsCountOrderByAggregateInput
    _avg?: s_recommendationsAvgOrderByAggregateInput
    _max?: s_recommendationsMaxOrderByAggregateInput
    _min?: s_recommendationsMinOrderByAggregateInput
    _sum?: s_recommendationsSumOrderByAggregateInput
  }

  export type s_recommendationsScalarWhereWithAggregatesInput = {
    AND?: s_recommendationsScalarWhereWithAggregatesInput | s_recommendationsScalarWhereWithAggregatesInput[]
    OR?: s_recommendationsScalarWhereWithAggregatesInput[]
    NOT?: s_recommendationsScalarWhereWithAggregatesInput | s_recommendationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"s_recommendations"> | number
    user_id?: StringWithAggregatesFilter<"s_recommendations"> | string
    esl?: IntNullableWithAggregatesFilter<"s_recommendations"> | number | null
    star?: IntNullableWithAggregatesFilter<"s_recommendations"> | number | null
    completion?: IntNullableWithAggregatesFilter<"s_recommendations"> | number | null
  }

  export type s_scoresWhereInput = {
    AND?: s_scoresWhereInput | s_scoresWhereInput[]
    OR?: s_scoresWhereInput[]
    NOT?: s_scoresWhereInput | s_scoresWhereInput[]
    id?: IntFilter<"s_scores"> | number
    subjcode?: StringFilter<"s_scores"> | string
    actid?: StringFilter<"s_scores"> | string
    acttype?: IntFilter<"s_scores"> | number
    sid?: StringFilter<"s_scores"> | string
    score?: IntFilter<"s_scores"> | number
    maxscore?: IntFilter<"s_scores"> | number
    qtr?: IntFilter<"s_scores"> | number
    flag?: IntFilter<"s_scores"> | number
  }

  export type s_scoresOrderByWithRelationInput = {
    id?: SortOrder
    subjcode?: SortOrder
    actid?: SortOrder
    acttype?: SortOrder
    sid?: SortOrder
    score?: SortOrder
    maxscore?: SortOrder
    qtr?: SortOrder
    flag?: SortOrder
    _relevance?: s_scoresOrderByRelevanceInput
  }

  export type s_scoresWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: s_scoresWhereInput | s_scoresWhereInput[]
    OR?: s_scoresWhereInput[]
    NOT?: s_scoresWhereInput | s_scoresWhereInput[]
    subjcode?: StringFilter<"s_scores"> | string
    actid?: StringFilter<"s_scores"> | string
    acttype?: IntFilter<"s_scores"> | number
    sid?: StringFilter<"s_scores"> | string
    score?: IntFilter<"s_scores"> | number
    maxscore?: IntFilter<"s_scores"> | number
    qtr?: IntFilter<"s_scores"> | number
    flag?: IntFilter<"s_scores"> | number
  }, "id">

  export type s_scoresOrderByWithAggregationInput = {
    id?: SortOrder
    subjcode?: SortOrder
    actid?: SortOrder
    acttype?: SortOrder
    sid?: SortOrder
    score?: SortOrder
    maxscore?: SortOrder
    qtr?: SortOrder
    flag?: SortOrder
    _count?: s_scoresCountOrderByAggregateInput
    _avg?: s_scoresAvgOrderByAggregateInput
    _max?: s_scoresMaxOrderByAggregateInput
    _min?: s_scoresMinOrderByAggregateInput
    _sum?: s_scoresSumOrderByAggregateInput
  }

  export type s_scoresScalarWhereWithAggregatesInput = {
    AND?: s_scoresScalarWhereWithAggregatesInput | s_scoresScalarWhereWithAggregatesInput[]
    OR?: s_scoresScalarWhereWithAggregatesInput[]
    NOT?: s_scoresScalarWhereWithAggregatesInput | s_scoresScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"s_scores"> | number
    subjcode?: StringWithAggregatesFilter<"s_scores"> | string
    actid?: StringWithAggregatesFilter<"s_scores"> | string
    acttype?: IntWithAggregatesFilter<"s_scores"> | number
    sid?: StringWithAggregatesFilter<"s_scores"> | string
    score?: IntWithAggregatesFilter<"s_scores"> | number
    maxscore?: IntWithAggregatesFilter<"s_scores"> | number
    qtr?: IntWithAggregatesFilter<"s_scores"> | number
    flag?: IntWithAggregatesFilter<"s_scores"> | number
  }

  export type s_studentcvWhereInput = {
    AND?: s_studentcvWhereInput | s_studentcvWhereInput[]
    OR?: s_studentcvWhereInput[]
    NOT?: s_studentcvWhereInput | s_studentcvWhereInput[]
    id?: IntFilter<"s_studentcv"> | number
    sid?: StringFilter<"s_studentcv"> | string
    tid?: StringFilter<"s_studentcv"> | string
    subjid?: StringFilter<"s_studentcv"> | string
    qtr?: IntFilter<"s_studentcv"> | number
    independence?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    respect?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    empathy?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    appreciation?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    tolerance?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    enthusiasm?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    conduct?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
  }

  export type s_studentcvOrderByWithRelationInput = {
    id?: SortOrder
    sid?: SortOrder
    tid?: SortOrder
    subjid?: SortOrder
    qtr?: SortOrder
    independence?: SortOrder
    confidence?: SortOrder
    respect?: SortOrder
    empathy?: SortOrder
    appreciation?: SortOrder
    tolerance?: SortOrder
    enthusiasm?: SortOrder
    conduct?: SortOrder
    _relevance?: s_studentcvOrderByRelevanceInput
  }

  export type s_studentcvWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: s_studentcvWhereInput | s_studentcvWhereInput[]
    OR?: s_studentcvWhereInput[]
    NOT?: s_studentcvWhereInput | s_studentcvWhereInput[]
    sid?: StringFilter<"s_studentcv"> | string
    tid?: StringFilter<"s_studentcv"> | string
    subjid?: StringFilter<"s_studentcv"> | string
    qtr?: IntFilter<"s_studentcv"> | number
    independence?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    respect?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    empathy?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    appreciation?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    tolerance?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    enthusiasm?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    conduct?: DecimalFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
  }, "id">

  export type s_studentcvOrderByWithAggregationInput = {
    id?: SortOrder
    sid?: SortOrder
    tid?: SortOrder
    subjid?: SortOrder
    qtr?: SortOrder
    independence?: SortOrder
    confidence?: SortOrder
    respect?: SortOrder
    empathy?: SortOrder
    appreciation?: SortOrder
    tolerance?: SortOrder
    enthusiasm?: SortOrder
    conduct?: SortOrder
    _count?: s_studentcvCountOrderByAggregateInput
    _avg?: s_studentcvAvgOrderByAggregateInput
    _max?: s_studentcvMaxOrderByAggregateInput
    _min?: s_studentcvMinOrderByAggregateInput
    _sum?: s_studentcvSumOrderByAggregateInput
  }

  export type s_studentcvScalarWhereWithAggregatesInput = {
    AND?: s_studentcvScalarWhereWithAggregatesInput | s_studentcvScalarWhereWithAggregatesInput[]
    OR?: s_studentcvScalarWhereWithAggregatesInput[]
    NOT?: s_studentcvScalarWhereWithAggregatesInput | s_studentcvScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"s_studentcv"> | number
    sid?: StringWithAggregatesFilter<"s_studentcv"> | string
    tid?: StringWithAggregatesFilter<"s_studentcv"> | string
    subjid?: StringWithAggregatesFilter<"s_studentcv"> | string
    qtr?: IntWithAggregatesFilter<"s_studentcv"> | number
    independence?: DecimalWithAggregatesFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalWithAggregatesFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    respect?: DecimalWithAggregatesFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    empathy?: DecimalWithAggregatesFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    appreciation?: DecimalWithAggregatesFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    tolerance?: DecimalWithAggregatesFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    enthusiasm?: DecimalWithAggregatesFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
    conduct?: DecimalWithAggregatesFilter<"s_studentcv"> | Decimal | DecimalJsLike | number | string
  }

  export type s_subjectsWhereInput = {
    AND?: s_subjectsWhereInput | s_subjectsWhereInput[]
    OR?: s_subjectsWhereInput[]
    NOT?: s_subjectsWhereInput | s_subjectsWhereInput[]
    id?: IntFilter<"s_subjects"> | number
    code?: StringFilter<"s_subjects"> | string
    tid?: StringFilter<"s_subjects"> | string
    subjdesc?: StringFilter<"s_subjects"> | string
    subjlevel?: StringFilter<"s_subjects"> | string
    subjsection?: StringFilter<"s_subjects"> | string
    assignedby?: StringFilter<"s_subjects"> | string
    assigndate?: DateTimeFilter<"s_subjects"> | Date | string
    percentww?: FloatFilter<"s_subjects"> | number
    percentpt?: FloatFilter<"s_subjects"> | number
    percentqt?: FloatFilter<"s_subjects"> | number
  }

  export type s_subjectsOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    tid?: SortOrder
    subjdesc?: SortOrder
    subjlevel?: SortOrder
    subjsection?: SortOrder
    assignedby?: SortOrder
    assigndate?: SortOrder
    percentww?: SortOrder
    percentpt?: SortOrder
    percentqt?: SortOrder
    _relevance?: s_subjectsOrderByRelevanceInput
  }

  export type s_subjectsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: s_subjectsWhereInput | s_subjectsWhereInput[]
    OR?: s_subjectsWhereInput[]
    NOT?: s_subjectsWhereInput | s_subjectsWhereInput[]
    code?: StringFilter<"s_subjects"> | string
    tid?: StringFilter<"s_subjects"> | string
    subjdesc?: StringFilter<"s_subjects"> | string
    subjlevel?: StringFilter<"s_subjects"> | string
    subjsection?: StringFilter<"s_subjects"> | string
    assignedby?: StringFilter<"s_subjects"> | string
    assigndate?: DateTimeFilter<"s_subjects"> | Date | string
    percentww?: FloatFilter<"s_subjects"> | number
    percentpt?: FloatFilter<"s_subjects"> | number
    percentqt?: FloatFilter<"s_subjects"> | number
  }, "id">

  export type s_subjectsOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    tid?: SortOrder
    subjdesc?: SortOrder
    subjlevel?: SortOrder
    subjsection?: SortOrder
    assignedby?: SortOrder
    assigndate?: SortOrder
    percentww?: SortOrder
    percentpt?: SortOrder
    percentqt?: SortOrder
    _count?: s_subjectsCountOrderByAggregateInput
    _avg?: s_subjectsAvgOrderByAggregateInput
    _max?: s_subjectsMaxOrderByAggregateInput
    _min?: s_subjectsMinOrderByAggregateInput
    _sum?: s_subjectsSumOrderByAggregateInput
  }

  export type s_subjectsScalarWhereWithAggregatesInput = {
    AND?: s_subjectsScalarWhereWithAggregatesInput | s_subjectsScalarWhereWithAggregatesInput[]
    OR?: s_subjectsScalarWhereWithAggregatesInput[]
    NOT?: s_subjectsScalarWhereWithAggregatesInput | s_subjectsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"s_subjects"> | number
    code?: StringWithAggregatesFilter<"s_subjects"> | string
    tid?: StringWithAggregatesFilter<"s_subjects"> | string
    subjdesc?: StringWithAggregatesFilter<"s_subjects"> | string
    subjlevel?: StringWithAggregatesFilter<"s_subjects"> | string
    subjsection?: StringWithAggregatesFilter<"s_subjects"> | string
    assignedby?: StringWithAggregatesFilter<"s_subjects"> | string
    assigndate?: DateTimeWithAggregatesFilter<"s_subjects"> | Date | string
    percentww?: FloatWithAggregatesFilter<"s_subjects"> | number
    percentpt?: FloatWithAggregatesFilter<"s_subjects"> | number
    percentqt?: FloatWithAggregatesFilter<"s_subjects"> | number
  }

  export type s_transmuteWhereInput = {
    AND?: s_transmuteWhereInput | s_transmuteWhereInput[]
    OR?: s_transmuteWhereInput[]
    NOT?: s_transmuteWhereInput | s_transmuteWhereInput[]
    id?: IntFilter<"s_transmute"> | number
    lowerl?: FloatFilter<"s_transmute"> | number
    upperl?: FloatFilter<"s_transmute"> | number
    transmuted?: FloatFilter<"s_transmute"> | number
  }

  export type s_transmuteOrderByWithRelationInput = {
    id?: SortOrder
    lowerl?: SortOrder
    upperl?: SortOrder
    transmuted?: SortOrder
  }

  export type s_transmuteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: s_transmuteWhereInput | s_transmuteWhereInput[]
    OR?: s_transmuteWhereInput[]
    NOT?: s_transmuteWhereInput | s_transmuteWhereInput[]
    lowerl?: FloatFilter<"s_transmute"> | number
    upperl?: FloatFilter<"s_transmute"> | number
    transmuted?: FloatFilter<"s_transmute"> | number
  }, "id">

  export type s_transmuteOrderByWithAggregationInput = {
    id?: SortOrder
    lowerl?: SortOrder
    upperl?: SortOrder
    transmuted?: SortOrder
    _count?: s_transmuteCountOrderByAggregateInput
    _avg?: s_transmuteAvgOrderByAggregateInput
    _max?: s_transmuteMaxOrderByAggregateInput
    _min?: s_transmuteMinOrderByAggregateInput
    _sum?: s_transmuteSumOrderByAggregateInput
  }

  export type s_transmuteScalarWhereWithAggregatesInput = {
    AND?: s_transmuteScalarWhereWithAggregatesInput | s_transmuteScalarWhereWithAggregatesInput[]
    OR?: s_transmuteScalarWhereWithAggregatesInput[]
    NOT?: s_transmuteScalarWhereWithAggregatesInput | s_transmuteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"s_transmute"> | number
    lowerl?: FloatWithAggregatesFilter<"s_transmute"> | number
    upperl?: FloatWithAggregatesFilter<"s_transmute"> | number
    transmuted?: FloatWithAggregatesFilter<"s_transmute"> | number
  }

  export type s_verificationsWhereInput = {
    AND?: s_verificationsWhereInput | s_verificationsWhereInput[]
    OR?: s_verificationsWhereInput[]
    NOT?: s_verificationsWhereInput | s_verificationsWhereInput[]
    id?: IntFilter<"s_verifications"> | number
    user_id?: StringFilter<"s_verifications"> | string
    section?: StringFilter<"s_verifications"> | string
    grade?: IntFilter<"s_verifications"> | number
    subject?: StringNullableFilter<"s_verifications"> | string | null
    request_unlock?: IntNullableFilter<"s_verifications"> | number | null
    flag?: IntNullableFilter<"s_verifications"> | number | null
    created_at?: DateTimeFilter<"s_verifications"> | Date | string
  }

  export type s_verificationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    section?: SortOrder
    grade?: SortOrder
    subject?: SortOrderInput | SortOrder
    request_unlock?: SortOrderInput | SortOrder
    flag?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _relevance?: s_verificationsOrderByRelevanceInput
  }

  export type s_verificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: s_verificationsWhereInput | s_verificationsWhereInput[]
    OR?: s_verificationsWhereInput[]
    NOT?: s_verificationsWhereInput | s_verificationsWhereInput[]
    user_id?: StringFilter<"s_verifications"> | string
    section?: StringFilter<"s_verifications"> | string
    grade?: IntFilter<"s_verifications"> | number
    subject?: StringNullableFilter<"s_verifications"> | string | null
    request_unlock?: IntNullableFilter<"s_verifications"> | number | null
    flag?: IntNullableFilter<"s_verifications"> | number | null
    created_at?: DateTimeFilter<"s_verifications"> | Date | string
  }, "id">

  export type s_verificationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    section?: SortOrder
    grade?: SortOrder
    subject?: SortOrderInput | SortOrder
    request_unlock?: SortOrderInput | SortOrder
    flag?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: s_verificationsCountOrderByAggregateInput
    _avg?: s_verificationsAvgOrderByAggregateInput
    _max?: s_verificationsMaxOrderByAggregateInput
    _min?: s_verificationsMinOrderByAggregateInput
    _sum?: s_verificationsSumOrderByAggregateInput
  }

  export type s_verificationsScalarWhereWithAggregatesInput = {
    AND?: s_verificationsScalarWhereWithAggregatesInput | s_verificationsScalarWhereWithAggregatesInput[]
    OR?: s_verificationsScalarWhereWithAggregatesInput[]
    NOT?: s_verificationsScalarWhereWithAggregatesInput | s_verificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"s_verifications"> | number
    user_id?: StringWithAggregatesFilter<"s_verifications"> | string
    section?: StringWithAggregatesFilter<"s_verifications"> | string
    grade?: IntWithAggregatesFilter<"s_verifications"> | number
    subject?: StringNullableWithAggregatesFilter<"s_verifications"> | string | null
    request_unlock?: IntNullableWithAggregatesFilter<"s_verifications"> | number | null
    flag?: IntNullableWithAggregatesFilter<"s_verifications"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"s_verifications"> | Date | string
  }

  export type sales_historyWhereInput = {
    AND?: sales_historyWhereInput | sales_historyWhereInput[]
    OR?: sales_historyWhereInput[]
    NOT?: sales_historyWhereInput | sales_historyWhereInput[]
    sale_id?: IntFilter<"sales_history"> | number
    buyer_id?: IntNullableFilter<"sales_history"> | number | null
    product_name?: StringFilter<"sales_history"> | string
    quantity?: IntFilter<"sales_history"> | number
    sale_date?: DateTimeNullableFilter<"sales_history"> | Date | string | null
    rfid?: BigIntNullableFilter<"sales_history"> | bigint | number | null
  }

  export type sales_historyOrderByWithRelationInput = {
    sale_id?: SortOrder
    buyer_id?: SortOrderInput | SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    sale_date?: SortOrderInput | SortOrder
    rfid?: SortOrderInput | SortOrder
    _relevance?: sales_historyOrderByRelevanceInput
  }

  export type sales_historyWhereUniqueInput = Prisma.AtLeast<{
    sale_id?: number
    AND?: sales_historyWhereInput | sales_historyWhereInput[]
    OR?: sales_historyWhereInput[]
    NOT?: sales_historyWhereInput | sales_historyWhereInput[]
    buyer_id?: IntNullableFilter<"sales_history"> | number | null
    product_name?: StringFilter<"sales_history"> | string
    quantity?: IntFilter<"sales_history"> | number
    sale_date?: DateTimeNullableFilter<"sales_history"> | Date | string | null
    rfid?: BigIntNullableFilter<"sales_history"> | bigint | number | null
  }, "sale_id">

  export type sales_historyOrderByWithAggregationInput = {
    sale_id?: SortOrder
    buyer_id?: SortOrderInput | SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    sale_date?: SortOrderInput | SortOrder
    rfid?: SortOrderInput | SortOrder
    _count?: sales_historyCountOrderByAggregateInput
    _avg?: sales_historyAvgOrderByAggregateInput
    _max?: sales_historyMaxOrderByAggregateInput
    _min?: sales_historyMinOrderByAggregateInput
    _sum?: sales_historySumOrderByAggregateInput
  }

  export type sales_historyScalarWhereWithAggregatesInput = {
    AND?: sales_historyScalarWhereWithAggregatesInput | sales_historyScalarWhereWithAggregatesInput[]
    OR?: sales_historyScalarWhereWithAggregatesInput[]
    NOT?: sales_historyScalarWhereWithAggregatesInput | sales_historyScalarWhereWithAggregatesInput[]
    sale_id?: IntWithAggregatesFilter<"sales_history"> | number
    buyer_id?: IntNullableWithAggregatesFilter<"sales_history"> | number | null
    product_name?: StringWithAggregatesFilter<"sales_history"> | string
    quantity?: IntWithAggregatesFilter<"sales_history"> | number
    sale_date?: DateTimeNullableWithAggregatesFilter<"sales_history"> | Date | string | null
    rfid?: BigIntNullableWithAggregatesFilter<"sales_history"> | bigint | number | null
  }

  export type scheduleWhereInput = {
    AND?: scheduleWhereInput | scheduleWhereInput[]
    OR?: scheduleWhereInput[]
    NOT?: scheduleWhereInput | scheduleWhereInput[]
    id?: IntFilter<"schedule"> | number
    title?: StringFilter<"schedule"> | string
    start?: DateTimeFilter<"schedule"> | Date | string
    end?: DateTimeNullableFilter<"schedule"> | Date | string | null
  }

  export type scheduleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    _relevance?: scheduleOrderByRelevanceInput
  }

  export type scheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: scheduleWhereInput | scheduleWhereInput[]
    OR?: scheduleWhereInput[]
    NOT?: scheduleWhereInput | scheduleWhereInput[]
    title?: StringFilter<"schedule"> | string
    start?: DateTimeFilter<"schedule"> | Date | string
    end?: DateTimeNullableFilter<"schedule"> | Date | string | null
  }, "id">

  export type scheduleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    _count?: scheduleCountOrderByAggregateInput
    _avg?: scheduleAvgOrderByAggregateInput
    _max?: scheduleMaxOrderByAggregateInput
    _min?: scheduleMinOrderByAggregateInput
    _sum?: scheduleSumOrderByAggregateInput
  }

  export type scheduleScalarWhereWithAggregatesInput = {
    AND?: scheduleScalarWhereWithAggregatesInput | scheduleScalarWhereWithAggregatesInput[]
    OR?: scheduleScalarWhereWithAggregatesInput[]
    NOT?: scheduleScalarWhereWithAggregatesInput | scheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"schedule"> | number
    title?: StringWithAggregatesFilter<"schedule"> | string
    start?: DateTimeWithAggregatesFilter<"schedule"> | Date | string
    end?: DateTimeNullableWithAggregatesFilter<"schedule"> | Date | string | null
  }

  export type studentdetailsWhereInput = {
    AND?: studentdetailsWhereInput | studentdetailsWhereInput[]
    OR?: studentdetailsWhereInput[]
    NOT?: studentdetailsWhereInput | studentdetailsWhereInput[]
    id?: IntFilter<"studentdetails"> | number
    uniqid?: StringFilter<"studentdetails"> | string
    visa?: StringFilter<"studentdetails"> | string
    father?: StringFilter<"studentdetails"> | string
    fathermail?: StringFilter<"studentdetails"> | string
    fathernumber?: StringFilter<"studentdetails"> | string
    fatherwork?: StringFilter<"studentdetails"> | string
    fcompany?: StringFilter<"studentdetails"> | string
    fsalary?: StringFilter<"studentdetails"> | string
    mother?: StringFilter<"studentdetails"> | string
    mothermail?: StringFilter<"studentdetails"> | string
    mothernumber?: StringFilter<"studentdetails"> | string
    motherwork?: StringFilter<"studentdetails"> | string
    mcompany?: StringFilter<"studentdetails"> | string
    msalary?: StringFilter<"studentdetails"> | string
    street?: StringFilter<"studentdetails"> | string
    barangay?: StringFilter<"studentdetails"> | string
    city?: StringFilter<"studentdetails"> | string
    postal?: StringFilter<"studentdetails"> | string
    englishrw?: StringFilter<"studentdetails"> | string
    englishv?: StringFilter<"studentdetails"> | string
    languages?: StringFilter<"studentdetails"> | string
    advclasses?: StringFilter<"studentdetails"> | string
    remedial?: StringFilter<"studentdetails"> | string
    skill?: StringFilter<"studentdetails"> | string
    ashtma?: StringFilter<"studentdetails"> | string
    ashtmar?: StringFilter<"studentdetails"> | string
    allergy?: StringFilter<"studentdetails"> | string
    allergyr?: StringFilter<"studentdetails"> | string
    drug?: StringFilter<"studentdetails"> | string
    drugr?: StringFilter<"studentdetails"> | string
    speech?: StringFilter<"studentdetails"> | string
    speechr?: StringFilter<"studentdetails"> | string
    vision?: StringFilter<"studentdetails"> | string
    visionr?: StringFilter<"studentdetails"> | string
    hearing?: StringFilter<"studentdetails"> | string
    hearingr?: StringFilter<"studentdetails"> | string
    adhd?: StringFilter<"studentdetails"> | string
    adhdr?: StringFilter<"studentdetails"> | string
    healthcond?: StringFilter<"studentdetails"> | string
    hospitalization?: StringFilter<"studentdetails"> | string
    injuries?: StringFilter<"studentdetails"> | string
    medication?: StringFilter<"studentdetails"> | string
    general?: StringFilter<"studentdetails"> | string
    generaldets?: StringFilter<"studentdetails"> | string
    psych?: StringFilter<"studentdetails"> | string
    psychdets?: StringFilter<"studentdetails"> | string
    minor?: StringFilter<"studentdetails"> | string
    emergency?: StringFilter<"studentdetails"> | string
    hospital?: StringFilter<"studentdetails"> | string
    otc?: StringFilter<"studentdetails"> | string
    conforme?: StringFilter<"studentdetails"> | string
    conformedate?: StringFilter<"studentdetails"> | string
  }

  export type studentdetailsOrderByWithRelationInput = {
    id?: SortOrder
    uniqid?: SortOrder
    visa?: SortOrder
    father?: SortOrder
    fathermail?: SortOrder
    fathernumber?: SortOrder
    fatherwork?: SortOrder
    fcompany?: SortOrder
    fsalary?: SortOrder
    mother?: SortOrder
    mothermail?: SortOrder
    mothernumber?: SortOrder
    motherwork?: SortOrder
    mcompany?: SortOrder
    msalary?: SortOrder
    street?: SortOrder
    barangay?: SortOrder
    city?: SortOrder
    postal?: SortOrder
    englishrw?: SortOrder
    englishv?: SortOrder
    languages?: SortOrder
    advclasses?: SortOrder
    remedial?: SortOrder
    skill?: SortOrder
    ashtma?: SortOrder
    ashtmar?: SortOrder
    allergy?: SortOrder
    allergyr?: SortOrder
    drug?: SortOrder
    drugr?: SortOrder
    speech?: SortOrder
    speechr?: SortOrder
    vision?: SortOrder
    visionr?: SortOrder
    hearing?: SortOrder
    hearingr?: SortOrder
    adhd?: SortOrder
    adhdr?: SortOrder
    healthcond?: SortOrder
    hospitalization?: SortOrder
    injuries?: SortOrder
    medication?: SortOrder
    general?: SortOrder
    generaldets?: SortOrder
    psych?: SortOrder
    psychdets?: SortOrder
    minor?: SortOrder
    emergency?: SortOrder
    hospital?: SortOrder
    otc?: SortOrder
    conforme?: SortOrder
    conformedate?: SortOrder
    _relevance?: studentdetailsOrderByRelevanceInput
  }

  export type studentdetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: studentdetailsWhereInput | studentdetailsWhereInput[]
    OR?: studentdetailsWhereInput[]
    NOT?: studentdetailsWhereInput | studentdetailsWhereInput[]
    uniqid?: StringFilter<"studentdetails"> | string
    visa?: StringFilter<"studentdetails"> | string
    father?: StringFilter<"studentdetails"> | string
    fathermail?: StringFilter<"studentdetails"> | string
    fathernumber?: StringFilter<"studentdetails"> | string
    fatherwork?: StringFilter<"studentdetails"> | string
    fcompany?: StringFilter<"studentdetails"> | string
    fsalary?: StringFilter<"studentdetails"> | string
    mother?: StringFilter<"studentdetails"> | string
    mothermail?: StringFilter<"studentdetails"> | string
    mothernumber?: StringFilter<"studentdetails"> | string
    motherwork?: StringFilter<"studentdetails"> | string
    mcompany?: StringFilter<"studentdetails"> | string
    msalary?: StringFilter<"studentdetails"> | string
    street?: StringFilter<"studentdetails"> | string
    barangay?: StringFilter<"studentdetails"> | string
    city?: StringFilter<"studentdetails"> | string
    postal?: StringFilter<"studentdetails"> | string
    englishrw?: StringFilter<"studentdetails"> | string
    englishv?: StringFilter<"studentdetails"> | string
    languages?: StringFilter<"studentdetails"> | string
    advclasses?: StringFilter<"studentdetails"> | string
    remedial?: StringFilter<"studentdetails"> | string
    skill?: StringFilter<"studentdetails"> | string
    ashtma?: StringFilter<"studentdetails"> | string
    ashtmar?: StringFilter<"studentdetails"> | string
    allergy?: StringFilter<"studentdetails"> | string
    allergyr?: StringFilter<"studentdetails"> | string
    drug?: StringFilter<"studentdetails"> | string
    drugr?: StringFilter<"studentdetails"> | string
    speech?: StringFilter<"studentdetails"> | string
    speechr?: StringFilter<"studentdetails"> | string
    vision?: StringFilter<"studentdetails"> | string
    visionr?: StringFilter<"studentdetails"> | string
    hearing?: StringFilter<"studentdetails"> | string
    hearingr?: StringFilter<"studentdetails"> | string
    adhd?: StringFilter<"studentdetails"> | string
    adhdr?: StringFilter<"studentdetails"> | string
    healthcond?: StringFilter<"studentdetails"> | string
    hospitalization?: StringFilter<"studentdetails"> | string
    injuries?: StringFilter<"studentdetails"> | string
    medication?: StringFilter<"studentdetails"> | string
    general?: StringFilter<"studentdetails"> | string
    generaldets?: StringFilter<"studentdetails"> | string
    psych?: StringFilter<"studentdetails"> | string
    psychdets?: StringFilter<"studentdetails"> | string
    minor?: StringFilter<"studentdetails"> | string
    emergency?: StringFilter<"studentdetails"> | string
    hospital?: StringFilter<"studentdetails"> | string
    otc?: StringFilter<"studentdetails"> | string
    conforme?: StringFilter<"studentdetails"> | string
    conformedate?: StringFilter<"studentdetails"> | string
  }, "id">

  export type studentdetailsOrderByWithAggregationInput = {
    id?: SortOrder
    uniqid?: SortOrder
    visa?: SortOrder
    father?: SortOrder
    fathermail?: SortOrder
    fathernumber?: SortOrder
    fatherwork?: SortOrder
    fcompany?: SortOrder
    fsalary?: SortOrder
    mother?: SortOrder
    mothermail?: SortOrder
    mothernumber?: SortOrder
    motherwork?: SortOrder
    mcompany?: SortOrder
    msalary?: SortOrder
    street?: SortOrder
    barangay?: SortOrder
    city?: SortOrder
    postal?: SortOrder
    englishrw?: SortOrder
    englishv?: SortOrder
    languages?: SortOrder
    advclasses?: SortOrder
    remedial?: SortOrder
    skill?: SortOrder
    ashtma?: SortOrder
    ashtmar?: SortOrder
    allergy?: SortOrder
    allergyr?: SortOrder
    drug?: SortOrder
    drugr?: SortOrder
    speech?: SortOrder
    speechr?: SortOrder
    vision?: SortOrder
    visionr?: SortOrder
    hearing?: SortOrder
    hearingr?: SortOrder
    adhd?: SortOrder
    adhdr?: SortOrder
    healthcond?: SortOrder
    hospitalization?: SortOrder
    injuries?: SortOrder
    medication?: SortOrder
    general?: SortOrder
    generaldets?: SortOrder
    psych?: SortOrder
    psychdets?: SortOrder
    minor?: SortOrder
    emergency?: SortOrder
    hospital?: SortOrder
    otc?: SortOrder
    conforme?: SortOrder
    conformedate?: SortOrder
    _count?: studentdetailsCountOrderByAggregateInput
    _avg?: studentdetailsAvgOrderByAggregateInput
    _max?: studentdetailsMaxOrderByAggregateInput
    _min?: studentdetailsMinOrderByAggregateInput
    _sum?: studentdetailsSumOrderByAggregateInput
  }

  export type studentdetailsScalarWhereWithAggregatesInput = {
    AND?: studentdetailsScalarWhereWithAggregatesInput | studentdetailsScalarWhereWithAggregatesInput[]
    OR?: studentdetailsScalarWhereWithAggregatesInput[]
    NOT?: studentdetailsScalarWhereWithAggregatesInput | studentdetailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"studentdetails"> | number
    uniqid?: StringWithAggregatesFilter<"studentdetails"> | string
    visa?: StringWithAggregatesFilter<"studentdetails"> | string
    father?: StringWithAggregatesFilter<"studentdetails"> | string
    fathermail?: StringWithAggregatesFilter<"studentdetails"> | string
    fathernumber?: StringWithAggregatesFilter<"studentdetails"> | string
    fatherwork?: StringWithAggregatesFilter<"studentdetails"> | string
    fcompany?: StringWithAggregatesFilter<"studentdetails"> | string
    fsalary?: StringWithAggregatesFilter<"studentdetails"> | string
    mother?: StringWithAggregatesFilter<"studentdetails"> | string
    mothermail?: StringWithAggregatesFilter<"studentdetails"> | string
    mothernumber?: StringWithAggregatesFilter<"studentdetails"> | string
    motherwork?: StringWithAggregatesFilter<"studentdetails"> | string
    mcompany?: StringWithAggregatesFilter<"studentdetails"> | string
    msalary?: StringWithAggregatesFilter<"studentdetails"> | string
    street?: StringWithAggregatesFilter<"studentdetails"> | string
    barangay?: StringWithAggregatesFilter<"studentdetails"> | string
    city?: StringWithAggregatesFilter<"studentdetails"> | string
    postal?: StringWithAggregatesFilter<"studentdetails"> | string
    englishrw?: StringWithAggregatesFilter<"studentdetails"> | string
    englishv?: StringWithAggregatesFilter<"studentdetails"> | string
    languages?: StringWithAggregatesFilter<"studentdetails"> | string
    advclasses?: StringWithAggregatesFilter<"studentdetails"> | string
    remedial?: StringWithAggregatesFilter<"studentdetails"> | string
    skill?: StringWithAggregatesFilter<"studentdetails"> | string
    ashtma?: StringWithAggregatesFilter<"studentdetails"> | string
    ashtmar?: StringWithAggregatesFilter<"studentdetails"> | string
    allergy?: StringWithAggregatesFilter<"studentdetails"> | string
    allergyr?: StringWithAggregatesFilter<"studentdetails"> | string
    drug?: StringWithAggregatesFilter<"studentdetails"> | string
    drugr?: StringWithAggregatesFilter<"studentdetails"> | string
    speech?: StringWithAggregatesFilter<"studentdetails"> | string
    speechr?: StringWithAggregatesFilter<"studentdetails"> | string
    vision?: StringWithAggregatesFilter<"studentdetails"> | string
    visionr?: StringWithAggregatesFilter<"studentdetails"> | string
    hearing?: StringWithAggregatesFilter<"studentdetails"> | string
    hearingr?: StringWithAggregatesFilter<"studentdetails"> | string
    adhd?: StringWithAggregatesFilter<"studentdetails"> | string
    adhdr?: StringWithAggregatesFilter<"studentdetails"> | string
    healthcond?: StringWithAggregatesFilter<"studentdetails"> | string
    hospitalization?: StringWithAggregatesFilter<"studentdetails"> | string
    injuries?: StringWithAggregatesFilter<"studentdetails"> | string
    medication?: StringWithAggregatesFilter<"studentdetails"> | string
    general?: StringWithAggregatesFilter<"studentdetails"> | string
    generaldets?: StringWithAggregatesFilter<"studentdetails"> | string
    psych?: StringWithAggregatesFilter<"studentdetails"> | string
    psychdets?: StringWithAggregatesFilter<"studentdetails"> | string
    minor?: StringWithAggregatesFilter<"studentdetails"> | string
    emergency?: StringWithAggregatesFilter<"studentdetails"> | string
    hospital?: StringWithAggregatesFilter<"studentdetails"> | string
    otc?: StringWithAggregatesFilter<"studentdetails"> | string
    conforme?: StringWithAggregatesFilter<"studentdetails"> | string
    conformedate?: StringWithAggregatesFilter<"studentdetails"> | string
  }

  export type timeoffWhereInput = {
    AND?: timeoffWhereInput | timeoffWhereInput[]
    OR?: timeoffWhereInput[]
    NOT?: timeoffWhereInput | timeoffWhereInput[]
    id?: IntFilter<"timeoff"> | number
    rfid?: BigIntFilter<"timeoff"> | bigint | number
    leavetype?: StringFilter<"timeoff"> | string
    datefrom?: DateTimeFilter<"timeoff"> | Date | string
    dateto?: DateTimeFilter<"timeoff"> | Date | string
    ishalfday?: IntFilter<"timeoff"> | number
    details?: StringFilter<"timeoff"> | string
    credit?: IntFilter<"timeoff"> | number
    approval?: StringFilter<"timeoff"> | string
    approvedate?: DateTimeFilter<"timeoff"> | Date | string
    hrnote?: StringFilter<"timeoff"> | string
    hrdate?: DateTimeFilter<"timeoff"> | Date | string
  }

  export type timeoffOrderByWithRelationInput = {
    id?: SortOrder
    rfid?: SortOrder
    leavetype?: SortOrder
    datefrom?: SortOrder
    dateto?: SortOrder
    ishalfday?: SortOrder
    details?: SortOrder
    credit?: SortOrder
    approval?: SortOrder
    approvedate?: SortOrder
    hrnote?: SortOrder
    hrdate?: SortOrder
    _relevance?: timeoffOrderByRelevanceInput
  }

  export type timeoffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: timeoffWhereInput | timeoffWhereInput[]
    OR?: timeoffWhereInput[]
    NOT?: timeoffWhereInput | timeoffWhereInput[]
    rfid?: BigIntFilter<"timeoff"> | bigint | number
    leavetype?: StringFilter<"timeoff"> | string
    datefrom?: DateTimeFilter<"timeoff"> | Date | string
    dateto?: DateTimeFilter<"timeoff"> | Date | string
    ishalfday?: IntFilter<"timeoff"> | number
    details?: StringFilter<"timeoff"> | string
    credit?: IntFilter<"timeoff"> | number
    approval?: StringFilter<"timeoff"> | string
    approvedate?: DateTimeFilter<"timeoff"> | Date | string
    hrnote?: StringFilter<"timeoff"> | string
    hrdate?: DateTimeFilter<"timeoff"> | Date | string
  }, "id">

  export type timeoffOrderByWithAggregationInput = {
    id?: SortOrder
    rfid?: SortOrder
    leavetype?: SortOrder
    datefrom?: SortOrder
    dateto?: SortOrder
    ishalfday?: SortOrder
    details?: SortOrder
    credit?: SortOrder
    approval?: SortOrder
    approvedate?: SortOrder
    hrnote?: SortOrder
    hrdate?: SortOrder
    _count?: timeoffCountOrderByAggregateInput
    _avg?: timeoffAvgOrderByAggregateInput
    _max?: timeoffMaxOrderByAggregateInput
    _min?: timeoffMinOrderByAggregateInput
    _sum?: timeoffSumOrderByAggregateInput
  }

  export type timeoffScalarWhereWithAggregatesInput = {
    AND?: timeoffScalarWhereWithAggregatesInput | timeoffScalarWhereWithAggregatesInput[]
    OR?: timeoffScalarWhereWithAggregatesInput[]
    NOT?: timeoffScalarWhereWithAggregatesInput | timeoffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"timeoff"> | number
    rfid?: BigIntWithAggregatesFilter<"timeoff"> | bigint | number
    leavetype?: StringWithAggregatesFilter<"timeoff"> | string
    datefrom?: DateTimeWithAggregatesFilter<"timeoff"> | Date | string
    dateto?: DateTimeWithAggregatesFilter<"timeoff"> | Date | string
    ishalfday?: IntWithAggregatesFilter<"timeoff"> | number
    details?: StringWithAggregatesFilter<"timeoff"> | string
    credit?: IntWithAggregatesFilter<"timeoff"> | number
    approval?: StringWithAggregatesFilter<"timeoff"> | string
    approvedate?: DateTimeWithAggregatesFilter<"timeoff"> | Date | string
    hrnote?: StringWithAggregatesFilter<"timeoff"> | string
    hrdate?: DateTimeWithAggregatesFilter<"timeoff"> | Date | string
  }

  export type type_of_productsWhereInput = {
    AND?: type_of_productsWhereInput | type_of_productsWhereInput[]
    OR?: type_of_productsWhereInput[]
    NOT?: type_of_productsWhereInput | type_of_productsWhereInput[]
    id?: IntFilter<"type_of_products"> | number
    name?: StringFilter<"type_of_products"> | string
  }

  export type type_of_productsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    _relevance?: type_of_productsOrderByRelevanceInput
  }

  export type type_of_productsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: type_of_productsWhereInput | type_of_productsWhereInput[]
    OR?: type_of_productsWhereInput[]
    NOT?: type_of_productsWhereInput | type_of_productsWhereInput[]
    name?: StringFilter<"type_of_products"> | string
  }, "id">

  export type type_of_productsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: type_of_productsCountOrderByAggregateInput
    _avg?: type_of_productsAvgOrderByAggregateInput
    _max?: type_of_productsMaxOrderByAggregateInput
    _min?: type_of_productsMinOrderByAggregateInput
    _sum?: type_of_productsSumOrderByAggregateInput
  }

  export type type_of_productsScalarWhereWithAggregatesInput = {
    AND?: type_of_productsScalarWhereWithAggregatesInput | type_of_productsScalarWhereWithAggregatesInput[]
    OR?: type_of_productsScalarWhereWithAggregatesInput[]
    NOT?: type_of_productsScalarWhereWithAggregatesInput | type_of_productsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"type_of_products"> | number
    name?: StringWithAggregatesFilter<"type_of_products"> | string
  }

  export type uniformWhereInput = {
    AND?: uniformWhereInput | uniformWhereInput[]
    OR?: uniformWhereInput[]
    NOT?: uniformWhereInput | uniformWhereInput[]
    id?: IntFilter<"uniform"> | number
    rfid?: StringFilter<"uniform"> | string
    size?: StringFilter<"uniform"> | string
    basic?: StringNullableFilter<"uniform"> | string | null
    activity?: StringNullableFilter<"uniform"> | string | null
    formal?: StringNullableFilter<"uniform"> | string | null
    qtybasic?: StringFilter<"uniform"> | string
    qtyact?: StringFilter<"uniform"> | string
    qtyform?: StringFilter<"uniform"> | string
    iscomplete?: IntFilter<"uniform"> | number
    lasttouch?: StringFilter<"uniform"> | string
    dateordered?: StringNullableFilter<"uniform"> | string | null
    datereleased?: StringNullableFilter<"uniform"> | string | null
    comment?: StringFilter<"uniform"> | string
  }

  export type uniformOrderByWithRelationInput = {
    id?: SortOrder
    rfid?: SortOrder
    size?: SortOrder
    basic?: SortOrderInput | SortOrder
    activity?: SortOrderInput | SortOrder
    formal?: SortOrderInput | SortOrder
    qtybasic?: SortOrder
    qtyact?: SortOrder
    qtyform?: SortOrder
    iscomplete?: SortOrder
    lasttouch?: SortOrder
    dateordered?: SortOrderInput | SortOrder
    datereleased?: SortOrderInput | SortOrder
    comment?: SortOrder
    _relevance?: uniformOrderByRelevanceInput
  }

  export type uniformWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: uniformWhereInput | uniformWhereInput[]
    OR?: uniformWhereInput[]
    NOT?: uniformWhereInput | uniformWhereInput[]
    rfid?: StringFilter<"uniform"> | string
    size?: StringFilter<"uniform"> | string
    basic?: StringNullableFilter<"uniform"> | string | null
    activity?: StringNullableFilter<"uniform"> | string | null
    formal?: StringNullableFilter<"uniform"> | string | null
    qtybasic?: StringFilter<"uniform"> | string
    qtyact?: StringFilter<"uniform"> | string
    qtyform?: StringFilter<"uniform"> | string
    iscomplete?: IntFilter<"uniform"> | number
    lasttouch?: StringFilter<"uniform"> | string
    dateordered?: StringNullableFilter<"uniform"> | string | null
    datereleased?: StringNullableFilter<"uniform"> | string | null
    comment?: StringFilter<"uniform"> | string
  }, "id">

  export type uniformOrderByWithAggregationInput = {
    id?: SortOrder
    rfid?: SortOrder
    size?: SortOrder
    basic?: SortOrderInput | SortOrder
    activity?: SortOrderInput | SortOrder
    formal?: SortOrderInput | SortOrder
    qtybasic?: SortOrder
    qtyact?: SortOrder
    qtyform?: SortOrder
    iscomplete?: SortOrder
    lasttouch?: SortOrder
    dateordered?: SortOrderInput | SortOrder
    datereleased?: SortOrderInput | SortOrder
    comment?: SortOrder
    _count?: uniformCountOrderByAggregateInput
    _avg?: uniformAvgOrderByAggregateInput
    _max?: uniformMaxOrderByAggregateInput
    _min?: uniformMinOrderByAggregateInput
    _sum?: uniformSumOrderByAggregateInput
  }

  export type uniformScalarWhereWithAggregatesInput = {
    AND?: uniformScalarWhereWithAggregatesInput | uniformScalarWhereWithAggregatesInput[]
    OR?: uniformScalarWhereWithAggregatesInput[]
    NOT?: uniformScalarWhereWithAggregatesInput | uniformScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"uniform"> | number
    rfid?: StringWithAggregatesFilter<"uniform"> | string
    size?: StringWithAggregatesFilter<"uniform"> | string
    basic?: StringNullableWithAggregatesFilter<"uniform"> | string | null
    activity?: StringNullableWithAggregatesFilter<"uniform"> | string | null
    formal?: StringNullableWithAggregatesFilter<"uniform"> | string | null
    qtybasic?: StringWithAggregatesFilter<"uniform"> | string
    qtyact?: StringWithAggregatesFilter<"uniform"> | string
    qtyform?: StringWithAggregatesFilter<"uniform"> | string
    iscomplete?: IntWithAggregatesFilter<"uniform"> | number
    lasttouch?: StringWithAggregatesFilter<"uniform"> | string
    dateordered?: StringNullableWithAggregatesFilter<"uniform"> | string | null
    datereleased?: StringNullableWithAggregatesFilter<"uniform"> | string | null
    comment?: StringWithAggregatesFilter<"uniform"> | string
  }

  export type uniform_inventoryWhereInput = {
    AND?: uniform_inventoryWhereInput | uniform_inventoryWhereInput[]
    OR?: uniform_inventoryWhereInput[]
    NOT?: uniform_inventoryWhereInput | uniform_inventoryWhereInput[]
    id?: IntFilter<"uniform_inventory"> | number
    uniform_type_id?: StringFilter<"uniform_inventory"> | string
    uniform_size_id?: StringFilter<"uniform_inventory"> | string
    qty?: IntFilter<"uniform_inventory"> | number
    gender?: StringFilter<"uniform_inventory"> | string
    date?: DateTimeFilter<"uniform_inventory"> | Date | string
    user?: StringFilter<"uniform_inventory"> | string
  }

  export type uniform_inventoryOrderByWithRelationInput = {
    id?: SortOrder
    uniform_type_id?: SortOrder
    uniform_size_id?: SortOrder
    qty?: SortOrder
    gender?: SortOrder
    date?: SortOrder
    user?: SortOrder
    _relevance?: uniform_inventoryOrderByRelevanceInput
  }

  export type uniform_inventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: uniform_inventoryWhereInput | uniform_inventoryWhereInput[]
    OR?: uniform_inventoryWhereInput[]
    NOT?: uniform_inventoryWhereInput | uniform_inventoryWhereInput[]
    uniform_type_id?: StringFilter<"uniform_inventory"> | string
    uniform_size_id?: StringFilter<"uniform_inventory"> | string
    qty?: IntFilter<"uniform_inventory"> | number
    gender?: StringFilter<"uniform_inventory"> | string
    date?: DateTimeFilter<"uniform_inventory"> | Date | string
    user?: StringFilter<"uniform_inventory"> | string
  }, "id">

  export type uniform_inventoryOrderByWithAggregationInput = {
    id?: SortOrder
    uniform_type_id?: SortOrder
    uniform_size_id?: SortOrder
    qty?: SortOrder
    gender?: SortOrder
    date?: SortOrder
    user?: SortOrder
    _count?: uniform_inventoryCountOrderByAggregateInput
    _avg?: uniform_inventoryAvgOrderByAggregateInput
    _max?: uniform_inventoryMaxOrderByAggregateInput
    _min?: uniform_inventoryMinOrderByAggregateInput
    _sum?: uniform_inventorySumOrderByAggregateInput
  }

  export type uniform_inventoryScalarWhereWithAggregatesInput = {
    AND?: uniform_inventoryScalarWhereWithAggregatesInput | uniform_inventoryScalarWhereWithAggregatesInput[]
    OR?: uniform_inventoryScalarWhereWithAggregatesInput[]
    NOT?: uniform_inventoryScalarWhereWithAggregatesInput | uniform_inventoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"uniform_inventory"> | number
    uniform_type_id?: StringWithAggregatesFilter<"uniform_inventory"> | string
    uniform_size_id?: StringWithAggregatesFilter<"uniform_inventory"> | string
    qty?: IntWithAggregatesFilter<"uniform_inventory"> | number
    gender?: StringWithAggregatesFilter<"uniform_inventory"> | string
    date?: DateTimeWithAggregatesFilter<"uniform_inventory"> | Date | string
    user?: StringWithAggregatesFilter<"uniform_inventory"> | string
  }

  export type uniform_issuedWhereInput = {
    AND?: uniform_issuedWhereInput | uniform_issuedWhereInput[]
    OR?: uniform_issuedWhereInput[]
    NOT?: uniform_issuedWhereInput | uniform_issuedWhereInput[]
    id?: IntFilter<"uniform_issued"> | number
    rfid?: StringFilter<"uniform_issued"> | string
    releasedby?: StringFilter<"uniform_issued"> | string
    uniform_type_id?: StringFilter<"uniform_issued"> | string
    uniform_size_id?: StringFilter<"uniform_issued"> | string
    date?: DateTimeFilter<"uniform_issued"> | Date | string
  }

  export type uniform_issuedOrderByWithRelationInput = {
    id?: SortOrder
    rfid?: SortOrder
    releasedby?: SortOrder
    uniform_type_id?: SortOrder
    uniform_size_id?: SortOrder
    date?: SortOrder
    _relevance?: uniform_issuedOrderByRelevanceInput
  }

  export type uniform_issuedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: uniform_issuedWhereInput | uniform_issuedWhereInput[]
    OR?: uniform_issuedWhereInput[]
    NOT?: uniform_issuedWhereInput | uniform_issuedWhereInput[]
    rfid?: StringFilter<"uniform_issued"> | string
    releasedby?: StringFilter<"uniform_issued"> | string
    uniform_type_id?: StringFilter<"uniform_issued"> | string
    uniform_size_id?: StringFilter<"uniform_issued"> | string
    date?: DateTimeFilter<"uniform_issued"> | Date | string
  }, "id">

  export type uniform_issuedOrderByWithAggregationInput = {
    id?: SortOrder
    rfid?: SortOrder
    releasedby?: SortOrder
    uniform_type_id?: SortOrder
    uniform_size_id?: SortOrder
    date?: SortOrder
    _count?: uniform_issuedCountOrderByAggregateInput
    _avg?: uniform_issuedAvgOrderByAggregateInput
    _max?: uniform_issuedMaxOrderByAggregateInput
    _min?: uniform_issuedMinOrderByAggregateInput
    _sum?: uniform_issuedSumOrderByAggregateInput
  }

  export type uniform_issuedScalarWhereWithAggregatesInput = {
    AND?: uniform_issuedScalarWhereWithAggregatesInput | uniform_issuedScalarWhereWithAggregatesInput[]
    OR?: uniform_issuedScalarWhereWithAggregatesInput[]
    NOT?: uniform_issuedScalarWhereWithAggregatesInput | uniform_issuedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"uniform_issued"> | number
    rfid?: StringWithAggregatesFilter<"uniform_issued"> | string
    releasedby?: StringWithAggregatesFilter<"uniform_issued"> | string
    uniform_type_id?: StringWithAggregatesFilter<"uniform_issued"> | string
    uniform_size_id?: StringWithAggregatesFilter<"uniform_issued"> | string
    date?: DateTimeWithAggregatesFilter<"uniform_issued"> | Date | string
  }

  export type uniform_sizesWhereInput = {
    AND?: uniform_sizesWhereInput | uniform_sizesWhereInput[]
    OR?: uniform_sizesWhereInput[]
    NOT?: uniform_sizesWhereInput | uniform_sizesWhereInput[]
    id?: IntFilter<"uniform_sizes"> | number
    size?: StringFilter<"uniform_sizes"> | string
    created_at?: DateTimeNullableFilter<"uniform_sizes"> | Date | string | null
  }

  export type uniform_sizesOrderByWithRelationInput = {
    id?: SortOrder
    size?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _relevance?: uniform_sizesOrderByRelevanceInput
  }

  export type uniform_sizesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: uniform_sizesWhereInput | uniform_sizesWhereInput[]
    OR?: uniform_sizesWhereInput[]
    NOT?: uniform_sizesWhereInput | uniform_sizesWhereInput[]
    size?: StringFilter<"uniform_sizes"> | string
    created_at?: DateTimeNullableFilter<"uniform_sizes"> | Date | string | null
  }, "id">

  export type uniform_sizesOrderByWithAggregationInput = {
    id?: SortOrder
    size?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: uniform_sizesCountOrderByAggregateInput
    _avg?: uniform_sizesAvgOrderByAggregateInput
    _max?: uniform_sizesMaxOrderByAggregateInput
    _min?: uniform_sizesMinOrderByAggregateInput
    _sum?: uniform_sizesSumOrderByAggregateInput
  }

  export type uniform_sizesScalarWhereWithAggregatesInput = {
    AND?: uniform_sizesScalarWhereWithAggregatesInput | uniform_sizesScalarWhereWithAggregatesInput[]
    OR?: uniform_sizesScalarWhereWithAggregatesInput[]
    NOT?: uniform_sizesScalarWhereWithAggregatesInput | uniform_sizesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"uniform_sizes"> | number
    size?: StringWithAggregatesFilter<"uniform_sizes"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"uniform_sizes"> | Date | string | null
  }

  export type uniform_typesWhereInput = {
    AND?: uniform_typesWhereInput | uniform_typesWhereInput[]
    OR?: uniform_typesWhereInput[]
    NOT?: uniform_typesWhereInput | uniform_typesWhereInput[]
    id?: IntFilter<"uniform_types"> | number
    type?: StringFilter<"uniform_types"> | string
    created_at?: DateTimeNullableFilter<"uniform_types"> | Date | string | null
  }

  export type uniform_typesOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _relevance?: uniform_typesOrderByRelevanceInput
  }

  export type uniform_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: uniform_typesWhereInput | uniform_typesWhereInput[]
    OR?: uniform_typesWhereInput[]
    NOT?: uniform_typesWhereInput | uniform_typesWhereInput[]
    type?: StringFilter<"uniform_types"> | string
    created_at?: DateTimeNullableFilter<"uniform_types"> | Date | string | null
  }, "id">

  export type uniform_typesOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: uniform_typesCountOrderByAggregateInput
    _avg?: uniform_typesAvgOrderByAggregateInput
    _max?: uniform_typesMaxOrderByAggregateInput
    _min?: uniform_typesMinOrderByAggregateInput
    _sum?: uniform_typesSumOrderByAggregateInput
  }

  export type uniform_typesScalarWhereWithAggregatesInput = {
    AND?: uniform_typesScalarWhereWithAggregatesInput | uniform_typesScalarWhereWithAggregatesInput[]
    OR?: uniform_typesScalarWhereWithAggregatesInput[]
    NOT?: uniform_typesScalarWhereWithAggregatesInput | uniform_typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"uniform_types"> | number
    type?: StringWithAggregatesFilter<"uniform_types"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"uniform_types"> | Date | string | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    rfid?: BigIntFilter<"user"> | bigint | number
    fname?: StringFilter<"user"> | string
    mname?: StringFilter<"user"> | string
    lname?: StringFilter<"user"> | string
    type?: StringFilter<"user"> | string
    gender?: StringFilter<"user"> | string
    position?: StringFilter<"user"> | string
    grade?: StringFilter<"user"> | string
    section?: StringFilter<"user"> | string
    dob?: DateTimeFilter<"user"> | Date | string
    email?: StringFilter<"user"> | string
    mobile?: StringFilter<"user"> | string
    vacchist?: StringFilter<"user"> | string
    photo?: StringFilter<"user"> | string
    manager?: StringFilter<"user"> | string
    isactive?: IntFilter<"user"> | number
    is_situation?: StringFilter<"user"> | string
    username?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    level?: IntFilter<"user"> | number
    status?: IntFilter<"user"> | number
    prevsch?: StringFilter<"user"> | string
    prevschcountry?: StringFilter<"user"> | string
    lrn?: StringFilter<"user"> | string
    uniqid?: StringFilter<"user"> | string
    tf?: StringFilter<"user"> | string
    country?: StringFilter<"user"> | string
    nationality?: StringFilter<"user"> | string
    nationalities?: StringFilter<"user"> | string
    guardianname?: StringFilter<"user"> | string
    guardianemail?: StringFilter<"user"> | string
    guardianphone?: StringFilter<"user"> | string
    referral?: StringFilter<"user"> | string
    apptype?: StringFilter<"user"> | string
    sy?: StringFilter<"user"> | string
    strand?: StringFilter<"user"> | string
    religion?: StringFilter<"user"> | string
    visa?: StringFilter<"user"> | string
    earlybird?: IntFilter<"user"> | number
    modelrelease?: IntFilter<"user"> | number
    feepolicy?: IntFilter<"user"> | number
    refund?: IntFilter<"user"> | number
    tos?: IntFilter<"user"> | number
    empno?: StringFilter<"user"> | string
    isESL?: IntFilter<"user"> | number
    house?: StringFilter<"user"> | string
    isofficial?: IntFilter<"user"> | number
    isEnrolledInAfterSchool?: BoolFilter<"user"> | boolean
    attendance?: AttendanceListRelationFilter
    enrolledactivity?: EnrolledactivityListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    type?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    is_situation?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    nationalities?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    religion?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    empno?: SortOrder
    isESL?: SortOrder
    house?: SortOrder
    isofficial?: SortOrder
    isEnrolledInAfterSchool?: SortOrder
    attendance?: attendanceOrderByRelationAggregateInput
    enrolledactivity?: enrolledactivityOrderByRelationAggregateInput
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    rfid?: BigIntFilter<"user"> | bigint | number
    fname?: StringFilter<"user"> | string
    mname?: StringFilter<"user"> | string
    lname?: StringFilter<"user"> | string
    type?: StringFilter<"user"> | string
    gender?: StringFilter<"user"> | string
    position?: StringFilter<"user"> | string
    grade?: StringFilter<"user"> | string
    section?: StringFilter<"user"> | string
    dob?: DateTimeFilter<"user"> | Date | string
    email?: StringFilter<"user"> | string
    mobile?: StringFilter<"user"> | string
    vacchist?: StringFilter<"user"> | string
    photo?: StringFilter<"user"> | string
    manager?: StringFilter<"user"> | string
    isactive?: IntFilter<"user"> | number
    is_situation?: StringFilter<"user"> | string
    username?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    level?: IntFilter<"user"> | number
    status?: IntFilter<"user"> | number
    prevsch?: StringFilter<"user"> | string
    prevschcountry?: StringFilter<"user"> | string
    lrn?: StringFilter<"user"> | string
    uniqid?: StringFilter<"user"> | string
    tf?: StringFilter<"user"> | string
    country?: StringFilter<"user"> | string
    nationality?: StringFilter<"user"> | string
    nationalities?: StringFilter<"user"> | string
    guardianname?: StringFilter<"user"> | string
    guardianemail?: StringFilter<"user"> | string
    guardianphone?: StringFilter<"user"> | string
    referral?: StringFilter<"user"> | string
    apptype?: StringFilter<"user"> | string
    sy?: StringFilter<"user"> | string
    strand?: StringFilter<"user"> | string
    religion?: StringFilter<"user"> | string
    visa?: StringFilter<"user"> | string
    earlybird?: IntFilter<"user"> | number
    modelrelease?: IntFilter<"user"> | number
    feepolicy?: IntFilter<"user"> | number
    refund?: IntFilter<"user"> | number
    tos?: IntFilter<"user"> | number
    empno?: StringFilter<"user"> | string
    isESL?: IntFilter<"user"> | number
    house?: StringFilter<"user"> | string
    isofficial?: IntFilter<"user"> | number
    isEnrolledInAfterSchool?: BoolFilter<"user"> | boolean
    attendance?: AttendanceListRelationFilter
    enrolledactivity?: EnrolledactivityListRelationFilter
  }, "id">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    type?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    is_situation?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    nationalities?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    religion?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    empno?: SortOrder
    isESL?: SortOrder
    house?: SortOrder
    isofficial?: SortOrder
    isEnrolledInAfterSchool?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    rfid?: BigIntWithAggregatesFilter<"user"> | bigint | number
    fname?: StringWithAggregatesFilter<"user"> | string
    mname?: StringWithAggregatesFilter<"user"> | string
    lname?: StringWithAggregatesFilter<"user"> | string
    type?: StringWithAggregatesFilter<"user"> | string
    gender?: StringWithAggregatesFilter<"user"> | string
    position?: StringWithAggregatesFilter<"user"> | string
    grade?: StringWithAggregatesFilter<"user"> | string
    section?: StringWithAggregatesFilter<"user"> | string
    dob?: DateTimeWithAggregatesFilter<"user"> | Date | string
    email?: StringWithAggregatesFilter<"user"> | string
    mobile?: StringWithAggregatesFilter<"user"> | string
    vacchist?: StringWithAggregatesFilter<"user"> | string
    photo?: StringWithAggregatesFilter<"user"> | string
    manager?: StringWithAggregatesFilter<"user"> | string
    isactive?: IntWithAggregatesFilter<"user"> | number
    is_situation?: StringWithAggregatesFilter<"user"> | string
    username?: StringWithAggregatesFilter<"user"> | string
    password?: StringWithAggregatesFilter<"user"> | string
    level?: IntWithAggregatesFilter<"user"> | number
    status?: IntWithAggregatesFilter<"user"> | number
    prevsch?: StringWithAggregatesFilter<"user"> | string
    prevschcountry?: StringWithAggregatesFilter<"user"> | string
    lrn?: StringWithAggregatesFilter<"user"> | string
    uniqid?: StringWithAggregatesFilter<"user"> | string
    tf?: StringWithAggregatesFilter<"user"> | string
    country?: StringWithAggregatesFilter<"user"> | string
    nationality?: StringWithAggregatesFilter<"user"> | string
    nationalities?: StringWithAggregatesFilter<"user"> | string
    guardianname?: StringWithAggregatesFilter<"user"> | string
    guardianemail?: StringWithAggregatesFilter<"user"> | string
    guardianphone?: StringWithAggregatesFilter<"user"> | string
    referral?: StringWithAggregatesFilter<"user"> | string
    apptype?: StringWithAggregatesFilter<"user"> | string
    sy?: StringWithAggregatesFilter<"user"> | string
    strand?: StringWithAggregatesFilter<"user"> | string
    religion?: StringWithAggregatesFilter<"user"> | string
    visa?: StringWithAggregatesFilter<"user"> | string
    earlybird?: IntWithAggregatesFilter<"user"> | number
    modelrelease?: IntWithAggregatesFilter<"user"> | number
    feepolicy?: IntWithAggregatesFilter<"user"> | number
    refund?: IntWithAggregatesFilter<"user"> | number
    tos?: IntWithAggregatesFilter<"user"> | number
    empno?: StringWithAggregatesFilter<"user"> | string
    isESL?: IntWithAggregatesFilter<"user"> | number
    house?: StringWithAggregatesFilter<"user"> | string
    isofficial?: IntWithAggregatesFilter<"user"> | number
    isEnrolledInAfterSchool?: BoolWithAggregatesFilter<"user"> | boolean
  }

  export type user22WhereInput = {
    AND?: user22WhereInput | user22WhereInput[]
    OR?: user22WhereInput[]
    NOT?: user22WhereInput | user22WhereInput[]
    id?: IntFilter<"user22"> | number
    rfid?: BigIntFilter<"user22"> | bigint | number
    fname?: StringFilter<"user22"> | string
    mname?: StringFilter<"user22"> | string
    lname?: StringFilter<"user22"> | string
    gender?: StringFilter<"user22"> | string
    position?: StringFilter<"user22"> | string
    grade?: StringFilter<"user22"> | string
    section?: StringFilter<"user22"> | string
    dob?: DateTimeFilter<"user22"> | Date | string
    email?: StringFilter<"user22"> | string
    mobile?: StringFilter<"user22"> | string
    vacchist?: StringFilter<"user22"> | string
    photo?: StringFilter<"user22"> | string
    manager?: StringFilter<"user22"> | string
    isactive?: IntFilter<"user22"> | number
    username?: StringFilter<"user22"> | string
    password?: StringFilter<"user22"> | string
    level?: IntFilter<"user22"> | number
    status?: IntFilter<"user22"> | number
    prevsch?: StringFilter<"user22"> | string
    prevschcountry?: StringFilter<"user22"> | string
    lrn?: StringFilter<"user22"> | string
    uniqid?: StringFilter<"user22"> | string
    tf?: StringFilter<"user22"> | string
    country?: StringFilter<"user22"> | string
    nationality?: StringFilter<"user22"> | string
    guardianname?: StringFilter<"user22"> | string
    guardianemail?: StringFilter<"user22"> | string
    guardianphone?: StringFilter<"user22"> | string
    referral?: StringFilter<"user22"> | string
    apptype?: StringFilter<"user22"> | string
    sy?: StringFilter<"user22"> | string
    strand?: StringFilter<"user22"> | string
    visa?: StringFilter<"user22"> | string
    earlybird?: IntFilter<"user22"> | number
    modelrelease?: IntFilter<"user22"> | number
    feepolicy?: IntFilter<"user22"> | number
    refund?: IntFilter<"user22"> | number
    tos?: IntFilter<"user22"> | number
  }

  export type user22OrderByWithRelationInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    _relevance?: user22OrderByRelevanceInput
  }

  export type user22WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: user22WhereInput | user22WhereInput[]
    OR?: user22WhereInput[]
    NOT?: user22WhereInput | user22WhereInput[]
    rfid?: BigIntFilter<"user22"> | bigint | number
    fname?: StringFilter<"user22"> | string
    mname?: StringFilter<"user22"> | string
    lname?: StringFilter<"user22"> | string
    gender?: StringFilter<"user22"> | string
    position?: StringFilter<"user22"> | string
    grade?: StringFilter<"user22"> | string
    section?: StringFilter<"user22"> | string
    dob?: DateTimeFilter<"user22"> | Date | string
    email?: StringFilter<"user22"> | string
    mobile?: StringFilter<"user22"> | string
    vacchist?: StringFilter<"user22"> | string
    photo?: StringFilter<"user22"> | string
    manager?: StringFilter<"user22"> | string
    isactive?: IntFilter<"user22"> | number
    username?: StringFilter<"user22"> | string
    password?: StringFilter<"user22"> | string
    level?: IntFilter<"user22"> | number
    status?: IntFilter<"user22"> | number
    prevsch?: StringFilter<"user22"> | string
    prevschcountry?: StringFilter<"user22"> | string
    lrn?: StringFilter<"user22"> | string
    uniqid?: StringFilter<"user22"> | string
    tf?: StringFilter<"user22"> | string
    country?: StringFilter<"user22"> | string
    nationality?: StringFilter<"user22"> | string
    guardianname?: StringFilter<"user22"> | string
    guardianemail?: StringFilter<"user22"> | string
    guardianphone?: StringFilter<"user22"> | string
    referral?: StringFilter<"user22"> | string
    apptype?: StringFilter<"user22"> | string
    sy?: StringFilter<"user22"> | string
    strand?: StringFilter<"user22"> | string
    visa?: StringFilter<"user22"> | string
    earlybird?: IntFilter<"user22"> | number
    modelrelease?: IntFilter<"user22"> | number
    feepolicy?: IntFilter<"user22"> | number
    refund?: IntFilter<"user22"> | number
    tos?: IntFilter<"user22"> | number
  }, "id">

  export type user22OrderByWithAggregationInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    _count?: user22CountOrderByAggregateInput
    _avg?: user22AvgOrderByAggregateInput
    _max?: user22MaxOrderByAggregateInput
    _min?: user22MinOrderByAggregateInput
    _sum?: user22SumOrderByAggregateInput
  }

  export type user22ScalarWhereWithAggregatesInput = {
    AND?: user22ScalarWhereWithAggregatesInput | user22ScalarWhereWithAggregatesInput[]
    OR?: user22ScalarWhereWithAggregatesInput[]
    NOT?: user22ScalarWhereWithAggregatesInput | user22ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user22"> | number
    rfid?: BigIntWithAggregatesFilter<"user22"> | bigint | number
    fname?: StringWithAggregatesFilter<"user22"> | string
    mname?: StringWithAggregatesFilter<"user22"> | string
    lname?: StringWithAggregatesFilter<"user22"> | string
    gender?: StringWithAggregatesFilter<"user22"> | string
    position?: StringWithAggregatesFilter<"user22"> | string
    grade?: StringWithAggregatesFilter<"user22"> | string
    section?: StringWithAggregatesFilter<"user22"> | string
    dob?: DateTimeWithAggregatesFilter<"user22"> | Date | string
    email?: StringWithAggregatesFilter<"user22"> | string
    mobile?: StringWithAggregatesFilter<"user22"> | string
    vacchist?: StringWithAggregatesFilter<"user22"> | string
    photo?: StringWithAggregatesFilter<"user22"> | string
    manager?: StringWithAggregatesFilter<"user22"> | string
    isactive?: IntWithAggregatesFilter<"user22"> | number
    username?: StringWithAggregatesFilter<"user22"> | string
    password?: StringWithAggregatesFilter<"user22"> | string
    level?: IntWithAggregatesFilter<"user22"> | number
    status?: IntWithAggregatesFilter<"user22"> | number
    prevsch?: StringWithAggregatesFilter<"user22"> | string
    prevschcountry?: StringWithAggregatesFilter<"user22"> | string
    lrn?: StringWithAggregatesFilter<"user22"> | string
    uniqid?: StringWithAggregatesFilter<"user22"> | string
    tf?: StringWithAggregatesFilter<"user22"> | string
    country?: StringWithAggregatesFilter<"user22"> | string
    nationality?: StringWithAggregatesFilter<"user22"> | string
    guardianname?: StringWithAggregatesFilter<"user22"> | string
    guardianemail?: StringWithAggregatesFilter<"user22"> | string
    guardianphone?: StringWithAggregatesFilter<"user22"> | string
    referral?: StringWithAggregatesFilter<"user22"> | string
    apptype?: StringWithAggregatesFilter<"user22"> | string
    sy?: StringWithAggregatesFilter<"user22"> | string
    strand?: StringWithAggregatesFilter<"user22"> | string
    visa?: StringWithAggregatesFilter<"user22"> | string
    earlybird?: IntWithAggregatesFilter<"user22"> | number
    modelrelease?: IntWithAggregatesFilter<"user22"> | number
    feepolicy?: IntWithAggregatesFilter<"user22"> | number
    refund?: IntWithAggregatesFilter<"user22"> | number
    tos?: IntWithAggregatesFilter<"user22"> | number
  }

  export type users24WhereInput = {
    AND?: users24WhereInput | users24WhereInput[]
    OR?: users24WhereInput[]
    NOT?: users24WhereInput | users24WhereInput[]
    id?: IntFilter<"users24"> | number
    rfid?: BigIntFilter<"users24"> | bigint | number
    fname?: StringFilter<"users24"> | string
    mname?: StringFilter<"users24"> | string
    lname?: StringFilter<"users24"> | string
    type?: StringFilter<"users24"> | string
    gender?: StringFilter<"users24"> | string
    position?: StringFilter<"users24"> | string
    grade?: StringFilter<"users24"> | string
    section?: StringFilter<"users24"> | string
    dob?: DateTimeFilter<"users24"> | Date | string
    email?: StringFilter<"users24"> | string
    mobile?: StringFilter<"users24"> | string
    vacchist?: StringFilter<"users24"> | string
    photo?: StringFilter<"users24"> | string
    manager?: StringFilter<"users24"> | string
    isactive?: IntFilter<"users24"> | number
    is_situation?: StringFilter<"users24"> | string
    username?: StringFilter<"users24"> | string
    password?: StringFilter<"users24"> | string
    level?: IntFilter<"users24"> | number
    status?: IntFilter<"users24"> | number
    prevsch?: StringFilter<"users24"> | string
    prevschcountry?: StringFilter<"users24"> | string
    lrn?: StringFilter<"users24"> | string
    uniqid?: StringFilter<"users24"> | string
    tf?: StringFilter<"users24"> | string
    country?: StringFilter<"users24"> | string
    nationality?: StringFilter<"users24"> | string
    nationalities?: StringFilter<"users24"> | string
    religion?: StringFilter<"users24"> | string
    guardianname?: StringFilter<"users24"> | string
    guardianemail?: StringFilter<"users24"> | string
    guardianphone?: StringFilter<"users24"> | string
    referral?: StringFilter<"users24"> | string
    apptype?: StringFilter<"users24"> | string
    sy?: StringFilter<"users24"> | string
    strand?: StringFilter<"users24"> | string
    visa?: StringFilter<"users24"> | string
    earlybird?: IntFilter<"users24"> | number
    modelrelease?: IntFilter<"users24"> | number
    feepolicy?: IntFilter<"users24"> | number
    refund?: IntFilter<"users24"> | number
    tos?: IntFilter<"users24"> | number
    empno?: StringFilter<"users24"> | string
    isESL?: IntFilter<"users24"> | number
    house?: StringFilter<"users24"> | string
    isofficial?: IntFilter<"users24"> | number
  }

  export type users24OrderByWithRelationInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    type?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    is_situation?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    nationalities?: SortOrder
    religion?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    empno?: SortOrder
    isESL?: SortOrder
    house?: SortOrder
    isofficial?: SortOrder
    _relevance?: users24OrderByRelevanceInput
  }

  export type users24WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: users24WhereInput | users24WhereInput[]
    OR?: users24WhereInput[]
    NOT?: users24WhereInput | users24WhereInput[]
    rfid?: BigIntFilter<"users24"> | bigint | number
    fname?: StringFilter<"users24"> | string
    mname?: StringFilter<"users24"> | string
    lname?: StringFilter<"users24"> | string
    type?: StringFilter<"users24"> | string
    gender?: StringFilter<"users24"> | string
    position?: StringFilter<"users24"> | string
    grade?: StringFilter<"users24"> | string
    section?: StringFilter<"users24"> | string
    dob?: DateTimeFilter<"users24"> | Date | string
    email?: StringFilter<"users24"> | string
    mobile?: StringFilter<"users24"> | string
    vacchist?: StringFilter<"users24"> | string
    photo?: StringFilter<"users24"> | string
    manager?: StringFilter<"users24"> | string
    isactive?: IntFilter<"users24"> | number
    is_situation?: StringFilter<"users24"> | string
    username?: StringFilter<"users24"> | string
    password?: StringFilter<"users24"> | string
    level?: IntFilter<"users24"> | number
    status?: IntFilter<"users24"> | number
    prevsch?: StringFilter<"users24"> | string
    prevschcountry?: StringFilter<"users24"> | string
    lrn?: StringFilter<"users24"> | string
    uniqid?: StringFilter<"users24"> | string
    tf?: StringFilter<"users24"> | string
    country?: StringFilter<"users24"> | string
    nationality?: StringFilter<"users24"> | string
    nationalities?: StringFilter<"users24"> | string
    religion?: StringFilter<"users24"> | string
    guardianname?: StringFilter<"users24"> | string
    guardianemail?: StringFilter<"users24"> | string
    guardianphone?: StringFilter<"users24"> | string
    referral?: StringFilter<"users24"> | string
    apptype?: StringFilter<"users24"> | string
    sy?: StringFilter<"users24"> | string
    strand?: StringFilter<"users24"> | string
    visa?: StringFilter<"users24"> | string
    earlybird?: IntFilter<"users24"> | number
    modelrelease?: IntFilter<"users24"> | number
    feepolicy?: IntFilter<"users24"> | number
    refund?: IntFilter<"users24"> | number
    tos?: IntFilter<"users24"> | number
    empno?: StringFilter<"users24"> | string
    isESL?: IntFilter<"users24"> | number
    house?: StringFilter<"users24"> | string
    isofficial?: IntFilter<"users24"> | number
  }, "id">

  export type users24OrderByWithAggregationInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    type?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    is_situation?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    nationalities?: SortOrder
    religion?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    empno?: SortOrder
    isESL?: SortOrder
    house?: SortOrder
    isofficial?: SortOrder
    _count?: users24CountOrderByAggregateInput
    _avg?: users24AvgOrderByAggregateInput
    _max?: users24MaxOrderByAggregateInput
    _min?: users24MinOrderByAggregateInput
    _sum?: users24SumOrderByAggregateInput
  }

  export type users24ScalarWhereWithAggregatesInput = {
    AND?: users24ScalarWhereWithAggregatesInput | users24ScalarWhereWithAggregatesInput[]
    OR?: users24ScalarWhereWithAggregatesInput[]
    NOT?: users24ScalarWhereWithAggregatesInput | users24ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users24"> | number
    rfid?: BigIntWithAggregatesFilter<"users24"> | bigint | number
    fname?: StringWithAggregatesFilter<"users24"> | string
    mname?: StringWithAggregatesFilter<"users24"> | string
    lname?: StringWithAggregatesFilter<"users24"> | string
    type?: StringWithAggregatesFilter<"users24"> | string
    gender?: StringWithAggregatesFilter<"users24"> | string
    position?: StringWithAggregatesFilter<"users24"> | string
    grade?: StringWithAggregatesFilter<"users24"> | string
    section?: StringWithAggregatesFilter<"users24"> | string
    dob?: DateTimeWithAggregatesFilter<"users24"> | Date | string
    email?: StringWithAggregatesFilter<"users24"> | string
    mobile?: StringWithAggregatesFilter<"users24"> | string
    vacchist?: StringWithAggregatesFilter<"users24"> | string
    photo?: StringWithAggregatesFilter<"users24"> | string
    manager?: StringWithAggregatesFilter<"users24"> | string
    isactive?: IntWithAggregatesFilter<"users24"> | number
    is_situation?: StringWithAggregatesFilter<"users24"> | string
    username?: StringWithAggregatesFilter<"users24"> | string
    password?: StringWithAggregatesFilter<"users24"> | string
    level?: IntWithAggregatesFilter<"users24"> | number
    status?: IntWithAggregatesFilter<"users24"> | number
    prevsch?: StringWithAggregatesFilter<"users24"> | string
    prevschcountry?: StringWithAggregatesFilter<"users24"> | string
    lrn?: StringWithAggregatesFilter<"users24"> | string
    uniqid?: StringWithAggregatesFilter<"users24"> | string
    tf?: StringWithAggregatesFilter<"users24"> | string
    country?: StringWithAggregatesFilter<"users24"> | string
    nationality?: StringWithAggregatesFilter<"users24"> | string
    nationalities?: StringWithAggregatesFilter<"users24"> | string
    religion?: StringWithAggregatesFilter<"users24"> | string
    guardianname?: StringWithAggregatesFilter<"users24"> | string
    guardianemail?: StringWithAggregatesFilter<"users24"> | string
    guardianphone?: StringWithAggregatesFilter<"users24"> | string
    referral?: StringWithAggregatesFilter<"users24"> | string
    apptype?: StringWithAggregatesFilter<"users24"> | string
    sy?: StringWithAggregatesFilter<"users24"> | string
    strand?: StringWithAggregatesFilter<"users24"> | string
    visa?: StringWithAggregatesFilter<"users24"> | string
    earlybird?: IntWithAggregatesFilter<"users24"> | number
    modelrelease?: IntWithAggregatesFilter<"users24"> | number
    feepolicy?: IntWithAggregatesFilter<"users24"> | number
    refund?: IntWithAggregatesFilter<"users24"> | number
    tos?: IntWithAggregatesFilter<"users24"> | number
    empno?: StringWithAggregatesFilter<"users24"> | string
    isESL?: IntWithAggregatesFilter<"users24"> | number
    house?: StringWithAggregatesFilter<"users24"> | string
    isofficial?: IntWithAggregatesFilter<"users24"> | number
  }

  export type visitorlogWhereInput = {
    AND?: visitorlogWhereInput | visitorlogWhereInput[]
    OR?: visitorlogWhereInput[]
    NOT?: visitorlogWhereInput | visitorlogWhereInput[]
    id?: IntFilter<"visitorlog"> | number
    name?: StringFilter<"visitorlog"> | string
    rfid?: StringFilter<"visitorlog"> | string
    comment?: StringFilter<"visitorlog"> | string
    registerdate?: DateTimeFilter<"visitorlog"> | Date | string
    status?: IntFilter<"visitorlog"> | number
  }

  export type visitorlogOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    rfid?: SortOrder
    comment?: SortOrder
    registerdate?: SortOrder
    status?: SortOrder
    _relevance?: visitorlogOrderByRelevanceInput
  }

  export type visitorlogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: visitorlogWhereInput | visitorlogWhereInput[]
    OR?: visitorlogWhereInput[]
    NOT?: visitorlogWhereInput | visitorlogWhereInput[]
    name?: StringFilter<"visitorlog"> | string
    rfid?: StringFilter<"visitorlog"> | string
    comment?: StringFilter<"visitorlog"> | string
    registerdate?: DateTimeFilter<"visitorlog"> | Date | string
    status?: IntFilter<"visitorlog"> | number
  }, "id">

  export type visitorlogOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    rfid?: SortOrder
    comment?: SortOrder
    registerdate?: SortOrder
    status?: SortOrder
    _count?: visitorlogCountOrderByAggregateInput
    _avg?: visitorlogAvgOrderByAggregateInput
    _max?: visitorlogMaxOrderByAggregateInput
    _min?: visitorlogMinOrderByAggregateInput
    _sum?: visitorlogSumOrderByAggregateInput
  }

  export type visitorlogScalarWhereWithAggregatesInput = {
    AND?: visitorlogScalarWhereWithAggregatesInput | visitorlogScalarWhereWithAggregatesInput[]
    OR?: visitorlogScalarWhereWithAggregatesInput[]
    NOT?: visitorlogScalarWhereWithAggregatesInput | visitorlogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"visitorlog"> | number
    name?: StringWithAggregatesFilter<"visitorlog"> | string
    rfid?: StringWithAggregatesFilter<"visitorlog"> | string
    comment?: StringWithAggregatesFilter<"visitorlog"> | string
    registerdate?: DateTimeWithAggregatesFilter<"visitorlog"> | Date | string
    status?: IntWithAggregatesFilter<"visitorlog"> | number
  }

  export type wispayWhereInput = {
    AND?: wispayWhereInput | wispayWhereInput[]
    OR?: wispayWhereInput[]
    NOT?: wispayWhereInput | wispayWhereInput[]
    id?: IntFilter<"wispay"> | number
    debit?: DecimalFilter<"wispay"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"wispay"> | Decimal | DecimalJsLike | number | string
    rfid?: BigIntFilter<"wispay"> | bigint | number
    empid?: StringFilter<"wispay"> | string
    username?: StringFilter<"wispay"> | string
    refcode?: StringFilter<"wispay"> | string
    transdate?: DateTimeFilter<"wispay"> | Date | string
    processedby?: StringFilter<"wispay"> | string
    product_type?: StringFilter<"wispay"> | string
    product_name?: StringFilter<"wispay"> | string
    quantity?: FloatFilter<"wispay"> | number
    isAfterSchoolPayment?: BoolFilter<"wispay"> | boolean
  }

  export type wispayOrderByWithRelationInput = {
    id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    rfid?: SortOrder
    empid?: SortOrder
    username?: SortOrder
    refcode?: SortOrder
    transdate?: SortOrder
    processedby?: SortOrder
    product_type?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    isAfterSchoolPayment?: SortOrder
    _relevance?: wispayOrderByRelevanceInput
  }

  export type wispayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: wispayWhereInput | wispayWhereInput[]
    OR?: wispayWhereInput[]
    NOT?: wispayWhereInput | wispayWhereInput[]
    debit?: DecimalFilter<"wispay"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"wispay"> | Decimal | DecimalJsLike | number | string
    rfid?: BigIntFilter<"wispay"> | bigint | number
    empid?: StringFilter<"wispay"> | string
    username?: StringFilter<"wispay"> | string
    refcode?: StringFilter<"wispay"> | string
    transdate?: DateTimeFilter<"wispay"> | Date | string
    processedby?: StringFilter<"wispay"> | string
    product_type?: StringFilter<"wispay"> | string
    product_name?: StringFilter<"wispay"> | string
    quantity?: FloatFilter<"wispay"> | number
    isAfterSchoolPayment?: BoolFilter<"wispay"> | boolean
  }, "id">

  export type wispayOrderByWithAggregationInput = {
    id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    rfid?: SortOrder
    empid?: SortOrder
    username?: SortOrder
    refcode?: SortOrder
    transdate?: SortOrder
    processedby?: SortOrder
    product_type?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    isAfterSchoolPayment?: SortOrder
    _count?: wispayCountOrderByAggregateInput
    _avg?: wispayAvgOrderByAggregateInput
    _max?: wispayMaxOrderByAggregateInput
    _min?: wispayMinOrderByAggregateInput
    _sum?: wispaySumOrderByAggregateInput
  }

  export type wispayScalarWhereWithAggregatesInput = {
    AND?: wispayScalarWhereWithAggregatesInput | wispayScalarWhereWithAggregatesInput[]
    OR?: wispayScalarWhereWithAggregatesInput[]
    NOT?: wispayScalarWhereWithAggregatesInput | wispayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"wispay"> | number
    debit?: DecimalWithAggregatesFilter<"wispay"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalWithAggregatesFilter<"wispay"> | Decimal | DecimalJsLike | number | string
    rfid?: BigIntWithAggregatesFilter<"wispay"> | bigint | number
    empid?: StringWithAggregatesFilter<"wispay"> | string
    username?: StringWithAggregatesFilter<"wispay"> | string
    refcode?: StringWithAggregatesFilter<"wispay"> | string
    transdate?: DateTimeWithAggregatesFilter<"wispay"> | Date | string
    processedby?: StringWithAggregatesFilter<"wispay"> | string
    product_type?: StringWithAggregatesFilter<"wispay"> | string
    product_name?: StringWithAggregatesFilter<"wispay"> | string
    quantity?: FloatWithAggregatesFilter<"wispay"> | number
    isAfterSchoolPayment?: BoolWithAggregatesFilter<"wispay"> | boolean
  }

  export type activitysessionCreateInput = {
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    afterschoolactivity: afterschoolactivityCreateNestedOneWithoutActivitysessionInput
    attendance?: attendanceCreateNestedManyWithoutActivitysessionInput
  }

  export type activitysessionUncheckedCreateInput = {
    id?: number
    activityId: number
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    attendance?: attendanceUncheckedCreateNestedManyWithoutActivitysessionInput
  }

  export type activitysessionUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    afterschoolactivity?: afterschoolactivityUpdateOneRequiredWithoutActivitysessionNestedInput
    attendance?: attendanceUpdateManyWithoutActivitysessionNestedInput
  }

  export type activitysessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: attendanceUncheckedUpdateManyWithoutActivitysessionNestedInput
  }

  export type activitysessionCreateManyInput = {
    id?: number
    activityId: number
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type activitysessionUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activitysessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type afterschoolactivityCreateInput = {
    name: string
    description?: string | null
    dayOfWeek: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coachName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    photo?: string | null
    activitysession?: activitysessionCreateNestedManyWithoutAfterschoolactivityInput
    enrolledactivity?: enrolledactivityCreateNestedManyWithoutAfterschoolactivityInput
  }

  export type afterschoolactivityUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    dayOfWeek: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coachName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    photo?: string | null
    activitysession?: activitysessionUncheckedCreateNestedManyWithoutAfterschoolactivityInput
    enrolledactivity?: enrolledactivityUncheckedCreateNestedManyWithoutAfterschoolactivityInput
  }

  export type afterschoolactivityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coachName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    activitysession?: activitysessionUpdateManyWithoutAfterschoolactivityNestedInput
    enrolledactivity?: enrolledactivityUpdateManyWithoutAfterschoolactivityNestedInput
  }

  export type afterschoolactivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coachName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    activitysession?: activitysessionUncheckedUpdateManyWithoutAfterschoolactivityNestedInput
    enrolledactivity?: enrolledactivityUncheckedUpdateManyWithoutAfterschoolactivityNestedInput
  }

  export type afterschoolactivityCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    dayOfWeek: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coachName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    photo?: string | null
  }

  export type afterschoolactivityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coachName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type afterschoolactivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coachName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type attendanceCreateInput = {
    status: string
    activitysession: activitysessionCreateNestedOneWithoutAttendanceInput
    user: userCreateNestedOneWithoutAttendanceInput
  }

  export type attendanceUncheckedCreateInput = {
    id?: number
    sessionId: number
    userId: number
    status: string
  }

  export type attendanceUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    activitysession?: activitysessionUpdateOneRequiredWithoutAttendanceNestedInput
    user?: userUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type attendanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type attendanceCreateManyInput = {
    id?: number
    sessionId: number
    userId: number
    status: string
  }

  export type attendanceUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type attendanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type attendance_libraryCreateInput = {
    name?: string | null
    date?: Date | string | null
    rfid?: string | null
  }

  export type attendance_libraryUncheckedCreateInput = {
    id?: number
    name?: string | null
    date?: Date | string | null
    rfid?: string | null
  }

  export type attendance_libraryUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type attendance_libraryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type attendance_libraryCreateManyInput = {
    id?: number
    name?: string | null
    date?: Date | string | null
    rfid?: string | null
  }

  export type attendance_libraryUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type attendance_libraryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type borrowersCreateInput = {
    name?: string | null
    rfid?: string | null
    title?: string | null
    date_borrowed?: Date | string | null
    date_returned?: Date | string | null
    remarks?: string | null
  }

  export type borrowersUncheckedCreateInput = {
    id?: number
    name?: string | null
    rfid?: string | null
    title?: string | null
    date_borrowed?: Date | string | null
    date_returned?: Date | string | null
    remarks?: string | null
  }

  export type borrowersUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    rfid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date_borrowed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_returned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type borrowersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    rfid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date_borrowed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_returned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type borrowersCreateManyInput = {
    id?: number
    name?: string | null
    rfid?: string | null
    title?: string | null
    date_borrowed?: Date | string | null
    date_returned?: Date | string | null
    remarks?: string | null
  }

  export type borrowersUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    rfid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date_borrowed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_returned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type borrowersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    rfid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date_borrowed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_returned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type buyersCreateInput = {
    buyer_name: string
    rfid?: bigint | number | null
  }

  export type buyersUncheckedCreateInput = {
    buyer_id?: number
    buyer_name: string
    rfid?: bigint | number | null
  }

  export type buyersUpdateInput = {
    buyer_name?: StringFieldUpdateOperationsInput | string
    rfid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type buyersUncheckedUpdateInput = {
    buyer_id?: IntFieldUpdateOperationsInput | number
    buyer_name?: StringFieldUpdateOperationsInput | string
    rfid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type buyersCreateManyInput = {
    buyer_id?: number
    buyer_name: string
    rfid?: bigint | number | null
  }

  export type buyersUpdateManyMutationInput = {
    buyer_name?: StringFieldUpdateOperationsInput | string
    rfid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type buyersUncheckedUpdateManyInput = {
    buyer_id?: IntFieldUpdateOperationsInput | number
    buyer_name?: StringFieldUpdateOperationsInput | string
    rfid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type clinic_historyCreateInput = {
    name: string
    grade: string
    complaint: string
    diagnose: string
    treatment: string
    vital_signs: string
    time_in: Date | string
    time_out: Date | string
    date: string
    remarks: string
  }

  export type clinic_historyUncheckedCreateInput = {
    Id?: number
    name: string
    grade: string
    complaint: string
    diagnose: string
    treatment: string
    vital_signs: string
    time_in: Date | string
    time_out: Date | string
    date: string
    remarks: string
  }

  export type clinic_historyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    complaint?: StringFieldUpdateOperationsInput | string
    diagnose?: StringFieldUpdateOperationsInput | string
    treatment?: StringFieldUpdateOperationsInput | string
    vital_signs?: StringFieldUpdateOperationsInput | string
    time_in?: DateTimeFieldUpdateOperationsInput | Date | string
    time_out?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
  }

  export type clinic_historyUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    complaint?: StringFieldUpdateOperationsInput | string
    diagnose?: StringFieldUpdateOperationsInput | string
    treatment?: StringFieldUpdateOperationsInput | string
    vital_signs?: StringFieldUpdateOperationsInput | string
    time_in?: DateTimeFieldUpdateOperationsInput | Date | string
    time_out?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
  }

  export type clinic_historyCreateManyInput = {
    Id?: number
    name: string
    grade: string
    complaint: string
    diagnose: string
    treatment: string
    vital_signs: string
    time_in: Date | string
    time_out: Date | string
    date: string
    remarks: string
  }

  export type clinic_historyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    complaint?: StringFieldUpdateOperationsInput | string
    diagnose?: StringFieldUpdateOperationsInput | string
    treatment?: StringFieldUpdateOperationsInput | string
    vital_signs?: StringFieldUpdateOperationsInput | string
    time_in?: DateTimeFieldUpdateOperationsInput | Date | string
    time_out?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
  }

  export type clinic_historyUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    complaint?: StringFieldUpdateOperationsInput | string
    diagnose?: StringFieldUpdateOperationsInput | string
    treatment?: StringFieldUpdateOperationsInput | string
    vital_signs?: StringFieldUpdateOperationsInput | string
    time_in?: DateTimeFieldUpdateOperationsInput | Date | string
    time_out?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
  }

  export type countriesCreateInput = {
    countryCode?: string
    countryName?: string
    currencyCode?: string | null
    fipsCode?: string | null
    isoNumeric?: string | null
    north?: string | null
    south?: string | null
    east?: string | null
    west?: string | null
    capital?: string | null
    continentName?: string | null
    continent?: string | null
    languages?: string | null
  }

  export type countriesUncheckedCreateInput = {
    id?: number
    countryCode?: string
    countryName?: string
    currencyCode?: string | null
    fipsCode?: string | null
    isoNumeric?: string | null
    north?: string | null
    south?: string | null
    east?: string | null
    west?: string | null
    capital?: string | null
    continentName?: string | null
    continent?: string | null
    languages?: string | null
  }

  export type countriesUpdateInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
    countryName?: StringFieldUpdateOperationsInput | string
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isoNumeric?: NullableStringFieldUpdateOperationsInput | string | null
    north?: NullableStringFieldUpdateOperationsInput | string | null
    south?: NullableStringFieldUpdateOperationsInput | string | null
    east?: NullableStringFieldUpdateOperationsInput | string | null
    west?: NullableStringFieldUpdateOperationsInput | string | null
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    continentName?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type countriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    countryName?: StringFieldUpdateOperationsInput | string
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isoNumeric?: NullableStringFieldUpdateOperationsInput | string | null
    north?: NullableStringFieldUpdateOperationsInput | string | null
    south?: NullableStringFieldUpdateOperationsInput | string | null
    east?: NullableStringFieldUpdateOperationsInput | string | null
    west?: NullableStringFieldUpdateOperationsInput | string | null
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    continentName?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type countriesCreateManyInput = {
    id?: number
    countryCode?: string
    countryName?: string
    currencyCode?: string | null
    fipsCode?: string | null
    isoNumeric?: string | null
    north?: string | null
    south?: string | null
    east?: string | null
    west?: string | null
    capital?: string | null
    continentName?: string | null
    continent?: string | null
    languages?: string | null
  }

  export type countriesUpdateManyMutationInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
    countryName?: StringFieldUpdateOperationsInput | string
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isoNumeric?: NullableStringFieldUpdateOperationsInput | string | null
    north?: NullableStringFieldUpdateOperationsInput | string | null
    south?: NullableStringFieldUpdateOperationsInput | string | null
    east?: NullableStringFieldUpdateOperationsInput | string | null
    west?: NullableStringFieldUpdateOperationsInput | string | null
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    continentName?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type countriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    countryName?: StringFieldUpdateOperationsInput | string
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isoNumeric?: NullableStringFieldUpdateOperationsInput | string | null
    north?: NullableStringFieldUpdateOperationsInput | string | null
    south?: NullableStringFieldUpdateOperationsInput | string | null
    east?: NullableStringFieldUpdateOperationsInput | string | null
    west?: NullableStringFieldUpdateOperationsInput | string | null
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    continentName?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type enrolledactivityCreateInput = {
    enrollmentDate?: Date | string
    afterschoolactivity: afterschoolactivityCreateNestedOneWithoutEnrolledactivityInput
    user: userCreateNestedOneWithoutEnrolledactivityInput
  }

  export type enrolledactivityUncheckedCreateInput = {
    id?: number
    userId: number
    activityId: number
    enrollmentDate?: Date | string
  }

  export type enrolledactivityUpdateInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    afterschoolactivity?: afterschoolactivityUpdateOneRequiredWithoutEnrolledactivityNestedInput
    user?: userUpdateOneRequiredWithoutEnrolledactivityNestedInput
  }

  export type enrolledactivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type enrolledactivityCreateManyInput = {
    id?: number
    userId: number
    activityId: number
    enrollmentDate?: Date | string
  }

  export type enrolledactivityUpdateManyMutationInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type enrolledactivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventoryCreateInput = {
    empno: string
    description: string
    serial: string
    dateout: Date | string
    datein: Date | string
    issuedby: string
    remarks: string
  }

  export type inventoryUncheckedCreateInput = {
    id?: number
    empno: string
    description: string
    serial: string
    dateout: Date | string
    datein: Date | string
    issuedby: string
    remarks: string
  }

  export type inventoryUpdateInput = {
    empno?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    dateout?: DateTimeFieldUpdateOperationsInput | Date | string
    datein?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedby?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
  }

  export type inventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    dateout?: DateTimeFieldUpdateOperationsInput | Date | string
    datein?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedby?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
  }

  export type inventoryCreateManyInput = {
    id?: number
    empno: string
    description: string
    serial: string
    dateout: Date | string
    datein: Date | string
    issuedby: string
    remarks: string
  }

  export type inventoryUpdateManyMutationInput = {
    empno?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    dateout?: DateTimeFieldUpdateOperationsInput | Date | string
    datein?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedby?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
  }

  export type inventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    dateout?: DateTimeFieldUpdateOperationsInput | Date | string
    datein?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedby?: StringFieldUpdateOperationsInput | string
    remarks?: StringFieldUpdateOperationsInput | string
  }

  export type inventory__suppliersCreateInput = {
    companyName: string
    itemsProvided?: string | null
    address?: string | null
    phoneNumber?: string | null
    email?: string | null
    rating?: Decimal | DecimalJsLike | number | string | null
  }

  export type inventory__suppliersUncheckedCreateInput = {
    id?: number
    companyName: string
    itemsProvided?: string | null
    address?: string | null
    phoneNumber?: string | null
    email?: string | null
    rating?: Decimal | DecimalJsLike | number | string | null
  }

  export type inventory__suppliersUpdateInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    itemsProvided?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type inventory__suppliersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    itemsProvided?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type inventory__suppliersCreateManyInput = {
    id?: number
    companyName: string
    itemsProvided?: string | null
    address?: string | null
    phoneNumber?: string | null
    email?: string | null
    rating?: Decimal | DecimalJsLike | number | string | null
  }

  export type inventory__suppliersUpdateManyMutationInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    itemsProvided?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type inventory__suppliersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    itemsProvided?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type inventory_bookstoreCreateInput = {
    product_name: string
    quantity: number
    selling_price: number
    date: Date | string
  }

  export type inventory_bookstoreUncheckedCreateInput = {
    id?: number
    product_name: string
    quantity: number
    selling_price: number
    date: Date | string
  }

  export type inventory_bookstoreUpdateInput = {
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    selling_price?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventory_bookstoreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    selling_price?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventory_bookstoreCreateManyInput = {
    id?: number
    product_name: string
    quantity: number
    selling_price: number
    date: Date | string
  }

  export type inventory_bookstoreUpdateManyMutationInput = {
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    selling_price?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventory_bookstoreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    selling_price?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type library_loginCreateInput = {
    username?: string | null
    password?: string | null
  }

  export type library_loginUncheckedCreateInput = {
    id?: number
    username?: string | null
    password?: string | null
  }

  export type library_loginUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type library_loginUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type library_loginCreateManyInput = {
    id?: number
    username?: string | null
    password?: string | null
  }

  export type library_loginUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type library_loginUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type logs_enrollCreateInput = {
    ern: string
    stage: number
    usertouch: string
    touch: Date | string
    notes: string
  }

  export type logs_enrollUncheckedCreateInput = {
    id?: number
    ern: string
    stage: number
    usertouch: string
    touch: Date | string
    notes: string
  }

  export type logs_enrollUpdateInput = {
    ern?: StringFieldUpdateOperationsInput | string
    stage?: IntFieldUpdateOperationsInput | number
    usertouch?: StringFieldUpdateOperationsInput | string
    touch?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type logs_enrollUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ern?: StringFieldUpdateOperationsInput | string
    stage?: IntFieldUpdateOperationsInput | number
    usertouch?: StringFieldUpdateOperationsInput | string
    touch?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type logs_enrollCreateManyInput = {
    id?: number
    ern: string
    stage: number
    usertouch: string
    touch: Date | string
    notes: string
  }

  export type logs_enrollUpdateManyMutationInput = {
    ern?: StringFieldUpdateOperationsInput | string
    stage?: IntFieldUpdateOperationsInput | number
    usertouch?: StringFieldUpdateOperationsInput | string
    touch?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type logs_enrollUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ern?: StringFieldUpdateOperationsInput | string
    stage?: IntFieldUpdateOperationsInput | number
    usertouch?: StringFieldUpdateOperationsInput | string
    touch?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type nationalitiesCreateInput = {
    countryCode?: string
    nationalityName?: string
    currencyCode?: string | null
    fipsCode?: string | null
    isoNumeric?: string | null
    north?: string | null
    south?: string | null
    east?: string | null
    west?: string | null
    capital?: string | null
    continentName?: string | null
    continent?: string | null
  }

  export type nationalitiesUncheckedCreateInput = {
    id?: number
    countryCode?: string
    nationalityName?: string
    currencyCode?: string | null
    fipsCode?: string | null
    isoNumeric?: string | null
    north?: string | null
    south?: string | null
    east?: string | null
    west?: string | null
    capital?: string | null
    continentName?: string | null
    continent?: string | null
  }

  export type nationalitiesUpdateInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
    nationalityName?: StringFieldUpdateOperationsInput | string
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isoNumeric?: NullableStringFieldUpdateOperationsInput | string | null
    north?: NullableStringFieldUpdateOperationsInput | string | null
    south?: NullableStringFieldUpdateOperationsInput | string | null
    east?: NullableStringFieldUpdateOperationsInput | string | null
    west?: NullableStringFieldUpdateOperationsInput | string | null
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    continentName?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type nationalitiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    nationalityName?: StringFieldUpdateOperationsInput | string
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isoNumeric?: NullableStringFieldUpdateOperationsInput | string | null
    north?: NullableStringFieldUpdateOperationsInput | string | null
    south?: NullableStringFieldUpdateOperationsInput | string | null
    east?: NullableStringFieldUpdateOperationsInput | string | null
    west?: NullableStringFieldUpdateOperationsInput | string | null
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    continentName?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type nationalitiesCreateManyInput = {
    id?: number
    countryCode?: string
    nationalityName?: string
    currencyCode?: string | null
    fipsCode?: string | null
    isoNumeric?: string | null
    north?: string | null
    south?: string | null
    east?: string | null
    west?: string | null
    capital?: string | null
    continentName?: string | null
    continent?: string | null
  }

  export type nationalitiesUpdateManyMutationInput = {
    countryCode?: StringFieldUpdateOperationsInput | string
    nationalityName?: StringFieldUpdateOperationsInput | string
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isoNumeric?: NullableStringFieldUpdateOperationsInput | string | null
    north?: NullableStringFieldUpdateOperationsInput | string | null
    south?: NullableStringFieldUpdateOperationsInput | string | null
    east?: NullableStringFieldUpdateOperationsInput | string | null
    west?: NullableStringFieldUpdateOperationsInput | string | null
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    continentName?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type nationalitiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryCode?: StringFieldUpdateOperationsInput | string
    nationalityName?: StringFieldUpdateOperationsInput | string
    currencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    fipsCode?: NullableStringFieldUpdateOperationsInput | string | null
    isoNumeric?: NullableStringFieldUpdateOperationsInput | string | null
    north?: NullableStringFieldUpdateOperationsInput | string | null
    south?: NullableStringFieldUpdateOperationsInput | string | null
    east?: NullableStringFieldUpdateOperationsInput | string | null
    west?: NullableStringFieldUpdateOperationsInput | string | null
    capital?: NullableStringFieldUpdateOperationsInput | string | null
    continentName?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productsCreateInput = {
    product_code: string
    type_of_product: string
    name_of_product: string
    price_of_product: number
    date_created: Date | string
    last_touch: string
  }

  export type productsUncheckedCreateInput = {
    id?: number
    product_code: string
    type_of_product: string
    name_of_product: string
    price_of_product: number
    date_created: Date | string
    last_touch: string
  }

  export type productsUpdateInput = {
    product_code?: StringFieldUpdateOperationsInput | string
    type_of_product?: StringFieldUpdateOperationsInput | string
    name_of_product?: StringFieldUpdateOperationsInput | string
    price_of_product?: FloatFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_touch?: StringFieldUpdateOperationsInput | string
  }

  export type productsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_code?: StringFieldUpdateOperationsInput | string
    type_of_product?: StringFieldUpdateOperationsInput | string
    name_of_product?: StringFieldUpdateOperationsInput | string
    price_of_product?: FloatFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_touch?: StringFieldUpdateOperationsInput | string
  }

  export type productsCreateManyInput = {
    id?: number
    product_code: string
    type_of_product: string
    name_of_product: string
    price_of_product: number
    date_created: Date | string
    last_touch: string
  }

  export type productsUpdateManyMutationInput = {
    product_code?: StringFieldUpdateOperationsInput | string
    type_of_product?: StringFieldUpdateOperationsInput | string
    name_of_product?: StringFieldUpdateOperationsInput | string
    price_of_product?: FloatFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_touch?: StringFieldUpdateOperationsInput | string
  }

  export type productsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_code?: StringFieldUpdateOperationsInput | string
    type_of_product?: StringFieldUpdateOperationsInput | string
    name_of_product?: StringFieldUpdateOperationsInput | string
    price_of_product?: FloatFieldUpdateOperationsInput | number
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    last_touch?: StringFieldUpdateOperationsInput | string
  }

  export type requestsCreateInput = {
    rfid: bigint | number
    reqtype: string
    reqdate: Date | string
    reqneed: Date | string
    reqdetails: string
    approvedby: bigint | number
    approvedate: Date | string
    approvedfin: bigint | number
    approvedfindate: Date | string
    status: string
  }

  export type requestsUncheckedCreateInput = {
    id?: number
    rfid: bigint | number
    reqtype: string
    reqdate: Date | string
    reqneed: Date | string
    reqdetails: string
    approvedby: bigint | number
    approvedate: Date | string
    approvedfin: bigint | number
    approvedfindate: Date | string
    status: string
  }

  export type requestsUpdateInput = {
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    reqtype?: StringFieldUpdateOperationsInput | string
    reqdate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqneed?: DateTimeFieldUpdateOperationsInput | Date | string
    reqdetails?: StringFieldUpdateOperationsInput | string
    approvedby?: BigIntFieldUpdateOperationsInput | bigint | number
    approvedate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedfin?: BigIntFieldUpdateOperationsInput | bigint | number
    approvedfindate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type requestsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    reqtype?: StringFieldUpdateOperationsInput | string
    reqdate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqneed?: DateTimeFieldUpdateOperationsInput | Date | string
    reqdetails?: StringFieldUpdateOperationsInput | string
    approvedby?: BigIntFieldUpdateOperationsInput | bigint | number
    approvedate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedfin?: BigIntFieldUpdateOperationsInput | bigint | number
    approvedfindate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type requestsCreateManyInput = {
    id?: number
    rfid: bigint | number
    reqtype: string
    reqdate: Date | string
    reqneed: Date | string
    reqdetails: string
    approvedby: bigint | number
    approvedate: Date | string
    approvedfin: bigint | number
    approvedfindate: Date | string
    status: string
  }

  export type requestsUpdateManyMutationInput = {
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    reqtype?: StringFieldUpdateOperationsInput | string
    reqdate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqneed?: DateTimeFieldUpdateOperationsInput | Date | string
    reqdetails?: StringFieldUpdateOperationsInput | string
    approvedby?: BigIntFieldUpdateOperationsInput | bigint | number
    approvedate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedfin?: BigIntFieldUpdateOperationsInput | bigint | number
    approvedfindate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type requestsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    reqtype?: StringFieldUpdateOperationsInput | string
    reqdate?: DateTimeFieldUpdateOperationsInput | Date | string
    reqneed?: DateTimeFieldUpdateOperationsInput | Date | string
    reqdetails?: StringFieldUpdateOperationsInput | string
    approvedby?: BigIntFieldUpdateOperationsInput | bigint | number
    approvedate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedfin?: BigIntFieldUpdateOperationsInput | bigint | number
    approvedfindate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type s_activitiesCreateInput = {
    actid: string
    subjcode: string
    actlvl: number
    actsection: string
    actdate: Date | string
    actcreate: string
    actdesc: string
    acttype: number
    actqtr: number
    maxscore: number
    flag: number
  }

  export type s_activitiesUncheckedCreateInput = {
    id?: number
    actid: string
    subjcode: string
    actlvl: number
    actsection: string
    actdate: Date | string
    actcreate: string
    actdesc: string
    acttype: number
    actqtr: number
    maxscore: number
    flag: number
  }

  export type s_activitiesUpdateInput = {
    actid?: StringFieldUpdateOperationsInput | string
    subjcode?: StringFieldUpdateOperationsInput | string
    actlvl?: IntFieldUpdateOperationsInput | number
    actsection?: StringFieldUpdateOperationsInput | string
    actdate?: DateTimeFieldUpdateOperationsInput | Date | string
    actcreate?: StringFieldUpdateOperationsInput | string
    actdesc?: StringFieldUpdateOperationsInput | string
    acttype?: IntFieldUpdateOperationsInput | number
    actqtr?: IntFieldUpdateOperationsInput | number
    maxscore?: IntFieldUpdateOperationsInput | number
    flag?: IntFieldUpdateOperationsInput | number
  }

  export type s_activitiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    actid?: StringFieldUpdateOperationsInput | string
    subjcode?: StringFieldUpdateOperationsInput | string
    actlvl?: IntFieldUpdateOperationsInput | number
    actsection?: StringFieldUpdateOperationsInput | string
    actdate?: DateTimeFieldUpdateOperationsInput | Date | string
    actcreate?: StringFieldUpdateOperationsInput | string
    actdesc?: StringFieldUpdateOperationsInput | string
    acttype?: IntFieldUpdateOperationsInput | number
    actqtr?: IntFieldUpdateOperationsInput | number
    maxscore?: IntFieldUpdateOperationsInput | number
    flag?: IntFieldUpdateOperationsInput | number
  }

  export type s_activitiesCreateManyInput = {
    id?: number
    actid: string
    subjcode: string
    actlvl: number
    actsection: string
    actdate: Date | string
    actcreate: string
    actdesc: string
    acttype: number
    actqtr: number
    maxscore: number
    flag: number
  }

  export type s_activitiesUpdateManyMutationInput = {
    actid?: StringFieldUpdateOperationsInput | string
    subjcode?: StringFieldUpdateOperationsInput | string
    actlvl?: IntFieldUpdateOperationsInput | number
    actsection?: StringFieldUpdateOperationsInput | string
    actdate?: DateTimeFieldUpdateOperationsInput | Date | string
    actcreate?: StringFieldUpdateOperationsInput | string
    actdesc?: StringFieldUpdateOperationsInput | string
    acttype?: IntFieldUpdateOperationsInput | number
    actqtr?: IntFieldUpdateOperationsInput | number
    maxscore?: IntFieldUpdateOperationsInput | number
    flag?: IntFieldUpdateOperationsInput | number
  }

  export type s_activitiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    actid?: StringFieldUpdateOperationsInput | string
    subjcode?: StringFieldUpdateOperationsInput | string
    actlvl?: IntFieldUpdateOperationsInput | number
    actsection?: StringFieldUpdateOperationsInput | string
    actdate?: DateTimeFieldUpdateOperationsInput | Date | string
    actcreate?: StringFieldUpdateOperationsInput | string
    actdesc?: StringFieldUpdateOperationsInput | string
    acttype?: IntFieldUpdateOperationsInput | number
    actqtr?: IntFieldUpdateOperationsInput | number
    maxscore?: IntFieldUpdateOperationsInput | number
    flag?: IntFieldUpdateOperationsInput | number
  }

  export type s_classattendanceCreateInput = {
    attendance: number
    subjid: string
    studid: string
    adate: Date | string
    tid: string
    notes: string
  }

  export type s_classattendanceUncheckedCreateInput = {
    id?: number
    attendance: number
    subjid: string
    studid: string
    adate: Date | string
    tid: string
    notes: string
  }

  export type s_classattendanceUpdateInput = {
    attendance?: IntFieldUpdateOperationsInput | number
    subjid?: StringFieldUpdateOperationsInput | string
    studid?: StringFieldUpdateOperationsInput | string
    adate?: DateTimeFieldUpdateOperationsInput | Date | string
    tid?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type s_classattendanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    attendance?: IntFieldUpdateOperationsInput | number
    subjid?: StringFieldUpdateOperationsInput | string
    studid?: StringFieldUpdateOperationsInput | string
    adate?: DateTimeFieldUpdateOperationsInput | Date | string
    tid?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type s_classattendanceCreateManyInput = {
    id?: number
    attendance: number
    subjid: string
    studid: string
    adate: Date | string
    tid: string
    notes: string
  }

  export type s_classattendanceUpdateManyMutationInput = {
    attendance?: IntFieldUpdateOperationsInput | number
    subjid?: StringFieldUpdateOperationsInput | string
    studid?: StringFieldUpdateOperationsInput | string
    adate?: DateTimeFieldUpdateOperationsInput | Date | string
    tid?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type s_classattendanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    attendance?: IntFieldUpdateOperationsInput | number
    subjid?: StringFieldUpdateOperationsInput | string
    studid?: StringFieldUpdateOperationsInput | string
    adate?: DateTimeFieldUpdateOperationsInput | Date | string
    tid?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
  }

  export type s_coretableCreateInput = {
    start: Decimal | DecimalJsLike | number | string
    end: Decimal | DecimalJsLike | number | string
    grade: string
  }

  export type s_coretableUncheckedCreateInput = {
    id?: number
    start: Decimal | DecimalJsLike | number | string
    end: Decimal | DecimalJsLike | number | string
    grade: string
  }

  export type s_coretableUpdateInput = {
    start?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    end?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type s_coretableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    start?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    end?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type s_coretableCreateManyInput = {
    id?: number
    start: Decimal | DecimalJsLike | number | string
    end: Decimal | DecimalJsLike | number | string
    grade: string
  }

  export type s_coretableUpdateManyMutationInput = {
    start?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    end?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type s_coretableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    start?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    end?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type s_corevaluesCreateInput = {
    corevalue: string
  }

  export type s_corevaluesUncheckedCreateInput = {
    id?: number
    corevalue: string
  }

  export type s_corevaluesUpdateInput = {
    corevalue?: StringFieldUpdateOperationsInput | string
  }

  export type s_corevaluesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    corevalue?: StringFieldUpdateOperationsInput | string
  }

  export type s_corevaluesCreateManyInput = {
    id?: number
    corevalue: string
  }

  export type s_corevaluesUpdateManyMutationInput = {
    corevalue?: StringFieldUpdateOperationsInput | string
  }

  export type s_corevaluesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    corevalue?: StringFieldUpdateOperationsInput | string
  }

  export type s_payablesCreateInput = {
    user_id: string
    reservation_fee?: number | null
    tuition_fee?: number | null
    other_fee?: number | null
    assessment_fee?: number | null
    registration_fee?: number | null
    special_permit?: number | null
    international_fee_old?: number | null
    international_fee_new?: number | null
    pta?: number | null
  }

  export type s_payablesUncheckedCreateInput = {
    id?: number
    user_id: string
    reservation_fee?: number | null
    tuition_fee?: number | null
    other_fee?: number | null
    assessment_fee?: number | null
    registration_fee?: number | null
    special_permit?: number | null
    international_fee_old?: number | null
    international_fee_new?: number | null
    pta?: number | null
  }

  export type s_payablesUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    reservation_fee?: NullableIntFieldUpdateOperationsInput | number | null
    tuition_fee?: NullableIntFieldUpdateOperationsInput | number | null
    other_fee?: NullableIntFieldUpdateOperationsInput | number | null
    assessment_fee?: NullableIntFieldUpdateOperationsInput | number | null
    registration_fee?: NullableIntFieldUpdateOperationsInput | number | null
    special_permit?: NullableIntFieldUpdateOperationsInput | number | null
    international_fee_old?: NullableIntFieldUpdateOperationsInput | number | null
    international_fee_new?: NullableIntFieldUpdateOperationsInput | number | null
    pta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type s_payablesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    reservation_fee?: NullableIntFieldUpdateOperationsInput | number | null
    tuition_fee?: NullableIntFieldUpdateOperationsInput | number | null
    other_fee?: NullableIntFieldUpdateOperationsInput | number | null
    assessment_fee?: NullableIntFieldUpdateOperationsInput | number | null
    registration_fee?: NullableIntFieldUpdateOperationsInput | number | null
    special_permit?: NullableIntFieldUpdateOperationsInput | number | null
    international_fee_old?: NullableIntFieldUpdateOperationsInput | number | null
    international_fee_new?: NullableIntFieldUpdateOperationsInput | number | null
    pta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type s_payablesCreateManyInput = {
    id?: number
    user_id: string
    reservation_fee?: number | null
    tuition_fee?: number | null
    other_fee?: number | null
    assessment_fee?: number | null
    registration_fee?: number | null
    special_permit?: number | null
    international_fee_old?: number | null
    international_fee_new?: number | null
    pta?: number | null
  }

  export type s_payablesUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    reservation_fee?: NullableIntFieldUpdateOperationsInput | number | null
    tuition_fee?: NullableIntFieldUpdateOperationsInput | number | null
    other_fee?: NullableIntFieldUpdateOperationsInput | number | null
    assessment_fee?: NullableIntFieldUpdateOperationsInput | number | null
    registration_fee?: NullableIntFieldUpdateOperationsInput | number | null
    special_permit?: NullableIntFieldUpdateOperationsInput | number | null
    international_fee_old?: NullableIntFieldUpdateOperationsInput | number | null
    international_fee_new?: NullableIntFieldUpdateOperationsInput | number | null
    pta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type s_payablesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    reservation_fee?: NullableIntFieldUpdateOperationsInput | number | null
    tuition_fee?: NullableIntFieldUpdateOperationsInput | number | null
    other_fee?: NullableIntFieldUpdateOperationsInput | number | null
    assessment_fee?: NullableIntFieldUpdateOperationsInput | number | null
    registration_fee?: NullableIntFieldUpdateOperationsInput | number | null
    special_permit?: NullableIntFieldUpdateOperationsInput | number | null
    international_fee_old?: NullableIntFieldUpdateOperationsInput | number | null
    international_fee_new?: NullableIntFieldUpdateOperationsInput | number | null
    pta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type s_recommendationsCreateInput = {
    user_id: string
    esl?: number | null
    star?: number | null
    completion?: number | null
  }

  export type s_recommendationsUncheckedCreateInput = {
    id?: number
    user_id: string
    esl?: number | null
    star?: number | null
    completion?: number | null
  }

  export type s_recommendationsUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    esl?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    completion?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type s_recommendationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    esl?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    completion?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type s_recommendationsCreateManyInput = {
    id?: number
    user_id: string
    esl?: number | null
    star?: number | null
    completion?: number | null
  }

  export type s_recommendationsUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    esl?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    completion?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type s_recommendationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    esl?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    completion?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type s_scoresCreateInput = {
    subjcode: string
    actid: string
    acttype: number
    sid: string
    score: number
    maxscore: number
    qtr: number
    flag: number
  }

  export type s_scoresUncheckedCreateInput = {
    id?: number
    subjcode: string
    actid: string
    acttype: number
    sid: string
    score: number
    maxscore: number
    qtr: number
    flag: number
  }

  export type s_scoresUpdateInput = {
    subjcode?: StringFieldUpdateOperationsInput | string
    actid?: StringFieldUpdateOperationsInput | string
    acttype?: IntFieldUpdateOperationsInput | number
    sid?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    maxscore?: IntFieldUpdateOperationsInput | number
    qtr?: IntFieldUpdateOperationsInput | number
    flag?: IntFieldUpdateOperationsInput | number
  }

  export type s_scoresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjcode?: StringFieldUpdateOperationsInput | string
    actid?: StringFieldUpdateOperationsInput | string
    acttype?: IntFieldUpdateOperationsInput | number
    sid?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    maxscore?: IntFieldUpdateOperationsInput | number
    qtr?: IntFieldUpdateOperationsInput | number
    flag?: IntFieldUpdateOperationsInput | number
  }

  export type s_scoresCreateManyInput = {
    id?: number
    subjcode: string
    actid: string
    acttype: number
    sid: string
    score: number
    maxscore: number
    qtr: number
    flag: number
  }

  export type s_scoresUpdateManyMutationInput = {
    subjcode?: StringFieldUpdateOperationsInput | string
    actid?: StringFieldUpdateOperationsInput | string
    acttype?: IntFieldUpdateOperationsInput | number
    sid?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    maxscore?: IntFieldUpdateOperationsInput | number
    qtr?: IntFieldUpdateOperationsInput | number
    flag?: IntFieldUpdateOperationsInput | number
  }

  export type s_scoresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjcode?: StringFieldUpdateOperationsInput | string
    actid?: StringFieldUpdateOperationsInput | string
    acttype?: IntFieldUpdateOperationsInput | number
    sid?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    maxscore?: IntFieldUpdateOperationsInput | number
    qtr?: IntFieldUpdateOperationsInput | number
    flag?: IntFieldUpdateOperationsInput | number
  }

  export type s_studentcvCreateInput = {
    sid: string
    tid: string
    subjid: string
    qtr: number
    independence: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    respect: Decimal | DecimalJsLike | number | string
    empathy: Decimal | DecimalJsLike | number | string
    appreciation: Decimal | DecimalJsLike | number | string
    tolerance: Decimal | DecimalJsLike | number | string
    enthusiasm: Decimal | DecimalJsLike | number | string
    conduct: Decimal | DecimalJsLike | number | string
  }

  export type s_studentcvUncheckedCreateInput = {
    id?: number
    sid: string
    tid: string
    subjid: string
    qtr: number
    independence: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    respect: Decimal | DecimalJsLike | number | string
    empathy: Decimal | DecimalJsLike | number | string
    appreciation: Decimal | DecimalJsLike | number | string
    tolerance: Decimal | DecimalJsLike | number | string
    enthusiasm: Decimal | DecimalJsLike | number | string
    conduct: Decimal | DecimalJsLike | number | string
  }

  export type s_studentcvUpdateInput = {
    sid?: StringFieldUpdateOperationsInput | string
    tid?: StringFieldUpdateOperationsInput | string
    subjid?: StringFieldUpdateOperationsInput | string
    qtr?: IntFieldUpdateOperationsInput | number
    independence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    respect?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    empathy?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tolerance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    enthusiasm?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conduct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type s_studentcvUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sid?: StringFieldUpdateOperationsInput | string
    tid?: StringFieldUpdateOperationsInput | string
    subjid?: StringFieldUpdateOperationsInput | string
    qtr?: IntFieldUpdateOperationsInput | number
    independence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    respect?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    empathy?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tolerance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    enthusiasm?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conduct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type s_studentcvCreateManyInput = {
    id?: number
    sid: string
    tid: string
    subjid: string
    qtr: number
    independence: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    respect: Decimal | DecimalJsLike | number | string
    empathy: Decimal | DecimalJsLike | number | string
    appreciation: Decimal | DecimalJsLike | number | string
    tolerance: Decimal | DecimalJsLike | number | string
    enthusiasm: Decimal | DecimalJsLike | number | string
    conduct: Decimal | DecimalJsLike | number | string
  }

  export type s_studentcvUpdateManyMutationInput = {
    sid?: StringFieldUpdateOperationsInput | string
    tid?: StringFieldUpdateOperationsInput | string
    subjid?: StringFieldUpdateOperationsInput | string
    qtr?: IntFieldUpdateOperationsInput | number
    independence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    respect?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    empathy?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tolerance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    enthusiasm?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conduct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type s_studentcvUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sid?: StringFieldUpdateOperationsInput | string
    tid?: StringFieldUpdateOperationsInput | string
    subjid?: StringFieldUpdateOperationsInput | string
    qtr?: IntFieldUpdateOperationsInput | number
    independence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    respect?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    empathy?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tolerance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    enthusiasm?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conduct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type s_subjectsCreateInput = {
    code: string
    tid: string
    subjdesc: string
    subjlevel: string
    subjsection: string
    assignedby: string
    assigndate: Date | string
    percentww: number
    percentpt: number
    percentqt: number
  }

  export type s_subjectsUncheckedCreateInput = {
    id?: number
    code: string
    tid: string
    subjdesc: string
    subjlevel: string
    subjsection: string
    assignedby: string
    assigndate: Date | string
    percentww: number
    percentpt: number
    percentqt: number
  }

  export type s_subjectsUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    tid?: StringFieldUpdateOperationsInput | string
    subjdesc?: StringFieldUpdateOperationsInput | string
    subjlevel?: StringFieldUpdateOperationsInput | string
    subjsection?: StringFieldUpdateOperationsInput | string
    assignedby?: StringFieldUpdateOperationsInput | string
    assigndate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentww?: FloatFieldUpdateOperationsInput | number
    percentpt?: FloatFieldUpdateOperationsInput | number
    percentqt?: FloatFieldUpdateOperationsInput | number
  }

  export type s_subjectsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    tid?: StringFieldUpdateOperationsInput | string
    subjdesc?: StringFieldUpdateOperationsInput | string
    subjlevel?: StringFieldUpdateOperationsInput | string
    subjsection?: StringFieldUpdateOperationsInput | string
    assignedby?: StringFieldUpdateOperationsInput | string
    assigndate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentww?: FloatFieldUpdateOperationsInput | number
    percentpt?: FloatFieldUpdateOperationsInput | number
    percentqt?: FloatFieldUpdateOperationsInput | number
  }

  export type s_subjectsCreateManyInput = {
    id?: number
    code: string
    tid: string
    subjdesc: string
    subjlevel: string
    subjsection: string
    assignedby: string
    assigndate: Date | string
    percentww: number
    percentpt: number
    percentqt: number
  }

  export type s_subjectsUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    tid?: StringFieldUpdateOperationsInput | string
    subjdesc?: StringFieldUpdateOperationsInput | string
    subjlevel?: StringFieldUpdateOperationsInput | string
    subjsection?: StringFieldUpdateOperationsInput | string
    assignedby?: StringFieldUpdateOperationsInput | string
    assigndate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentww?: FloatFieldUpdateOperationsInput | number
    percentpt?: FloatFieldUpdateOperationsInput | number
    percentqt?: FloatFieldUpdateOperationsInput | number
  }

  export type s_subjectsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    tid?: StringFieldUpdateOperationsInput | string
    subjdesc?: StringFieldUpdateOperationsInput | string
    subjlevel?: StringFieldUpdateOperationsInput | string
    subjsection?: StringFieldUpdateOperationsInput | string
    assignedby?: StringFieldUpdateOperationsInput | string
    assigndate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentww?: FloatFieldUpdateOperationsInput | number
    percentpt?: FloatFieldUpdateOperationsInput | number
    percentqt?: FloatFieldUpdateOperationsInput | number
  }

  export type s_transmuteCreateInput = {
    lowerl: number
    upperl: number
    transmuted: number
  }

  export type s_transmuteUncheckedCreateInput = {
    id?: number
    lowerl: number
    upperl: number
    transmuted: number
  }

  export type s_transmuteUpdateInput = {
    lowerl?: FloatFieldUpdateOperationsInput | number
    upperl?: FloatFieldUpdateOperationsInput | number
    transmuted?: FloatFieldUpdateOperationsInput | number
  }

  export type s_transmuteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lowerl?: FloatFieldUpdateOperationsInput | number
    upperl?: FloatFieldUpdateOperationsInput | number
    transmuted?: FloatFieldUpdateOperationsInput | number
  }

  export type s_transmuteCreateManyInput = {
    id?: number
    lowerl: number
    upperl: number
    transmuted: number
  }

  export type s_transmuteUpdateManyMutationInput = {
    lowerl?: FloatFieldUpdateOperationsInput | number
    upperl?: FloatFieldUpdateOperationsInput | number
    transmuted?: FloatFieldUpdateOperationsInput | number
  }

  export type s_transmuteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lowerl?: FloatFieldUpdateOperationsInput | number
    upperl?: FloatFieldUpdateOperationsInput | number
    transmuted?: FloatFieldUpdateOperationsInput | number
  }

  export type s_verificationsCreateInput = {
    user_id: string
    section: string
    grade: number
    subject?: string | null
    request_unlock?: number | null
    flag?: number | null
    created_at: Date | string
  }

  export type s_verificationsUncheckedCreateInput = {
    id?: number
    user_id: string
    section: string
    grade: number
    subject?: string | null
    request_unlock?: number | null
    flag?: number | null
    created_at: Date | string
  }

  export type s_verificationsUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    request_unlock?: NullableIntFieldUpdateOperationsInput | number | null
    flag?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type s_verificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    request_unlock?: NullableIntFieldUpdateOperationsInput | number | null
    flag?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type s_verificationsCreateManyInput = {
    id?: number
    user_id: string
    section: string
    grade: number
    subject?: string | null
    request_unlock?: number | null
    flag?: number | null
    created_at: Date | string
  }

  export type s_verificationsUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    request_unlock?: NullableIntFieldUpdateOperationsInput | number | null
    flag?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type s_verificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    request_unlock?: NullableIntFieldUpdateOperationsInput | number | null
    flag?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sales_historyCreateInput = {
    buyer_id?: number | null
    product_name: string
    quantity: number
    sale_date?: Date | string | null
    rfid?: bigint | number | null
  }

  export type sales_historyUncheckedCreateInput = {
    sale_id?: number
    buyer_id?: number | null
    product_name: string
    quantity: number
    sale_date?: Date | string | null
    rfid?: bigint | number | null
  }

  export type sales_historyUpdateInput = {
    buyer_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sale_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type sales_historyUncheckedUpdateInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    buyer_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sale_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type sales_historyCreateManyInput = {
    sale_id?: number
    buyer_id?: number | null
    product_name: string
    quantity: number
    sale_date?: Date | string | null
    rfid?: bigint | number | null
  }

  export type sales_historyUpdateManyMutationInput = {
    buyer_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sale_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type sales_historyUncheckedUpdateManyInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    buyer_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sale_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rfid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type scheduleCreateInput = {
    title: string
    start: Date | string
    end?: Date | string | null
  }

  export type scheduleUncheckedCreateInput = {
    id?: number
    title: string
    start: Date | string
    end?: Date | string | null
  }

  export type scheduleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type scheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type scheduleCreateManyInput = {
    id?: number
    title: string
    start: Date | string
    end?: Date | string | null
  }

  export type scheduleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type scheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type studentdetailsCreateInput = {
    uniqid: string
    visa: string
    father: string
    fathermail: string
    fathernumber: string
    fatherwork: string
    fcompany: string
    fsalary: string
    mother: string
    mothermail: string
    mothernumber: string
    motherwork: string
    mcompany: string
    msalary: string
    street: string
    barangay: string
    city: string
    postal: string
    englishrw: string
    englishv: string
    languages: string
    advclasses: string
    remedial: string
    skill: string
    ashtma: string
    ashtmar: string
    allergy: string
    allergyr: string
    drug: string
    drugr: string
    speech: string
    speechr: string
    vision: string
    visionr: string
    hearing: string
    hearingr: string
    adhd: string
    adhdr: string
    healthcond: string
    hospitalization: string
    injuries: string
    medication: string
    general: string
    generaldets: string
    psych: string
    psychdets: string
    minor: string
    emergency: string
    hospital: string
    otc: string
    conforme: string
    conformedate: string
  }

  export type studentdetailsUncheckedCreateInput = {
    id?: number
    uniqid: string
    visa: string
    father: string
    fathermail: string
    fathernumber: string
    fatherwork: string
    fcompany: string
    fsalary: string
    mother: string
    mothermail: string
    mothernumber: string
    motherwork: string
    mcompany: string
    msalary: string
    street: string
    barangay: string
    city: string
    postal: string
    englishrw: string
    englishv: string
    languages: string
    advclasses: string
    remedial: string
    skill: string
    ashtma: string
    ashtmar: string
    allergy: string
    allergyr: string
    drug: string
    drugr: string
    speech: string
    speechr: string
    vision: string
    visionr: string
    hearing: string
    hearingr: string
    adhd: string
    adhdr: string
    healthcond: string
    hospitalization: string
    injuries: string
    medication: string
    general: string
    generaldets: string
    psych: string
    psychdets: string
    minor: string
    emergency: string
    hospital: string
    otc: string
    conforme: string
    conformedate: string
  }

  export type studentdetailsUpdateInput = {
    uniqid?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    father?: StringFieldUpdateOperationsInput | string
    fathermail?: StringFieldUpdateOperationsInput | string
    fathernumber?: StringFieldUpdateOperationsInput | string
    fatherwork?: StringFieldUpdateOperationsInput | string
    fcompany?: StringFieldUpdateOperationsInput | string
    fsalary?: StringFieldUpdateOperationsInput | string
    mother?: StringFieldUpdateOperationsInput | string
    mothermail?: StringFieldUpdateOperationsInput | string
    mothernumber?: StringFieldUpdateOperationsInput | string
    motherwork?: StringFieldUpdateOperationsInput | string
    mcompany?: StringFieldUpdateOperationsInput | string
    msalary?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    barangay?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postal?: StringFieldUpdateOperationsInput | string
    englishrw?: StringFieldUpdateOperationsInput | string
    englishv?: StringFieldUpdateOperationsInput | string
    languages?: StringFieldUpdateOperationsInput | string
    advclasses?: StringFieldUpdateOperationsInput | string
    remedial?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    ashtma?: StringFieldUpdateOperationsInput | string
    ashtmar?: StringFieldUpdateOperationsInput | string
    allergy?: StringFieldUpdateOperationsInput | string
    allergyr?: StringFieldUpdateOperationsInput | string
    drug?: StringFieldUpdateOperationsInput | string
    drugr?: StringFieldUpdateOperationsInput | string
    speech?: StringFieldUpdateOperationsInput | string
    speechr?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    visionr?: StringFieldUpdateOperationsInput | string
    hearing?: StringFieldUpdateOperationsInput | string
    hearingr?: StringFieldUpdateOperationsInput | string
    adhd?: StringFieldUpdateOperationsInput | string
    adhdr?: StringFieldUpdateOperationsInput | string
    healthcond?: StringFieldUpdateOperationsInput | string
    hospitalization?: StringFieldUpdateOperationsInput | string
    injuries?: StringFieldUpdateOperationsInput | string
    medication?: StringFieldUpdateOperationsInput | string
    general?: StringFieldUpdateOperationsInput | string
    generaldets?: StringFieldUpdateOperationsInput | string
    psych?: StringFieldUpdateOperationsInput | string
    psychdets?: StringFieldUpdateOperationsInput | string
    minor?: StringFieldUpdateOperationsInput | string
    emergency?: StringFieldUpdateOperationsInput | string
    hospital?: StringFieldUpdateOperationsInput | string
    otc?: StringFieldUpdateOperationsInput | string
    conforme?: StringFieldUpdateOperationsInput | string
    conformedate?: StringFieldUpdateOperationsInput | string
  }

  export type studentdetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uniqid?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    father?: StringFieldUpdateOperationsInput | string
    fathermail?: StringFieldUpdateOperationsInput | string
    fathernumber?: StringFieldUpdateOperationsInput | string
    fatherwork?: StringFieldUpdateOperationsInput | string
    fcompany?: StringFieldUpdateOperationsInput | string
    fsalary?: StringFieldUpdateOperationsInput | string
    mother?: StringFieldUpdateOperationsInput | string
    mothermail?: StringFieldUpdateOperationsInput | string
    mothernumber?: StringFieldUpdateOperationsInput | string
    motherwork?: StringFieldUpdateOperationsInput | string
    mcompany?: StringFieldUpdateOperationsInput | string
    msalary?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    barangay?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postal?: StringFieldUpdateOperationsInput | string
    englishrw?: StringFieldUpdateOperationsInput | string
    englishv?: StringFieldUpdateOperationsInput | string
    languages?: StringFieldUpdateOperationsInput | string
    advclasses?: StringFieldUpdateOperationsInput | string
    remedial?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    ashtma?: StringFieldUpdateOperationsInput | string
    ashtmar?: StringFieldUpdateOperationsInput | string
    allergy?: StringFieldUpdateOperationsInput | string
    allergyr?: StringFieldUpdateOperationsInput | string
    drug?: StringFieldUpdateOperationsInput | string
    drugr?: StringFieldUpdateOperationsInput | string
    speech?: StringFieldUpdateOperationsInput | string
    speechr?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    visionr?: StringFieldUpdateOperationsInput | string
    hearing?: StringFieldUpdateOperationsInput | string
    hearingr?: StringFieldUpdateOperationsInput | string
    adhd?: StringFieldUpdateOperationsInput | string
    adhdr?: StringFieldUpdateOperationsInput | string
    healthcond?: StringFieldUpdateOperationsInput | string
    hospitalization?: StringFieldUpdateOperationsInput | string
    injuries?: StringFieldUpdateOperationsInput | string
    medication?: StringFieldUpdateOperationsInput | string
    general?: StringFieldUpdateOperationsInput | string
    generaldets?: StringFieldUpdateOperationsInput | string
    psych?: StringFieldUpdateOperationsInput | string
    psychdets?: StringFieldUpdateOperationsInput | string
    minor?: StringFieldUpdateOperationsInput | string
    emergency?: StringFieldUpdateOperationsInput | string
    hospital?: StringFieldUpdateOperationsInput | string
    otc?: StringFieldUpdateOperationsInput | string
    conforme?: StringFieldUpdateOperationsInput | string
    conformedate?: StringFieldUpdateOperationsInput | string
  }

  export type studentdetailsCreateManyInput = {
    id?: number
    uniqid: string
    visa: string
    father: string
    fathermail: string
    fathernumber: string
    fatherwork: string
    fcompany: string
    fsalary: string
    mother: string
    mothermail: string
    mothernumber: string
    motherwork: string
    mcompany: string
    msalary: string
    street: string
    barangay: string
    city: string
    postal: string
    englishrw: string
    englishv: string
    languages: string
    advclasses: string
    remedial: string
    skill: string
    ashtma: string
    ashtmar: string
    allergy: string
    allergyr: string
    drug: string
    drugr: string
    speech: string
    speechr: string
    vision: string
    visionr: string
    hearing: string
    hearingr: string
    adhd: string
    adhdr: string
    healthcond: string
    hospitalization: string
    injuries: string
    medication: string
    general: string
    generaldets: string
    psych: string
    psychdets: string
    minor: string
    emergency: string
    hospital: string
    otc: string
    conforme: string
    conformedate: string
  }

  export type studentdetailsUpdateManyMutationInput = {
    uniqid?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    father?: StringFieldUpdateOperationsInput | string
    fathermail?: StringFieldUpdateOperationsInput | string
    fathernumber?: StringFieldUpdateOperationsInput | string
    fatherwork?: StringFieldUpdateOperationsInput | string
    fcompany?: StringFieldUpdateOperationsInput | string
    fsalary?: StringFieldUpdateOperationsInput | string
    mother?: StringFieldUpdateOperationsInput | string
    mothermail?: StringFieldUpdateOperationsInput | string
    mothernumber?: StringFieldUpdateOperationsInput | string
    motherwork?: StringFieldUpdateOperationsInput | string
    mcompany?: StringFieldUpdateOperationsInput | string
    msalary?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    barangay?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postal?: StringFieldUpdateOperationsInput | string
    englishrw?: StringFieldUpdateOperationsInput | string
    englishv?: StringFieldUpdateOperationsInput | string
    languages?: StringFieldUpdateOperationsInput | string
    advclasses?: StringFieldUpdateOperationsInput | string
    remedial?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    ashtma?: StringFieldUpdateOperationsInput | string
    ashtmar?: StringFieldUpdateOperationsInput | string
    allergy?: StringFieldUpdateOperationsInput | string
    allergyr?: StringFieldUpdateOperationsInput | string
    drug?: StringFieldUpdateOperationsInput | string
    drugr?: StringFieldUpdateOperationsInput | string
    speech?: StringFieldUpdateOperationsInput | string
    speechr?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    visionr?: StringFieldUpdateOperationsInput | string
    hearing?: StringFieldUpdateOperationsInput | string
    hearingr?: StringFieldUpdateOperationsInput | string
    adhd?: StringFieldUpdateOperationsInput | string
    adhdr?: StringFieldUpdateOperationsInput | string
    healthcond?: StringFieldUpdateOperationsInput | string
    hospitalization?: StringFieldUpdateOperationsInput | string
    injuries?: StringFieldUpdateOperationsInput | string
    medication?: StringFieldUpdateOperationsInput | string
    general?: StringFieldUpdateOperationsInput | string
    generaldets?: StringFieldUpdateOperationsInput | string
    psych?: StringFieldUpdateOperationsInput | string
    psychdets?: StringFieldUpdateOperationsInput | string
    minor?: StringFieldUpdateOperationsInput | string
    emergency?: StringFieldUpdateOperationsInput | string
    hospital?: StringFieldUpdateOperationsInput | string
    otc?: StringFieldUpdateOperationsInput | string
    conforme?: StringFieldUpdateOperationsInput | string
    conformedate?: StringFieldUpdateOperationsInput | string
  }

  export type studentdetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uniqid?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    father?: StringFieldUpdateOperationsInput | string
    fathermail?: StringFieldUpdateOperationsInput | string
    fathernumber?: StringFieldUpdateOperationsInput | string
    fatherwork?: StringFieldUpdateOperationsInput | string
    fcompany?: StringFieldUpdateOperationsInput | string
    fsalary?: StringFieldUpdateOperationsInput | string
    mother?: StringFieldUpdateOperationsInput | string
    mothermail?: StringFieldUpdateOperationsInput | string
    mothernumber?: StringFieldUpdateOperationsInput | string
    motherwork?: StringFieldUpdateOperationsInput | string
    mcompany?: StringFieldUpdateOperationsInput | string
    msalary?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    barangay?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    postal?: StringFieldUpdateOperationsInput | string
    englishrw?: StringFieldUpdateOperationsInput | string
    englishv?: StringFieldUpdateOperationsInput | string
    languages?: StringFieldUpdateOperationsInput | string
    advclasses?: StringFieldUpdateOperationsInput | string
    remedial?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    ashtma?: StringFieldUpdateOperationsInput | string
    ashtmar?: StringFieldUpdateOperationsInput | string
    allergy?: StringFieldUpdateOperationsInput | string
    allergyr?: StringFieldUpdateOperationsInput | string
    drug?: StringFieldUpdateOperationsInput | string
    drugr?: StringFieldUpdateOperationsInput | string
    speech?: StringFieldUpdateOperationsInput | string
    speechr?: StringFieldUpdateOperationsInput | string
    vision?: StringFieldUpdateOperationsInput | string
    visionr?: StringFieldUpdateOperationsInput | string
    hearing?: StringFieldUpdateOperationsInput | string
    hearingr?: StringFieldUpdateOperationsInput | string
    adhd?: StringFieldUpdateOperationsInput | string
    adhdr?: StringFieldUpdateOperationsInput | string
    healthcond?: StringFieldUpdateOperationsInput | string
    hospitalization?: StringFieldUpdateOperationsInput | string
    injuries?: StringFieldUpdateOperationsInput | string
    medication?: StringFieldUpdateOperationsInput | string
    general?: StringFieldUpdateOperationsInput | string
    generaldets?: StringFieldUpdateOperationsInput | string
    psych?: StringFieldUpdateOperationsInput | string
    psychdets?: StringFieldUpdateOperationsInput | string
    minor?: StringFieldUpdateOperationsInput | string
    emergency?: StringFieldUpdateOperationsInput | string
    hospital?: StringFieldUpdateOperationsInput | string
    otc?: StringFieldUpdateOperationsInput | string
    conforme?: StringFieldUpdateOperationsInput | string
    conformedate?: StringFieldUpdateOperationsInput | string
  }

  export type timeoffCreateInput = {
    rfid: bigint | number
    leavetype: string
    datefrom: Date | string
    dateto: Date | string
    ishalfday: number
    details: string
    credit: number
    approval: string
    approvedate: Date | string
    hrnote: string
    hrdate: Date | string
  }

  export type timeoffUncheckedCreateInput = {
    id?: number
    rfid: bigint | number
    leavetype: string
    datefrom: Date | string
    dateto: Date | string
    ishalfday: number
    details: string
    credit: number
    approval: string
    approvedate: Date | string
    hrnote: string
    hrdate: Date | string
  }

  export type timeoffUpdateInput = {
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    leavetype?: StringFieldUpdateOperationsInput | string
    datefrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateto?: DateTimeFieldUpdateOperationsInput | Date | string
    ishalfday?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    approval?: StringFieldUpdateOperationsInput | string
    approvedate?: DateTimeFieldUpdateOperationsInput | Date | string
    hrnote?: StringFieldUpdateOperationsInput | string
    hrdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type timeoffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    leavetype?: StringFieldUpdateOperationsInput | string
    datefrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateto?: DateTimeFieldUpdateOperationsInput | Date | string
    ishalfday?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    approval?: StringFieldUpdateOperationsInput | string
    approvedate?: DateTimeFieldUpdateOperationsInput | Date | string
    hrnote?: StringFieldUpdateOperationsInput | string
    hrdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type timeoffCreateManyInput = {
    id?: number
    rfid: bigint | number
    leavetype: string
    datefrom: Date | string
    dateto: Date | string
    ishalfday: number
    details: string
    credit: number
    approval: string
    approvedate: Date | string
    hrnote: string
    hrdate: Date | string
  }

  export type timeoffUpdateManyMutationInput = {
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    leavetype?: StringFieldUpdateOperationsInput | string
    datefrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateto?: DateTimeFieldUpdateOperationsInput | Date | string
    ishalfday?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    approval?: StringFieldUpdateOperationsInput | string
    approvedate?: DateTimeFieldUpdateOperationsInput | Date | string
    hrnote?: StringFieldUpdateOperationsInput | string
    hrdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type timeoffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    leavetype?: StringFieldUpdateOperationsInput | string
    datefrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateto?: DateTimeFieldUpdateOperationsInput | Date | string
    ishalfday?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    approval?: StringFieldUpdateOperationsInput | string
    approvedate?: DateTimeFieldUpdateOperationsInput | Date | string
    hrnote?: StringFieldUpdateOperationsInput | string
    hrdate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type type_of_productsCreateInput = {
    name: string
  }

  export type type_of_productsUncheckedCreateInput = {
    id?: number
    name: string
  }

  export type type_of_productsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type type_of_productsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type type_of_productsCreateManyInput = {
    id?: number
    name: string
  }

  export type type_of_productsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type type_of_productsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type uniformCreateInput = {
    rfid: string
    size: string
    basic?: string | null
    activity?: string | null
    formal?: string | null
    qtybasic: string
    qtyact: string
    qtyform: string
    iscomplete: number
    lasttouch: string
    dateordered?: string | null
    datereleased?: string | null
    comment: string
  }

  export type uniformUncheckedCreateInput = {
    id?: number
    rfid: string
    size: string
    basic?: string | null
    activity?: string | null
    formal?: string | null
    qtybasic: string
    qtyact: string
    qtyform: string
    iscomplete: number
    lasttouch: string
    dateordered?: string | null
    datereleased?: string | null
    comment: string
  }

  export type uniformUpdateInput = {
    rfid?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    basic?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableStringFieldUpdateOperationsInput | string | null
    formal?: NullableStringFieldUpdateOperationsInput | string | null
    qtybasic?: StringFieldUpdateOperationsInput | string
    qtyact?: StringFieldUpdateOperationsInput | string
    qtyform?: StringFieldUpdateOperationsInput | string
    iscomplete?: IntFieldUpdateOperationsInput | number
    lasttouch?: StringFieldUpdateOperationsInput | string
    dateordered?: NullableStringFieldUpdateOperationsInput | string | null
    datereleased?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type uniformUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    basic?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableStringFieldUpdateOperationsInput | string | null
    formal?: NullableStringFieldUpdateOperationsInput | string | null
    qtybasic?: StringFieldUpdateOperationsInput | string
    qtyact?: StringFieldUpdateOperationsInput | string
    qtyform?: StringFieldUpdateOperationsInput | string
    iscomplete?: IntFieldUpdateOperationsInput | number
    lasttouch?: StringFieldUpdateOperationsInput | string
    dateordered?: NullableStringFieldUpdateOperationsInput | string | null
    datereleased?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type uniformCreateManyInput = {
    id?: number
    rfid: string
    size: string
    basic?: string | null
    activity?: string | null
    formal?: string | null
    qtybasic: string
    qtyact: string
    qtyform: string
    iscomplete: number
    lasttouch: string
    dateordered?: string | null
    datereleased?: string | null
    comment: string
  }

  export type uniformUpdateManyMutationInput = {
    rfid?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    basic?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableStringFieldUpdateOperationsInput | string | null
    formal?: NullableStringFieldUpdateOperationsInput | string | null
    qtybasic?: StringFieldUpdateOperationsInput | string
    qtyact?: StringFieldUpdateOperationsInput | string
    qtyform?: StringFieldUpdateOperationsInput | string
    iscomplete?: IntFieldUpdateOperationsInput | number
    lasttouch?: StringFieldUpdateOperationsInput | string
    dateordered?: NullableStringFieldUpdateOperationsInput | string | null
    datereleased?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type uniformUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    basic?: NullableStringFieldUpdateOperationsInput | string | null
    activity?: NullableStringFieldUpdateOperationsInput | string | null
    formal?: NullableStringFieldUpdateOperationsInput | string | null
    qtybasic?: StringFieldUpdateOperationsInput | string
    qtyact?: StringFieldUpdateOperationsInput | string
    qtyform?: StringFieldUpdateOperationsInput | string
    iscomplete?: IntFieldUpdateOperationsInput | number
    lasttouch?: StringFieldUpdateOperationsInput | string
    dateordered?: NullableStringFieldUpdateOperationsInput | string | null
    datereleased?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type uniform_inventoryCreateInput = {
    uniform_type_id: string
    uniform_size_id: string
    qty: number
    gender: string
    date: Date | string
    user: string
  }

  export type uniform_inventoryUncheckedCreateInput = {
    id?: number
    uniform_type_id: string
    uniform_size_id: string
    qty: number
    gender: string
    date: Date | string
    user: string
  }

  export type uniform_inventoryUpdateInput = {
    uniform_type_id?: StringFieldUpdateOperationsInput | string
    uniform_size_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: StringFieldUpdateOperationsInput | string
  }

  export type uniform_inventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uniform_type_id?: StringFieldUpdateOperationsInput | string
    uniform_size_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: StringFieldUpdateOperationsInput | string
  }

  export type uniform_inventoryCreateManyInput = {
    id?: number
    uniform_type_id: string
    uniform_size_id: string
    qty: number
    gender: string
    date: Date | string
    user: string
  }

  export type uniform_inventoryUpdateManyMutationInput = {
    uniform_type_id?: StringFieldUpdateOperationsInput | string
    uniform_size_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: StringFieldUpdateOperationsInput | string
  }

  export type uniform_inventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uniform_type_id?: StringFieldUpdateOperationsInput | string
    uniform_size_id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: StringFieldUpdateOperationsInput | string
  }

  export type uniform_issuedCreateInput = {
    rfid: string
    releasedby: string
    uniform_type_id: string
    uniform_size_id: string
    date: Date | string
  }

  export type uniform_issuedUncheckedCreateInput = {
    id?: number
    rfid: string
    releasedby: string
    uniform_type_id: string
    uniform_size_id: string
    date: Date | string
  }

  export type uniform_issuedUpdateInput = {
    rfid?: StringFieldUpdateOperationsInput | string
    releasedby?: StringFieldUpdateOperationsInput | string
    uniform_type_id?: StringFieldUpdateOperationsInput | string
    uniform_size_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type uniform_issuedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: StringFieldUpdateOperationsInput | string
    releasedby?: StringFieldUpdateOperationsInput | string
    uniform_type_id?: StringFieldUpdateOperationsInput | string
    uniform_size_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type uniform_issuedCreateManyInput = {
    id?: number
    rfid: string
    releasedby: string
    uniform_type_id: string
    uniform_size_id: string
    date: Date | string
  }

  export type uniform_issuedUpdateManyMutationInput = {
    rfid?: StringFieldUpdateOperationsInput | string
    releasedby?: StringFieldUpdateOperationsInput | string
    uniform_type_id?: StringFieldUpdateOperationsInput | string
    uniform_size_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type uniform_issuedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: StringFieldUpdateOperationsInput | string
    releasedby?: StringFieldUpdateOperationsInput | string
    uniform_type_id?: StringFieldUpdateOperationsInput | string
    uniform_size_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type uniform_sizesCreateInput = {
    size: string
    created_at?: Date | string | null
  }

  export type uniform_sizesUncheckedCreateInput = {
    id?: number
    size: string
    created_at?: Date | string | null
  }

  export type uniform_sizesUpdateInput = {
    size?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type uniform_sizesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type uniform_sizesCreateManyInput = {
    id?: number
    size: string
    created_at?: Date | string | null
  }

  export type uniform_sizesUpdateManyMutationInput = {
    size?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type uniform_sizesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type uniform_typesCreateInput = {
    type: string
    created_at?: Date | string | null
  }

  export type uniform_typesUncheckedCreateInput = {
    id?: number
    type: string
    created_at?: Date | string | null
  }

  export type uniform_typesUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type uniform_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type uniform_typesCreateManyInput = {
    id?: number
    type: string
    created_at?: Date | string | null
  }

  export type uniform_typesUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type uniform_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userCreateInput = {
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    type: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    is_situation: string
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    nationalities: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    religion: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: string
    isESL: number
    house: string
    isofficial: number
    isEnrolledInAfterSchool?: boolean
    attendance?: attendanceCreateNestedManyWithoutUserInput
    enrolledactivity?: enrolledactivityCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    type: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    is_situation: string
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    nationalities: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    religion: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: string
    isESL: number
    house: string
    isofficial: number
    isEnrolledInAfterSchool?: boolean
    attendance?: attendanceUncheckedCreateNestedManyWithoutUserInput
    enrolledactivity?: enrolledactivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    is_situation?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    nationalities?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    isESL?: IntFieldUpdateOperationsInput | number
    house?: StringFieldUpdateOperationsInput | string
    isofficial?: IntFieldUpdateOperationsInput | number
    isEnrolledInAfterSchool?: BoolFieldUpdateOperationsInput | boolean
    attendance?: attendanceUpdateManyWithoutUserNestedInput
    enrolledactivity?: enrolledactivityUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    is_situation?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    nationalities?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    isESL?: IntFieldUpdateOperationsInput | number
    house?: StringFieldUpdateOperationsInput | string
    isofficial?: IntFieldUpdateOperationsInput | number
    isEnrolledInAfterSchool?: BoolFieldUpdateOperationsInput | boolean
    attendance?: attendanceUncheckedUpdateManyWithoutUserNestedInput
    enrolledactivity?: enrolledactivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    type: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    is_situation: string
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    nationalities: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    religion: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: string
    isESL: number
    house: string
    isofficial: number
    isEnrolledInAfterSchool?: boolean
  }

  export type userUpdateManyMutationInput = {
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    is_situation?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    nationalities?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    isESL?: IntFieldUpdateOperationsInput | number
    house?: StringFieldUpdateOperationsInput | string
    isofficial?: IntFieldUpdateOperationsInput | number
    isEnrolledInAfterSchool?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    is_situation?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    nationalities?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    isESL?: IntFieldUpdateOperationsInput | number
    house?: StringFieldUpdateOperationsInput | string
    isofficial?: IntFieldUpdateOperationsInput | number
    isEnrolledInAfterSchool?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user22CreateInput = {
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
  }

  export type user22UncheckedCreateInput = {
    id?: number
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
  }

  export type user22UpdateInput = {
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
  }

  export type user22UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
  }

  export type user22CreateManyInput = {
    id?: number
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
  }

  export type user22UpdateManyMutationInput = {
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
  }

  export type user22UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
  }

  export type users24CreateInput = {
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    type: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    is_situation: string
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    nationalities: string
    religion: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: string
    isESL: number
    house: string
    isofficial: number
  }

  export type users24UncheckedCreateInput = {
    id?: number
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    type: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    is_situation: string
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    nationalities: string
    religion: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: string
    isESL: number
    house: string
    isofficial: number
  }

  export type users24UpdateInput = {
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    is_situation?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    nationalities?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    isESL?: IntFieldUpdateOperationsInput | number
    house?: StringFieldUpdateOperationsInput | string
    isofficial?: IntFieldUpdateOperationsInput | number
  }

  export type users24UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    is_situation?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    nationalities?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    isESL?: IntFieldUpdateOperationsInput | number
    house?: StringFieldUpdateOperationsInput | string
    isofficial?: IntFieldUpdateOperationsInput | number
  }

  export type users24CreateManyInput = {
    id?: number
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    type: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    is_situation: string
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    nationalities: string
    religion: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: string
    isESL: number
    house: string
    isofficial: number
  }

  export type users24UpdateManyMutationInput = {
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    is_situation?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    nationalities?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    isESL?: IntFieldUpdateOperationsInput | number
    house?: StringFieldUpdateOperationsInput | string
    isofficial?: IntFieldUpdateOperationsInput | number
  }

  export type users24UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    is_situation?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    nationalities?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    isESL?: IntFieldUpdateOperationsInput | number
    house?: StringFieldUpdateOperationsInput | string
    isofficial?: IntFieldUpdateOperationsInput | number
  }

  export type visitorlogCreateInput = {
    name: string
    rfid: string
    comment: string
    registerdate: Date | string
    status: number
  }

  export type visitorlogUncheckedCreateInput = {
    id?: number
    name: string
    rfid: string
    comment: string
    registerdate: Date | string
    status: number
  }

  export type visitorlogUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    rfid?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    registerdate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type visitorlogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rfid?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    registerdate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type visitorlogCreateManyInput = {
    id?: number
    name: string
    rfid: string
    comment: string
    registerdate: Date | string
    status: number
  }

  export type visitorlogUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    rfid?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    registerdate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type visitorlogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rfid?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    registerdate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type wispayCreateInput = {
    debit: Decimal | DecimalJsLike | number | string
    credit: Decimal | DecimalJsLike | number | string
    rfid: bigint | number
    empid: string
    username: string
    refcode: string
    transdate: Date | string
    processedby: string
    product_type: string
    product_name: string
    quantity: number
    isAfterSchoolPayment?: boolean
  }

  export type wispayUncheckedCreateInput = {
    id?: number
    debit: Decimal | DecimalJsLike | number | string
    credit: Decimal | DecimalJsLike | number | string
    rfid: bigint | number
    empid: string
    username: string
    refcode: string
    transdate: Date | string
    processedby: string
    product_type: string
    product_name: string
    quantity: number
    isAfterSchoolPayment?: boolean
  }

  export type wispayUpdateInput = {
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    empid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    refcode?: StringFieldUpdateOperationsInput | string
    transdate?: DateTimeFieldUpdateOperationsInput | Date | string
    processedby?: StringFieldUpdateOperationsInput | string
    product_type?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    isAfterSchoolPayment?: BoolFieldUpdateOperationsInput | boolean
  }

  export type wispayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    empid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    refcode?: StringFieldUpdateOperationsInput | string
    transdate?: DateTimeFieldUpdateOperationsInput | Date | string
    processedby?: StringFieldUpdateOperationsInput | string
    product_type?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    isAfterSchoolPayment?: BoolFieldUpdateOperationsInput | boolean
  }

  export type wispayCreateManyInput = {
    id?: number
    debit: Decimal | DecimalJsLike | number | string
    credit: Decimal | DecimalJsLike | number | string
    rfid: bigint | number
    empid: string
    username: string
    refcode: string
    transdate: Date | string
    processedby: string
    product_type: string
    product_name: string
    quantity: number
    isAfterSchoolPayment?: boolean
  }

  export type wispayUpdateManyMutationInput = {
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    empid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    refcode?: StringFieldUpdateOperationsInput | string
    transdate?: DateTimeFieldUpdateOperationsInput | Date | string
    processedby?: StringFieldUpdateOperationsInput | string
    product_type?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    isAfterSchoolPayment?: BoolFieldUpdateOperationsInput | boolean
  }

  export type wispayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    empid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    refcode?: StringFieldUpdateOperationsInput | string
    transdate?: DateTimeFieldUpdateOperationsInput | Date | string
    processedby?: StringFieldUpdateOperationsInput | string
    product_type?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    isAfterSchoolPayment?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AfterschoolactivityScalarRelationFilter = {
    is?: afterschoolactivityWhereInput
    isNot?: afterschoolactivityWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: attendanceWhereInput
    some?: attendanceWhereInput
    none?: attendanceWhereInput
  }

  export type attendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type activitysessionCountOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type activitysessionAvgOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
  }

  export type activitysessionMaxOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type activitysessionMinOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type activitysessionSumOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ActivitysessionListRelationFilter = {
    every?: activitysessionWhereInput
    some?: activitysessionWhereInput
    none?: activitysessionWhereInput
  }

  export type EnrolledactivityListRelationFilter = {
    every?: enrolledactivityWhereInput
    some?: enrolledactivityWhereInput
    none?: enrolledactivityWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type activitysessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type enrolledactivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type afterschoolactivityOrderByRelevanceInput = {
    fields: afterschoolactivityOrderByRelevanceFieldEnum | afterschoolactivityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type afterschoolactivityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    coachName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photo?: SortOrder
  }

  export type afterschoolactivityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type afterschoolactivityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    coachName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photo?: SortOrder
  }

  export type afterschoolactivityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    location?: SortOrder
    coachName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photo?: SortOrder
  }

  export type afterschoolactivitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ActivitysessionScalarRelationFilter = {
    is?: activitysessionWhereInput
    isNot?: activitysessionWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type attendanceOrderByRelevanceInput = {
    fields: attendanceOrderByRelevanceFieldEnum | attendanceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type attendanceSessionIdUserIdCompoundUniqueInput = {
    sessionId: number
    userId: number
  }

  export type attendanceCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
  }

  export type attendanceAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
  }

  export type attendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
  }

  export type attendanceMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
  }

  export type attendanceSumOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type attendance_libraryOrderByRelevanceInput = {
    fields: attendance_libraryOrderByRelevanceFieldEnum | attendance_libraryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type attendance_libraryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    rfid?: SortOrder
  }

  export type attendance_libraryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type attendance_libraryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    rfid?: SortOrder
  }

  export type attendance_libraryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    rfid?: SortOrder
  }

  export type attendance_librarySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type borrowersOrderByRelevanceInput = {
    fields: borrowersOrderByRelevanceFieldEnum | borrowersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type borrowersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rfid?: SortOrder
    title?: SortOrder
    date_borrowed?: SortOrder
    date_returned?: SortOrder
    remarks?: SortOrder
  }

  export type borrowersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type borrowersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rfid?: SortOrder
    title?: SortOrder
    date_borrowed?: SortOrder
    date_returned?: SortOrder
    remarks?: SortOrder
  }

  export type borrowersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rfid?: SortOrder
    title?: SortOrder
    date_borrowed?: SortOrder
    date_returned?: SortOrder
    remarks?: SortOrder
  }

  export type borrowersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type buyersOrderByRelevanceInput = {
    fields: buyersOrderByRelevanceFieldEnum | buyersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type buyersCountOrderByAggregateInput = {
    buyer_id?: SortOrder
    buyer_name?: SortOrder
    rfid?: SortOrder
  }

  export type buyersAvgOrderByAggregateInput = {
    buyer_id?: SortOrder
    rfid?: SortOrder
  }

  export type buyersMaxOrderByAggregateInput = {
    buyer_id?: SortOrder
    buyer_name?: SortOrder
    rfid?: SortOrder
  }

  export type buyersMinOrderByAggregateInput = {
    buyer_id?: SortOrder
    buyer_name?: SortOrder
    rfid?: SortOrder
  }

  export type buyersSumOrderByAggregateInput = {
    buyer_id?: SortOrder
    rfid?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type clinic_historyOrderByRelevanceInput = {
    fields: clinic_historyOrderByRelevanceFieldEnum | clinic_historyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type clinic_historyCountOrderByAggregateInput = {
    Id?: SortOrder
    name?: SortOrder
    grade?: SortOrder
    complaint?: SortOrder
    diagnose?: SortOrder
    treatment?: SortOrder
    vital_signs?: SortOrder
    time_in?: SortOrder
    time_out?: SortOrder
    date?: SortOrder
    remarks?: SortOrder
  }

  export type clinic_historyAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type clinic_historyMaxOrderByAggregateInput = {
    Id?: SortOrder
    name?: SortOrder
    grade?: SortOrder
    complaint?: SortOrder
    diagnose?: SortOrder
    treatment?: SortOrder
    vital_signs?: SortOrder
    time_in?: SortOrder
    time_out?: SortOrder
    date?: SortOrder
    remarks?: SortOrder
  }

  export type clinic_historyMinOrderByAggregateInput = {
    Id?: SortOrder
    name?: SortOrder
    grade?: SortOrder
    complaint?: SortOrder
    diagnose?: SortOrder
    treatment?: SortOrder
    vital_signs?: SortOrder
    time_in?: SortOrder
    time_out?: SortOrder
    date?: SortOrder
    remarks?: SortOrder
  }

  export type clinic_historySumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type countriesOrderByRelevanceInput = {
    fields: countriesOrderByRelevanceFieldEnum | countriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type countriesCountOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    countryName?: SortOrder
    currencyCode?: SortOrder
    fipsCode?: SortOrder
    isoNumeric?: SortOrder
    north?: SortOrder
    south?: SortOrder
    east?: SortOrder
    west?: SortOrder
    capital?: SortOrder
    continentName?: SortOrder
    continent?: SortOrder
    languages?: SortOrder
  }

  export type countriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type countriesMaxOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    countryName?: SortOrder
    currencyCode?: SortOrder
    fipsCode?: SortOrder
    isoNumeric?: SortOrder
    north?: SortOrder
    south?: SortOrder
    east?: SortOrder
    west?: SortOrder
    capital?: SortOrder
    continentName?: SortOrder
    continent?: SortOrder
    languages?: SortOrder
  }

  export type countriesMinOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    countryName?: SortOrder
    currencyCode?: SortOrder
    fipsCode?: SortOrder
    isoNumeric?: SortOrder
    north?: SortOrder
    south?: SortOrder
    east?: SortOrder
    west?: SortOrder
    capital?: SortOrder
    continentName?: SortOrder
    continent?: SortOrder
    languages?: SortOrder
  }

  export type countriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type enrolledactivityUserIdActivityIdCompoundUniqueInput = {
    userId: number
    activityId: number
  }

  export type enrolledactivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    enrollmentDate?: SortOrder
  }

  export type enrolledactivityAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type enrolledactivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    enrollmentDate?: SortOrder
  }

  export type enrolledactivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
    enrollmentDate?: SortOrder
  }

  export type enrolledactivitySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activityId?: SortOrder
  }

  export type inventoryOrderByRelevanceInput = {
    fields: inventoryOrderByRelevanceFieldEnum | inventoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type inventoryCountOrderByAggregateInput = {
    id?: SortOrder
    empno?: SortOrder
    description?: SortOrder
    serial?: SortOrder
    dateout?: SortOrder
    datein?: SortOrder
    issuedby?: SortOrder
    remarks?: SortOrder
  }

  export type inventoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type inventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    empno?: SortOrder
    description?: SortOrder
    serial?: SortOrder
    dateout?: SortOrder
    datein?: SortOrder
    issuedby?: SortOrder
    remarks?: SortOrder
  }

  export type inventoryMinOrderByAggregateInput = {
    id?: SortOrder
    empno?: SortOrder
    description?: SortOrder
    serial?: SortOrder
    dateout?: SortOrder
    datein?: SortOrder
    issuedby?: SortOrder
    remarks?: SortOrder
  }

  export type inventorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type inventory__suppliersOrderByRelevanceInput = {
    fields: inventory__suppliersOrderByRelevanceFieldEnum | inventory__suppliersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type inventory__suppliersCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    itemsProvided?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    rating?: SortOrder
  }

  export type inventory__suppliersAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
  }

  export type inventory__suppliersMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    itemsProvided?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    rating?: SortOrder
  }

  export type inventory__suppliersMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    itemsProvided?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    rating?: SortOrder
  }

  export type inventory__suppliersSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type inventory_bookstoreOrderByRelevanceInput = {
    fields: inventory_bookstoreOrderByRelevanceFieldEnum | inventory_bookstoreOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type inventory_bookstoreCountOrderByAggregateInput = {
    id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    selling_price?: SortOrder
    date?: SortOrder
  }

  export type inventory_bookstoreAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    selling_price?: SortOrder
  }

  export type inventory_bookstoreMaxOrderByAggregateInput = {
    id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    selling_price?: SortOrder
    date?: SortOrder
  }

  export type inventory_bookstoreMinOrderByAggregateInput = {
    id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    selling_price?: SortOrder
    date?: SortOrder
  }

  export type inventory_bookstoreSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    selling_price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type library_loginOrderByRelevanceInput = {
    fields: library_loginOrderByRelevanceFieldEnum | library_loginOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type library_loginCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type library_loginAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type library_loginMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type library_loginMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type library_loginSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type logs_enrollOrderByRelevanceInput = {
    fields: logs_enrollOrderByRelevanceFieldEnum | logs_enrollOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type logs_enrollCountOrderByAggregateInput = {
    id?: SortOrder
    ern?: SortOrder
    stage?: SortOrder
    usertouch?: SortOrder
    touch?: SortOrder
    notes?: SortOrder
  }

  export type logs_enrollAvgOrderByAggregateInput = {
    id?: SortOrder
    stage?: SortOrder
  }

  export type logs_enrollMaxOrderByAggregateInput = {
    id?: SortOrder
    ern?: SortOrder
    stage?: SortOrder
    usertouch?: SortOrder
    touch?: SortOrder
    notes?: SortOrder
  }

  export type logs_enrollMinOrderByAggregateInput = {
    id?: SortOrder
    ern?: SortOrder
    stage?: SortOrder
    usertouch?: SortOrder
    touch?: SortOrder
    notes?: SortOrder
  }

  export type logs_enrollSumOrderByAggregateInput = {
    id?: SortOrder
    stage?: SortOrder
  }

  export type nationalitiesOrderByRelevanceInput = {
    fields: nationalitiesOrderByRelevanceFieldEnum | nationalitiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type nationalitiesCountOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    nationalityName?: SortOrder
    currencyCode?: SortOrder
    fipsCode?: SortOrder
    isoNumeric?: SortOrder
    north?: SortOrder
    south?: SortOrder
    east?: SortOrder
    west?: SortOrder
    capital?: SortOrder
    continentName?: SortOrder
    continent?: SortOrder
  }

  export type nationalitiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type nationalitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    nationalityName?: SortOrder
    currencyCode?: SortOrder
    fipsCode?: SortOrder
    isoNumeric?: SortOrder
    north?: SortOrder
    south?: SortOrder
    east?: SortOrder
    west?: SortOrder
    capital?: SortOrder
    continentName?: SortOrder
    continent?: SortOrder
  }

  export type nationalitiesMinOrderByAggregateInput = {
    id?: SortOrder
    countryCode?: SortOrder
    nationalityName?: SortOrder
    currencyCode?: SortOrder
    fipsCode?: SortOrder
    isoNumeric?: SortOrder
    north?: SortOrder
    south?: SortOrder
    east?: SortOrder
    west?: SortOrder
    capital?: SortOrder
    continentName?: SortOrder
    continent?: SortOrder
  }

  export type nationalitiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type productsOrderByRelevanceInput = {
    fields: productsOrderByRelevanceFieldEnum | productsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type productsCountOrderByAggregateInput = {
    id?: SortOrder
    product_code?: SortOrder
    type_of_product?: SortOrder
    name_of_product?: SortOrder
    price_of_product?: SortOrder
    date_created?: SortOrder
    last_touch?: SortOrder
  }

  export type productsAvgOrderByAggregateInput = {
    id?: SortOrder
    price_of_product?: SortOrder
  }

  export type productsMaxOrderByAggregateInput = {
    id?: SortOrder
    product_code?: SortOrder
    type_of_product?: SortOrder
    name_of_product?: SortOrder
    price_of_product?: SortOrder
    date_created?: SortOrder
    last_touch?: SortOrder
  }

  export type productsMinOrderByAggregateInput = {
    id?: SortOrder
    product_code?: SortOrder
    type_of_product?: SortOrder
    name_of_product?: SortOrder
    price_of_product?: SortOrder
    date_created?: SortOrder
    last_touch?: SortOrder
  }

  export type productsSumOrderByAggregateInput = {
    id?: SortOrder
    price_of_product?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type requestsOrderByRelevanceInput = {
    fields: requestsOrderByRelevanceFieldEnum | requestsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type requestsCountOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    reqtype?: SortOrder
    reqdate?: SortOrder
    reqneed?: SortOrder
    reqdetails?: SortOrder
    approvedby?: SortOrder
    approvedate?: SortOrder
    approvedfin?: SortOrder
    approvedfindate?: SortOrder
    status?: SortOrder
  }

  export type requestsAvgOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    approvedby?: SortOrder
    approvedfin?: SortOrder
  }

  export type requestsMaxOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    reqtype?: SortOrder
    reqdate?: SortOrder
    reqneed?: SortOrder
    reqdetails?: SortOrder
    approvedby?: SortOrder
    approvedate?: SortOrder
    approvedfin?: SortOrder
    approvedfindate?: SortOrder
    status?: SortOrder
  }

  export type requestsMinOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    reqtype?: SortOrder
    reqdate?: SortOrder
    reqneed?: SortOrder
    reqdetails?: SortOrder
    approvedby?: SortOrder
    approvedate?: SortOrder
    approvedfin?: SortOrder
    approvedfindate?: SortOrder
    status?: SortOrder
  }

  export type requestsSumOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    approvedby?: SortOrder
    approvedfin?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type s_activitiesOrderByRelevanceInput = {
    fields: s_activitiesOrderByRelevanceFieldEnum | s_activitiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type s_activitiesCountOrderByAggregateInput = {
    id?: SortOrder
    actid?: SortOrder
    subjcode?: SortOrder
    actlvl?: SortOrder
    actsection?: SortOrder
    actdate?: SortOrder
    actcreate?: SortOrder
    actdesc?: SortOrder
    acttype?: SortOrder
    actqtr?: SortOrder
    maxscore?: SortOrder
    flag?: SortOrder
  }

  export type s_activitiesAvgOrderByAggregateInput = {
    id?: SortOrder
    actlvl?: SortOrder
    acttype?: SortOrder
    actqtr?: SortOrder
    maxscore?: SortOrder
    flag?: SortOrder
  }

  export type s_activitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    actid?: SortOrder
    subjcode?: SortOrder
    actlvl?: SortOrder
    actsection?: SortOrder
    actdate?: SortOrder
    actcreate?: SortOrder
    actdesc?: SortOrder
    acttype?: SortOrder
    actqtr?: SortOrder
    maxscore?: SortOrder
    flag?: SortOrder
  }

  export type s_activitiesMinOrderByAggregateInput = {
    id?: SortOrder
    actid?: SortOrder
    subjcode?: SortOrder
    actlvl?: SortOrder
    actsection?: SortOrder
    actdate?: SortOrder
    actcreate?: SortOrder
    actdesc?: SortOrder
    acttype?: SortOrder
    actqtr?: SortOrder
    maxscore?: SortOrder
    flag?: SortOrder
  }

  export type s_activitiesSumOrderByAggregateInput = {
    id?: SortOrder
    actlvl?: SortOrder
    acttype?: SortOrder
    actqtr?: SortOrder
    maxscore?: SortOrder
    flag?: SortOrder
  }

  export type s_classattendanceOrderByRelevanceInput = {
    fields: s_classattendanceOrderByRelevanceFieldEnum | s_classattendanceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type s_classattendanceCountOrderByAggregateInput = {
    id?: SortOrder
    attendance?: SortOrder
    subjid?: SortOrder
    studid?: SortOrder
    adate?: SortOrder
    tid?: SortOrder
    notes?: SortOrder
  }

  export type s_classattendanceAvgOrderByAggregateInput = {
    id?: SortOrder
    attendance?: SortOrder
  }

  export type s_classattendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    attendance?: SortOrder
    subjid?: SortOrder
    studid?: SortOrder
    adate?: SortOrder
    tid?: SortOrder
    notes?: SortOrder
  }

  export type s_classattendanceMinOrderByAggregateInput = {
    id?: SortOrder
    attendance?: SortOrder
    subjid?: SortOrder
    studid?: SortOrder
    adate?: SortOrder
    tid?: SortOrder
    notes?: SortOrder
  }

  export type s_classattendanceSumOrderByAggregateInput = {
    id?: SortOrder
    attendance?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type s_coretableOrderByRelevanceInput = {
    fields: s_coretableOrderByRelevanceFieldEnum | s_coretableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type s_coretableCountOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    grade?: SortOrder
  }

  export type s_coretableAvgOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type s_coretableMaxOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    grade?: SortOrder
  }

  export type s_coretableMinOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    grade?: SortOrder
  }

  export type s_coretableSumOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type s_corevaluesOrderByRelevanceInput = {
    fields: s_corevaluesOrderByRelevanceFieldEnum | s_corevaluesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type s_corevaluesCountOrderByAggregateInput = {
    id?: SortOrder
    corevalue?: SortOrder
  }

  export type s_corevaluesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type s_corevaluesMaxOrderByAggregateInput = {
    id?: SortOrder
    corevalue?: SortOrder
  }

  export type s_corevaluesMinOrderByAggregateInput = {
    id?: SortOrder
    corevalue?: SortOrder
  }

  export type s_corevaluesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type s_payablesOrderByRelevanceInput = {
    fields: s_payablesOrderByRelevanceFieldEnum | s_payablesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type s_payablesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    reservation_fee?: SortOrder
    tuition_fee?: SortOrder
    other_fee?: SortOrder
    assessment_fee?: SortOrder
    registration_fee?: SortOrder
    special_permit?: SortOrder
    international_fee_old?: SortOrder
    international_fee_new?: SortOrder
    pta?: SortOrder
  }

  export type s_payablesAvgOrderByAggregateInput = {
    id?: SortOrder
    reservation_fee?: SortOrder
    tuition_fee?: SortOrder
    other_fee?: SortOrder
    assessment_fee?: SortOrder
    registration_fee?: SortOrder
    special_permit?: SortOrder
    international_fee_old?: SortOrder
    international_fee_new?: SortOrder
    pta?: SortOrder
  }

  export type s_payablesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    reservation_fee?: SortOrder
    tuition_fee?: SortOrder
    other_fee?: SortOrder
    assessment_fee?: SortOrder
    registration_fee?: SortOrder
    special_permit?: SortOrder
    international_fee_old?: SortOrder
    international_fee_new?: SortOrder
    pta?: SortOrder
  }

  export type s_payablesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    reservation_fee?: SortOrder
    tuition_fee?: SortOrder
    other_fee?: SortOrder
    assessment_fee?: SortOrder
    registration_fee?: SortOrder
    special_permit?: SortOrder
    international_fee_old?: SortOrder
    international_fee_new?: SortOrder
    pta?: SortOrder
  }

  export type s_payablesSumOrderByAggregateInput = {
    id?: SortOrder
    reservation_fee?: SortOrder
    tuition_fee?: SortOrder
    other_fee?: SortOrder
    assessment_fee?: SortOrder
    registration_fee?: SortOrder
    special_permit?: SortOrder
    international_fee_old?: SortOrder
    international_fee_new?: SortOrder
    pta?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type s_recommendationsOrderByRelevanceInput = {
    fields: s_recommendationsOrderByRelevanceFieldEnum | s_recommendationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type s_recommendationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    esl?: SortOrder
    star?: SortOrder
    completion?: SortOrder
  }

  export type s_recommendationsAvgOrderByAggregateInput = {
    id?: SortOrder
    esl?: SortOrder
    star?: SortOrder
    completion?: SortOrder
  }

  export type s_recommendationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    esl?: SortOrder
    star?: SortOrder
    completion?: SortOrder
  }

  export type s_recommendationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    esl?: SortOrder
    star?: SortOrder
    completion?: SortOrder
  }

  export type s_recommendationsSumOrderByAggregateInput = {
    id?: SortOrder
    esl?: SortOrder
    star?: SortOrder
    completion?: SortOrder
  }

  export type s_scoresOrderByRelevanceInput = {
    fields: s_scoresOrderByRelevanceFieldEnum | s_scoresOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type s_scoresCountOrderByAggregateInput = {
    id?: SortOrder
    subjcode?: SortOrder
    actid?: SortOrder
    acttype?: SortOrder
    sid?: SortOrder
    score?: SortOrder
    maxscore?: SortOrder
    qtr?: SortOrder
    flag?: SortOrder
  }

  export type s_scoresAvgOrderByAggregateInput = {
    id?: SortOrder
    acttype?: SortOrder
    score?: SortOrder
    maxscore?: SortOrder
    qtr?: SortOrder
    flag?: SortOrder
  }

  export type s_scoresMaxOrderByAggregateInput = {
    id?: SortOrder
    subjcode?: SortOrder
    actid?: SortOrder
    acttype?: SortOrder
    sid?: SortOrder
    score?: SortOrder
    maxscore?: SortOrder
    qtr?: SortOrder
    flag?: SortOrder
  }

  export type s_scoresMinOrderByAggregateInput = {
    id?: SortOrder
    subjcode?: SortOrder
    actid?: SortOrder
    acttype?: SortOrder
    sid?: SortOrder
    score?: SortOrder
    maxscore?: SortOrder
    qtr?: SortOrder
    flag?: SortOrder
  }

  export type s_scoresSumOrderByAggregateInput = {
    id?: SortOrder
    acttype?: SortOrder
    score?: SortOrder
    maxscore?: SortOrder
    qtr?: SortOrder
    flag?: SortOrder
  }

  export type s_studentcvOrderByRelevanceInput = {
    fields: s_studentcvOrderByRelevanceFieldEnum | s_studentcvOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type s_studentcvCountOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    tid?: SortOrder
    subjid?: SortOrder
    qtr?: SortOrder
    independence?: SortOrder
    confidence?: SortOrder
    respect?: SortOrder
    empathy?: SortOrder
    appreciation?: SortOrder
    tolerance?: SortOrder
    enthusiasm?: SortOrder
    conduct?: SortOrder
  }

  export type s_studentcvAvgOrderByAggregateInput = {
    id?: SortOrder
    qtr?: SortOrder
    independence?: SortOrder
    confidence?: SortOrder
    respect?: SortOrder
    empathy?: SortOrder
    appreciation?: SortOrder
    tolerance?: SortOrder
    enthusiasm?: SortOrder
    conduct?: SortOrder
  }

  export type s_studentcvMaxOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    tid?: SortOrder
    subjid?: SortOrder
    qtr?: SortOrder
    independence?: SortOrder
    confidence?: SortOrder
    respect?: SortOrder
    empathy?: SortOrder
    appreciation?: SortOrder
    tolerance?: SortOrder
    enthusiasm?: SortOrder
    conduct?: SortOrder
  }

  export type s_studentcvMinOrderByAggregateInput = {
    id?: SortOrder
    sid?: SortOrder
    tid?: SortOrder
    subjid?: SortOrder
    qtr?: SortOrder
    independence?: SortOrder
    confidence?: SortOrder
    respect?: SortOrder
    empathy?: SortOrder
    appreciation?: SortOrder
    tolerance?: SortOrder
    enthusiasm?: SortOrder
    conduct?: SortOrder
  }

  export type s_studentcvSumOrderByAggregateInput = {
    id?: SortOrder
    qtr?: SortOrder
    independence?: SortOrder
    confidence?: SortOrder
    respect?: SortOrder
    empathy?: SortOrder
    appreciation?: SortOrder
    tolerance?: SortOrder
    enthusiasm?: SortOrder
    conduct?: SortOrder
  }

  export type s_subjectsOrderByRelevanceInput = {
    fields: s_subjectsOrderByRelevanceFieldEnum | s_subjectsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type s_subjectsCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    tid?: SortOrder
    subjdesc?: SortOrder
    subjlevel?: SortOrder
    subjsection?: SortOrder
    assignedby?: SortOrder
    assigndate?: SortOrder
    percentww?: SortOrder
    percentpt?: SortOrder
    percentqt?: SortOrder
  }

  export type s_subjectsAvgOrderByAggregateInput = {
    id?: SortOrder
    percentww?: SortOrder
    percentpt?: SortOrder
    percentqt?: SortOrder
  }

  export type s_subjectsMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    tid?: SortOrder
    subjdesc?: SortOrder
    subjlevel?: SortOrder
    subjsection?: SortOrder
    assignedby?: SortOrder
    assigndate?: SortOrder
    percentww?: SortOrder
    percentpt?: SortOrder
    percentqt?: SortOrder
  }

  export type s_subjectsMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    tid?: SortOrder
    subjdesc?: SortOrder
    subjlevel?: SortOrder
    subjsection?: SortOrder
    assignedby?: SortOrder
    assigndate?: SortOrder
    percentww?: SortOrder
    percentpt?: SortOrder
    percentqt?: SortOrder
  }

  export type s_subjectsSumOrderByAggregateInput = {
    id?: SortOrder
    percentww?: SortOrder
    percentpt?: SortOrder
    percentqt?: SortOrder
  }

  export type s_transmuteCountOrderByAggregateInput = {
    id?: SortOrder
    lowerl?: SortOrder
    upperl?: SortOrder
    transmuted?: SortOrder
  }

  export type s_transmuteAvgOrderByAggregateInput = {
    id?: SortOrder
    lowerl?: SortOrder
    upperl?: SortOrder
    transmuted?: SortOrder
  }

  export type s_transmuteMaxOrderByAggregateInput = {
    id?: SortOrder
    lowerl?: SortOrder
    upperl?: SortOrder
    transmuted?: SortOrder
  }

  export type s_transmuteMinOrderByAggregateInput = {
    id?: SortOrder
    lowerl?: SortOrder
    upperl?: SortOrder
    transmuted?: SortOrder
  }

  export type s_transmuteSumOrderByAggregateInput = {
    id?: SortOrder
    lowerl?: SortOrder
    upperl?: SortOrder
    transmuted?: SortOrder
  }

  export type s_verificationsOrderByRelevanceInput = {
    fields: s_verificationsOrderByRelevanceFieldEnum | s_verificationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type s_verificationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    section?: SortOrder
    grade?: SortOrder
    subject?: SortOrder
    request_unlock?: SortOrder
    flag?: SortOrder
    created_at?: SortOrder
  }

  export type s_verificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    request_unlock?: SortOrder
    flag?: SortOrder
  }

  export type s_verificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    section?: SortOrder
    grade?: SortOrder
    subject?: SortOrder
    request_unlock?: SortOrder
    flag?: SortOrder
    created_at?: SortOrder
  }

  export type s_verificationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    section?: SortOrder
    grade?: SortOrder
    subject?: SortOrder
    request_unlock?: SortOrder
    flag?: SortOrder
    created_at?: SortOrder
  }

  export type s_verificationsSumOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    request_unlock?: SortOrder
    flag?: SortOrder
  }

  export type sales_historyOrderByRelevanceInput = {
    fields: sales_historyOrderByRelevanceFieldEnum | sales_historyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sales_historyCountOrderByAggregateInput = {
    sale_id?: SortOrder
    buyer_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    sale_date?: SortOrder
    rfid?: SortOrder
  }

  export type sales_historyAvgOrderByAggregateInput = {
    sale_id?: SortOrder
    buyer_id?: SortOrder
    quantity?: SortOrder
    rfid?: SortOrder
  }

  export type sales_historyMaxOrderByAggregateInput = {
    sale_id?: SortOrder
    buyer_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    sale_date?: SortOrder
    rfid?: SortOrder
  }

  export type sales_historyMinOrderByAggregateInput = {
    sale_id?: SortOrder
    buyer_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    sale_date?: SortOrder
    rfid?: SortOrder
  }

  export type sales_historySumOrderByAggregateInput = {
    sale_id?: SortOrder
    buyer_id?: SortOrder
    quantity?: SortOrder
    rfid?: SortOrder
  }

  export type scheduleOrderByRelevanceInput = {
    fields: scheduleOrderByRelevanceFieldEnum | scheduleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type scheduleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type scheduleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type scheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type scheduleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type scheduleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type studentdetailsOrderByRelevanceInput = {
    fields: studentdetailsOrderByRelevanceFieldEnum | studentdetailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type studentdetailsCountOrderByAggregateInput = {
    id?: SortOrder
    uniqid?: SortOrder
    visa?: SortOrder
    father?: SortOrder
    fathermail?: SortOrder
    fathernumber?: SortOrder
    fatherwork?: SortOrder
    fcompany?: SortOrder
    fsalary?: SortOrder
    mother?: SortOrder
    mothermail?: SortOrder
    mothernumber?: SortOrder
    motherwork?: SortOrder
    mcompany?: SortOrder
    msalary?: SortOrder
    street?: SortOrder
    barangay?: SortOrder
    city?: SortOrder
    postal?: SortOrder
    englishrw?: SortOrder
    englishv?: SortOrder
    languages?: SortOrder
    advclasses?: SortOrder
    remedial?: SortOrder
    skill?: SortOrder
    ashtma?: SortOrder
    ashtmar?: SortOrder
    allergy?: SortOrder
    allergyr?: SortOrder
    drug?: SortOrder
    drugr?: SortOrder
    speech?: SortOrder
    speechr?: SortOrder
    vision?: SortOrder
    visionr?: SortOrder
    hearing?: SortOrder
    hearingr?: SortOrder
    adhd?: SortOrder
    adhdr?: SortOrder
    healthcond?: SortOrder
    hospitalization?: SortOrder
    injuries?: SortOrder
    medication?: SortOrder
    general?: SortOrder
    generaldets?: SortOrder
    psych?: SortOrder
    psychdets?: SortOrder
    minor?: SortOrder
    emergency?: SortOrder
    hospital?: SortOrder
    otc?: SortOrder
    conforme?: SortOrder
    conformedate?: SortOrder
  }

  export type studentdetailsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type studentdetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    uniqid?: SortOrder
    visa?: SortOrder
    father?: SortOrder
    fathermail?: SortOrder
    fathernumber?: SortOrder
    fatherwork?: SortOrder
    fcompany?: SortOrder
    fsalary?: SortOrder
    mother?: SortOrder
    mothermail?: SortOrder
    mothernumber?: SortOrder
    motherwork?: SortOrder
    mcompany?: SortOrder
    msalary?: SortOrder
    street?: SortOrder
    barangay?: SortOrder
    city?: SortOrder
    postal?: SortOrder
    englishrw?: SortOrder
    englishv?: SortOrder
    languages?: SortOrder
    advclasses?: SortOrder
    remedial?: SortOrder
    skill?: SortOrder
    ashtma?: SortOrder
    ashtmar?: SortOrder
    allergy?: SortOrder
    allergyr?: SortOrder
    drug?: SortOrder
    drugr?: SortOrder
    speech?: SortOrder
    speechr?: SortOrder
    vision?: SortOrder
    visionr?: SortOrder
    hearing?: SortOrder
    hearingr?: SortOrder
    adhd?: SortOrder
    adhdr?: SortOrder
    healthcond?: SortOrder
    hospitalization?: SortOrder
    injuries?: SortOrder
    medication?: SortOrder
    general?: SortOrder
    generaldets?: SortOrder
    psych?: SortOrder
    psychdets?: SortOrder
    minor?: SortOrder
    emergency?: SortOrder
    hospital?: SortOrder
    otc?: SortOrder
    conforme?: SortOrder
    conformedate?: SortOrder
  }

  export type studentdetailsMinOrderByAggregateInput = {
    id?: SortOrder
    uniqid?: SortOrder
    visa?: SortOrder
    father?: SortOrder
    fathermail?: SortOrder
    fathernumber?: SortOrder
    fatherwork?: SortOrder
    fcompany?: SortOrder
    fsalary?: SortOrder
    mother?: SortOrder
    mothermail?: SortOrder
    mothernumber?: SortOrder
    motherwork?: SortOrder
    mcompany?: SortOrder
    msalary?: SortOrder
    street?: SortOrder
    barangay?: SortOrder
    city?: SortOrder
    postal?: SortOrder
    englishrw?: SortOrder
    englishv?: SortOrder
    languages?: SortOrder
    advclasses?: SortOrder
    remedial?: SortOrder
    skill?: SortOrder
    ashtma?: SortOrder
    ashtmar?: SortOrder
    allergy?: SortOrder
    allergyr?: SortOrder
    drug?: SortOrder
    drugr?: SortOrder
    speech?: SortOrder
    speechr?: SortOrder
    vision?: SortOrder
    visionr?: SortOrder
    hearing?: SortOrder
    hearingr?: SortOrder
    adhd?: SortOrder
    adhdr?: SortOrder
    healthcond?: SortOrder
    hospitalization?: SortOrder
    injuries?: SortOrder
    medication?: SortOrder
    general?: SortOrder
    generaldets?: SortOrder
    psych?: SortOrder
    psychdets?: SortOrder
    minor?: SortOrder
    emergency?: SortOrder
    hospital?: SortOrder
    otc?: SortOrder
    conforme?: SortOrder
    conformedate?: SortOrder
  }

  export type studentdetailsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type timeoffOrderByRelevanceInput = {
    fields: timeoffOrderByRelevanceFieldEnum | timeoffOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type timeoffCountOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    leavetype?: SortOrder
    datefrom?: SortOrder
    dateto?: SortOrder
    ishalfday?: SortOrder
    details?: SortOrder
    credit?: SortOrder
    approval?: SortOrder
    approvedate?: SortOrder
    hrnote?: SortOrder
    hrdate?: SortOrder
  }

  export type timeoffAvgOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    ishalfday?: SortOrder
    credit?: SortOrder
  }

  export type timeoffMaxOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    leavetype?: SortOrder
    datefrom?: SortOrder
    dateto?: SortOrder
    ishalfday?: SortOrder
    details?: SortOrder
    credit?: SortOrder
    approval?: SortOrder
    approvedate?: SortOrder
    hrnote?: SortOrder
    hrdate?: SortOrder
  }

  export type timeoffMinOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    leavetype?: SortOrder
    datefrom?: SortOrder
    dateto?: SortOrder
    ishalfday?: SortOrder
    details?: SortOrder
    credit?: SortOrder
    approval?: SortOrder
    approvedate?: SortOrder
    hrnote?: SortOrder
    hrdate?: SortOrder
  }

  export type timeoffSumOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    ishalfday?: SortOrder
    credit?: SortOrder
  }

  export type type_of_productsOrderByRelevanceInput = {
    fields: type_of_productsOrderByRelevanceFieldEnum | type_of_productsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type type_of_productsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type type_of_productsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type type_of_productsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type type_of_productsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type type_of_productsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type uniformOrderByRelevanceInput = {
    fields: uniformOrderByRelevanceFieldEnum | uniformOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type uniformCountOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    size?: SortOrder
    basic?: SortOrder
    activity?: SortOrder
    formal?: SortOrder
    qtybasic?: SortOrder
    qtyact?: SortOrder
    qtyform?: SortOrder
    iscomplete?: SortOrder
    lasttouch?: SortOrder
    dateordered?: SortOrder
    datereleased?: SortOrder
    comment?: SortOrder
  }

  export type uniformAvgOrderByAggregateInput = {
    id?: SortOrder
    iscomplete?: SortOrder
  }

  export type uniformMaxOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    size?: SortOrder
    basic?: SortOrder
    activity?: SortOrder
    formal?: SortOrder
    qtybasic?: SortOrder
    qtyact?: SortOrder
    qtyform?: SortOrder
    iscomplete?: SortOrder
    lasttouch?: SortOrder
    dateordered?: SortOrder
    datereleased?: SortOrder
    comment?: SortOrder
  }

  export type uniformMinOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    size?: SortOrder
    basic?: SortOrder
    activity?: SortOrder
    formal?: SortOrder
    qtybasic?: SortOrder
    qtyact?: SortOrder
    qtyform?: SortOrder
    iscomplete?: SortOrder
    lasttouch?: SortOrder
    dateordered?: SortOrder
    datereleased?: SortOrder
    comment?: SortOrder
  }

  export type uniformSumOrderByAggregateInput = {
    id?: SortOrder
    iscomplete?: SortOrder
  }

  export type uniform_inventoryOrderByRelevanceInput = {
    fields: uniform_inventoryOrderByRelevanceFieldEnum | uniform_inventoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type uniform_inventoryCountOrderByAggregateInput = {
    id?: SortOrder
    uniform_type_id?: SortOrder
    uniform_size_id?: SortOrder
    qty?: SortOrder
    gender?: SortOrder
    date?: SortOrder
    user?: SortOrder
  }

  export type uniform_inventoryAvgOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
  }

  export type uniform_inventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    uniform_type_id?: SortOrder
    uniform_size_id?: SortOrder
    qty?: SortOrder
    gender?: SortOrder
    date?: SortOrder
    user?: SortOrder
  }

  export type uniform_inventoryMinOrderByAggregateInput = {
    id?: SortOrder
    uniform_type_id?: SortOrder
    uniform_size_id?: SortOrder
    qty?: SortOrder
    gender?: SortOrder
    date?: SortOrder
    user?: SortOrder
  }

  export type uniform_inventorySumOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
  }

  export type uniform_issuedOrderByRelevanceInput = {
    fields: uniform_issuedOrderByRelevanceFieldEnum | uniform_issuedOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type uniform_issuedCountOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    releasedby?: SortOrder
    uniform_type_id?: SortOrder
    uniform_size_id?: SortOrder
    date?: SortOrder
  }

  export type uniform_issuedAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type uniform_issuedMaxOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    releasedby?: SortOrder
    uniform_type_id?: SortOrder
    uniform_size_id?: SortOrder
    date?: SortOrder
  }

  export type uniform_issuedMinOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    releasedby?: SortOrder
    uniform_type_id?: SortOrder
    uniform_size_id?: SortOrder
    date?: SortOrder
  }

  export type uniform_issuedSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type uniform_sizesOrderByRelevanceInput = {
    fields: uniform_sizesOrderByRelevanceFieldEnum | uniform_sizesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type uniform_sizesCountOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    created_at?: SortOrder
  }

  export type uniform_sizesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type uniform_sizesMaxOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    created_at?: SortOrder
  }

  export type uniform_sizesMinOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    created_at?: SortOrder
  }

  export type uniform_sizesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type uniform_typesOrderByRelevanceInput = {
    fields: uniform_typesOrderByRelevanceFieldEnum | uniform_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type uniform_typesCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
  }

  export type uniform_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type uniform_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
  }

  export type uniform_typesMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
  }

  export type uniform_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    type?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    is_situation?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    nationalities?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    religion?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    empno?: SortOrder
    isESL?: SortOrder
    house?: SortOrder
    isofficial?: SortOrder
    isEnrolledInAfterSchool?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    isactive?: SortOrder
    level?: SortOrder
    status?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    isESL?: SortOrder
    isofficial?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    type?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    is_situation?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    nationalities?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    religion?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    empno?: SortOrder
    isESL?: SortOrder
    house?: SortOrder
    isofficial?: SortOrder
    isEnrolledInAfterSchool?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    type?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    is_situation?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    nationalities?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    religion?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    empno?: SortOrder
    isESL?: SortOrder
    house?: SortOrder
    isofficial?: SortOrder
    isEnrolledInAfterSchool?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    isactive?: SortOrder
    level?: SortOrder
    status?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    isESL?: SortOrder
    isofficial?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type user22OrderByRelevanceInput = {
    fields: user22OrderByRelevanceFieldEnum | user22OrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type user22CountOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
  }

  export type user22AvgOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    isactive?: SortOrder
    level?: SortOrder
    status?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
  }

  export type user22MaxOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
  }

  export type user22MinOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
  }

  export type user22SumOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    isactive?: SortOrder
    level?: SortOrder
    status?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
  }

  export type users24OrderByRelevanceInput = {
    fields: users24OrderByRelevanceFieldEnum | users24OrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type users24CountOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    type?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    is_situation?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    nationalities?: SortOrder
    religion?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    empno?: SortOrder
    isESL?: SortOrder
    house?: SortOrder
    isofficial?: SortOrder
  }

  export type users24AvgOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    isactive?: SortOrder
    level?: SortOrder
    status?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    isESL?: SortOrder
    isofficial?: SortOrder
  }

  export type users24MaxOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    type?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    is_situation?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    nationalities?: SortOrder
    religion?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    empno?: SortOrder
    isESL?: SortOrder
    house?: SortOrder
    isofficial?: SortOrder
  }

  export type users24MinOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    type?: SortOrder
    gender?: SortOrder
    position?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    vacchist?: SortOrder
    photo?: SortOrder
    manager?: SortOrder
    isactive?: SortOrder
    is_situation?: SortOrder
    username?: SortOrder
    password?: SortOrder
    level?: SortOrder
    status?: SortOrder
    prevsch?: SortOrder
    prevschcountry?: SortOrder
    lrn?: SortOrder
    uniqid?: SortOrder
    tf?: SortOrder
    country?: SortOrder
    nationality?: SortOrder
    nationalities?: SortOrder
    religion?: SortOrder
    guardianname?: SortOrder
    guardianemail?: SortOrder
    guardianphone?: SortOrder
    referral?: SortOrder
    apptype?: SortOrder
    sy?: SortOrder
    strand?: SortOrder
    visa?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    empno?: SortOrder
    isESL?: SortOrder
    house?: SortOrder
    isofficial?: SortOrder
  }

  export type users24SumOrderByAggregateInput = {
    id?: SortOrder
    rfid?: SortOrder
    isactive?: SortOrder
    level?: SortOrder
    status?: SortOrder
    earlybird?: SortOrder
    modelrelease?: SortOrder
    feepolicy?: SortOrder
    refund?: SortOrder
    tos?: SortOrder
    isESL?: SortOrder
    isofficial?: SortOrder
  }

  export type visitorlogOrderByRelevanceInput = {
    fields: visitorlogOrderByRelevanceFieldEnum | visitorlogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type visitorlogCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rfid?: SortOrder
    comment?: SortOrder
    registerdate?: SortOrder
    status?: SortOrder
  }

  export type visitorlogAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type visitorlogMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rfid?: SortOrder
    comment?: SortOrder
    registerdate?: SortOrder
    status?: SortOrder
  }

  export type visitorlogMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rfid?: SortOrder
    comment?: SortOrder
    registerdate?: SortOrder
    status?: SortOrder
  }

  export type visitorlogSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type wispayOrderByRelevanceInput = {
    fields: wispayOrderByRelevanceFieldEnum | wispayOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type wispayCountOrderByAggregateInput = {
    id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    rfid?: SortOrder
    empid?: SortOrder
    username?: SortOrder
    refcode?: SortOrder
    transdate?: SortOrder
    processedby?: SortOrder
    product_type?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    isAfterSchoolPayment?: SortOrder
  }

  export type wispayAvgOrderByAggregateInput = {
    id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    rfid?: SortOrder
    quantity?: SortOrder
  }

  export type wispayMaxOrderByAggregateInput = {
    id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    rfid?: SortOrder
    empid?: SortOrder
    username?: SortOrder
    refcode?: SortOrder
    transdate?: SortOrder
    processedby?: SortOrder
    product_type?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    isAfterSchoolPayment?: SortOrder
  }

  export type wispayMinOrderByAggregateInput = {
    id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    rfid?: SortOrder
    empid?: SortOrder
    username?: SortOrder
    refcode?: SortOrder
    transdate?: SortOrder
    processedby?: SortOrder
    product_type?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    isAfterSchoolPayment?: SortOrder
  }

  export type wispaySumOrderByAggregateInput = {
    id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    rfid?: SortOrder
    quantity?: SortOrder
  }

  export type afterschoolactivityCreateNestedOneWithoutActivitysessionInput = {
    create?: XOR<afterschoolactivityCreateWithoutActivitysessionInput, afterschoolactivityUncheckedCreateWithoutActivitysessionInput>
    connectOrCreate?: afterschoolactivityCreateOrConnectWithoutActivitysessionInput
    connect?: afterschoolactivityWhereUniqueInput
  }

  export type attendanceCreateNestedManyWithoutActivitysessionInput = {
    create?: XOR<attendanceCreateWithoutActivitysessionInput, attendanceUncheckedCreateWithoutActivitysessionInput> | attendanceCreateWithoutActivitysessionInput[] | attendanceUncheckedCreateWithoutActivitysessionInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutActivitysessionInput | attendanceCreateOrConnectWithoutActivitysessionInput[]
    createMany?: attendanceCreateManyActivitysessionInputEnvelope
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
  }

  export type attendanceUncheckedCreateNestedManyWithoutActivitysessionInput = {
    create?: XOR<attendanceCreateWithoutActivitysessionInput, attendanceUncheckedCreateWithoutActivitysessionInput> | attendanceCreateWithoutActivitysessionInput[] | attendanceUncheckedCreateWithoutActivitysessionInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutActivitysessionInput | attendanceCreateOrConnectWithoutActivitysessionInput[]
    createMany?: attendanceCreateManyActivitysessionInputEnvelope
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type afterschoolactivityUpdateOneRequiredWithoutActivitysessionNestedInput = {
    create?: XOR<afterschoolactivityCreateWithoutActivitysessionInput, afterschoolactivityUncheckedCreateWithoutActivitysessionInput>
    connectOrCreate?: afterschoolactivityCreateOrConnectWithoutActivitysessionInput
    upsert?: afterschoolactivityUpsertWithoutActivitysessionInput
    connect?: afterschoolactivityWhereUniqueInput
    update?: XOR<XOR<afterschoolactivityUpdateToOneWithWhereWithoutActivitysessionInput, afterschoolactivityUpdateWithoutActivitysessionInput>, afterschoolactivityUncheckedUpdateWithoutActivitysessionInput>
  }

  export type attendanceUpdateManyWithoutActivitysessionNestedInput = {
    create?: XOR<attendanceCreateWithoutActivitysessionInput, attendanceUncheckedCreateWithoutActivitysessionInput> | attendanceCreateWithoutActivitysessionInput[] | attendanceUncheckedCreateWithoutActivitysessionInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutActivitysessionInput | attendanceCreateOrConnectWithoutActivitysessionInput[]
    upsert?: attendanceUpsertWithWhereUniqueWithoutActivitysessionInput | attendanceUpsertWithWhereUniqueWithoutActivitysessionInput[]
    createMany?: attendanceCreateManyActivitysessionInputEnvelope
    set?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    disconnect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    delete?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    update?: attendanceUpdateWithWhereUniqueWithoutActivitysessionInput | attendanceUpdateWithWhereUniqueWithoutActivitysessionInput[]
    updateMany?: attendanceUpdateManyWithWhereWithoutActivitysessionInput | attendanceUpdateManyWithWhereWithoutActivitysessionInput[]
    deleteMany?: attendanceScalarWhereInput | attendanceScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type attendanceUncheckedUpdateManyWithoutActivitysessionNestedInput = {
    create?: XOR<attendanceCreateWithoutActivitysessionInput, attendanceUncheckedCreateWithoutActivitysessionInput> | attendanceCreateWithoutActivitysessionInput[] | attendanceUncheckedCreateWithoutActivitysessionInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutActivitysessionInput | attendanceCreateOrConnectWithoutActivitysessionInput[]
    upsert?: attendanceUpsertWithWhereUniqueWithoutActivitysessionInput | attendanceUpsertWithWhereUniqueWithoutActivitysessionInput[]
    createMany?: attendanceCreateManyActivitysessionInputEnvelope
    set?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    disconnect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    delete?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    update?: attendanceUpdateWithWhereUniqueWithoutActivitysessionInput | attendanceUpdateWithWhereUniqueWithoutActivitysessionInput[]
    updateMany?: attendanceUpdateManyWithWhereWithoutActivitysessionInput | attendanceUpdateManyWithWhereWithoutActivitysessionInput[]
    deleteMany?: attendanceScalarWhereInput | attendanceScalarWhereInput[]
  }

  export type activitysessionCreateNestedManyWithoutAfterschoolactivityInput = {
    create?: XOR<activitysessionCreateWithoutAfterschoolactivityInput, activitysessionUncheckedCreateWithoutAfterschoolactivityInput> | activitysessionCreateWithoutAfterschoolactivityInput[] | activitysessionUncheckedCreateWithoutAfterschoolactivityInput[]
    connectOrCreate?: activitysessionCreateOrConnectWithoutAfterschoolactivityInput | activitysessionCreateOrConnectWithoutAfterschoolactivityInput[]
    createMany?: activitysessionCreateManyAfterschoolactivityInputEnvelope
    connect?: activitysessionWhereUniqueInput | activitysessionWhereUniqueInput[]
  }

  export type enrolledactivityCreateNestedManyWithoutAfterschoolactivityInput = {
    create?: XOR<enrolledactivityCreateWithoutAfterschoolactivityInput, enrolledactivityUncheckedCreateWithoutAfterschoolactivityInput> | enrolledactivityCreateWithoutAfterschoolactivityInput[] | enrolledactivityUncheckedCreateWithoutAfterschoolactivityInput[]
    connectOrCreate?: enrolledactivityCreateOrConnectWithoutAfterschoolactivityInput | enrolledactivityCreateOrConnectWithoutAfterschoolactivityInput[]
    createMany?: enrolledactivityCreateManyAfterschoolactivityInputEnvelope
    connect?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
  }

  export type activitysessionUncheckedCreateNestedManyWithoutAfterschoolactivityInput = {
    create?: XOR<activitysessionCreateWithoutAfterschoolactivityInput, activitysessionUncheckedCreateWithoutAfterschoolactivityInput> | activitysessionCreateWithoutAfterschoolactivityInput[] | activitysessionUncheckedCreateWithoutAfterschoolactivityInput[]
    connectOrCreate?: activitysessionCreateOrConnectWithoutAfterschoolactivityInput | activitysessionCreateOrConnectWithoutAfterschoolactivityInput[]
    createMany?: activitysessionCreateManyAfterschoolactivityInputEnvelope
    connect?: activitysessionWhereUniqueInput | activitysessionWhereUniqueInput[]
  }

  export type enrolledactivityUncheckedCreateNestedManyWithoutAfterschoolactivityInput = {
    create?: XOR<enrolledactivityCreateWithoutAfterschoolactivityInput, enrolledactivityUncheckedCreateWithoutAfterschoolactivityInput> | enrolledactivityCreateWithoutAfterschoolactivityInput[] | enrolledactivityUncheckedCreateWithoutAfterschoolactivityInput[]
    connectOrCreate?: enrolledactivityCreateOrConnectWithoutAfterschoolactivityInput | enrolledactivityCreateOrConnectWithoutAfterschoolactivityInput[]
    createMany?: enrolledactivityCreateManyAfterschoolactivityInputEnvelope
    connect?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type activitysessionUpdateManyWithoutAfterschoolactivityNestedInput = {
    create?: XOR<activitysessionCreateWithoutAfterschoolactivityInput, activitysessionUncheckedCreateWithoutAfterschoolactivityInput> | activitysessionCreateWithoutAfterschoolactivityInput[] | activitysessionUncheckedCreateWithoutAfterschoolactivityInput[]
    connectOrCreate?: activitysessionCreateOrConnectWithoutAfterschoolactivityInput | activitysessionCreateOrConnectWithoutAfterschoolactivityInput[]
    upsert?: activitysessionUpsertWithWhereUniqueWithoutAfterschoolactivityInput | activitysessionUpsertWithWhereUniqueWithoutAfterschoolactivityInput[]
    createMany?: activitysessionCreateManyAfterschoolactivityInputEnvelope
    set?: activitysessionWhereUniqueInput | activitysessionWhereUniqueInput[]
    disconnect?: activitysessionWhereUniqueInput | activitysessionWhereUniqueInput[]
    delete?: activitysessionWhereUniqueInput | activitysessionWhereUniqueInput[]
    connect?: activitysessionWhereUniqueInput | activitysessionWhereUniqueInput[]
    update?: activitysessionUpdateWithWhereUniqueWithoutAfterschoolactivityInput | activitysessionUpdateWithWhereUniqueWithoutAfterschoolactivityInput[]
    updateMany?: activitysessionUpdateManyWithWhereWithoutAfterschoolactivityInput | activitysessionUpdateManyWithWhereWithoutAfterschoolactivityInput[]
    deleteMany?: activitysessionScalarWhereInput | activitysessionScalarWhereInput[]
  }

  export type enrolledactivityUpdateManyWithoutAfterschoolactivityNestedInput = {
    create?: XOR<enrolledactivityCreateWithoutAfterschoolactivityInput, enrolledactivityUncheckedCreateWithoutAfterschoolactivityInput> | enrolledactivityCreateWithoutAfterschoolactivityInput[] | enrolledactivityUncheckedCreateWithoutAfterschoolactivityInput[]
    connectOrCreate?: enrolledactivityCreateOrConnectWithoutAfterschoolactivityInput | enrolledactivityCreateOrConnectWithoutAfterschoolactivityInput[]
    upsert?: enrolledactivityUpsertWithWhereUniqueWithoutAfterschoolactivityInput | enrolledactivityUpsertWithWhereUniqueWithoutAfterschoolactivityInput[]
    createMany?: enrolledactivityCreateManyAfterschoolactivityInputEnvelope
    set?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    disconnect?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    delete?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    connect?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    update?: enrolledactivityUpdateWithWhereUniqueWithoutAfterschoolactivityInput | enrolledactivityUpdateWithWhereUniqueWithoutAfterschoolactivityInput[]
    updateMany?: enrolledactivityUpdateManyWithWhereWithoutAfterschoolactivityInput | enrolledactivityUpdateManyWithWhereWithoutAfterschoolactivityInput[]
    deleteMany?: enrolledactivityScalarWhereInput | enrolledactivityScalarWhereInput[]
  }

  export type activitysessionUncheckedUpdateManyWithoutAfterschoolactivityNestedInput = {
    create?: XOR<activitysessionCreateWithoutAfterschoolactivityInput, activitysessionUncheckedCreateWithoutAfterschoolactivityInput> | activitysessionCreateWithoutAfterschoolactivityInput[] | activitysessionUncheckedCreateWithoutAfterschoolactivityInput[]
    connectOrCreate?: activitysessionCreateOrConnectWithoutAfterschoolactivityInput | activitysessionCreateOrConnectWithoutAfterschoolactivityInput[]
    upsert?: activitysessionUpsertWithWhereUniqueWithoutAfterschoolactivityInput | activitysessionUpsertWithWhereUniqueWithoutAfterschoolactivityInput[]
    createMany?: activitysessionCreateManyAfterschoolactivityInputEnvelope
    set?: activitysessionWhereUniqueInput | activitysessionWhereUniqueInput[]
    disconnect?: activitysessionWhereUniqueInput | activitysessionWhereUniqueInput[]
    delete?: activitysessionWhereUniqueInput | activitysessionWhereUniqueInput[]
    connect?: activitysessionWhereUniqueInput | activitysessionWhereUniqueInput[]
    update?: activitysessionUpdateWithWhereUniqueWithoutAfterschoolactivityInput | activitysessionUpdateWithWhereUniqueWithoutAfterschoolactivityInput[]
    updateMany?: activitysessionUpdateManyWithWhereWithoutAfterschoolactivityInput | activitysessionUpdateManyWithWhereWithoutAfterschoolactivityInput[]
    deleteMany?: activitysessionScalarWhereInput | activitysessionScalarWhereInput[]
  }

  export type enrolledactivityUncheckedUpdateManyWithoutAfterschoolactivityNestedInput = {
    create?: XOR<enrolledactivityCreateWithoutAfterschoolactivityInput, enrolledactivityUncheckedCreateWithoutAfterschoolactivityInput> | enrolledactivityCreateWithoutAfterschoolactivityInput[] | enrolledactivityUncheckedCreateWithoutAfterschoolactivityInput[]
    connectOrCreate?: enrolledactivityCreateOrConnectWithoutAfterschoolactivityInput | enrolledactivityCreateOrConnectWithoutAfterschoolactivityInput[]
    upsert?: enrolledactivityUpsertWithWhereUniqueWithoutAfterschoolactivityInput | enrolledactivityUpsertWithWhereUniqueWithoutAfterschoolactivityInput[]
    createMany?: enrolledactivityCreateManyAfterschoolactivityInputEnvelope
    set?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    disconnect?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    delete?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    connect?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    update?: enrolledactivityUpdateWithWhereUniqueWithoutAfterschoolactivityInput | enrolledactivityUpdateWithWhereUniqueWithoutAfterschoolactivityInput[]
    updateMany?: enrolledactivityUpdateManyWithWhereWithoutAfterschoolactivityInput | enrolledactivityUpdateManyWithWhereWithoutAfterschoolactivityInput[]
    deleteMany?: enrolledactivityScalarWhereInput | enrolledactivityScalarWhereInput[]
  }

  export type activitysessionCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<activitysessionCreateWithoutAttendanceInput, activitysessionUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: activitysessionCreateOrConnectWithoutAttendanceInput
    connect?: activitysessionWhereUniqueInput
  }

  export type userCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<userCreateWithoutAttendanceInput, userUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: userCreateOrConnectWithoutAttendanceInput
    connect?: userWhereUniqueInput
  }

  export type activitysessionUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<activitysessionCreateWithoutAttendanceInput, activitysessionUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: activitysessionCreateOrConnectWithoutAttendanceInput
    upsert?: activitysessionUpsertWithoutAttendanceInput
    connect?: activitysessionWhereUniqueInput
    update?: XOR<XOR<activitysessionUpdateToOneWithWhereWithoutAttendanceInput, activitysessionUpdateWithoutAttendanceInput>, activitysessionUncheckedUpdateWithoutAttendanceInput>
  }

  export type userUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<userCreateWithoutAttendanceInput, userUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: userCreateOrConnectWithoutAttendanceInput
    upsert?: userUpsertWithoutAttendanceInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAttendanceInput, userUpdateWithoutAttendanceInput>, userUncheckedUpdateWithoutAttendanceInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type afterschoolactivityCreateNestedOneWithoutEnrolledactivityInput = {
    create?: XOR<afterschoolactivityCreateWithoutEnrolledactivityInput, afterschoolactivityUncheckedCreateWithoutEnrolledactivityInput>
    connectOrCreate?: afterschoolactivityCreateOrConnectWithoutEnrolledactivityInput
    connect?: afterschoolactivityWhereUniqueInput
  }

  export type userCreateNestedOneWithoutEnrolledactivityInput = {
    create?: XOR<userCreateWithoutEnrolledactivityInput, userUncheckedCreateWithoutEnrolledactivityInput>
    connectOrCreate?: userCreateOrConnectWithoutEnrolledactivityInput
    connect?: userWhereUniqueInput
  }

  export type afterschoolactivityUpdateOneRequiredWithoutEnrolledactivityNestedInput = {
    create?: XOR<afterschoolactivityCreateWithoutEnrolledactivityInput, afterschoolactivityUncheckedCreateWithoutEnrolledactivityInput>
    connectOrCreate?: afterschoolactivityCreateOrConnectWithoutEnrolledactivityInput
    upsert?: afterschoolactivityUpsertWithoutEnrolledactivityInput
    connect?: afterschoolactivityWhereUniqueInput
    update?: XOR<XOR<afterschoolactivityUpdateToOneWithWhereWithoutEnrolledactivityInput, afterschoolactivityUpdateWithoutEnrolledactivityInput>, afterschoolactivityUncheckedUpdateWithoutEnrolledactivityInput>
  }

  export type userUpdateOneRequiredWithoutEnrolledactivityNestedInput = {
    create?: XOR<userCreateWithoutEnrolledactivityInput, userUncheckedCreateWithoutEnrolledactivityInput>
    connectOrCreate?: userCreateOrConnectWithoutEnrolledactivityInput
    upsert?: userUpsertWithoutEnrolledactivityInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutEnrolledactivityInput, userUpdateWithoutEnrolledactivityInput>, userUncheckedUpdateWithoutEnrolledactivityInput>
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type attendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<attendanceCreateWithoutUserInput, attendanceUncheckedCreateWithoutUserInput> | attendanceCreateWithoutUserInput[] | attendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutUserInput | attendanceCreateOrConnectWithoutUserInput[]
    createMany?: attendanceCreateManyUserInputEnvelope
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
  }

  export type enrolledactivityCreateNestedManyWithoutUserInput = {
    create?: XOR<enrolledactivityCreateWithoutUserInput, enrolledactivityUncheckedCreateWithoutUserInput> | enrolledactivityCreateWithoutUserInput[] | enrolledactivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: enrolledactivityCreateOrConnectWithoutUserInput | enrolledactivityCreateOrConnectWithoutUserInput[]
    createMany?: enrolledactivityCreateManyUserInputEnvelope
    connect?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
  }

  export type attendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<attendanceCreateWithoutUserInput, attendanceUncheckedCreateWithoutUserInput> | attendanceCreateWithoutUserInput[] | attendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutUserInput | attendanceCreateOrConnectWithoutUserInput[]
    createMany?: attendanceCreateManyUserInputEnvelope
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
  }

  export type enrolledactivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<enrolledactivityCreateWithoutUserInput, enrolledactivityUncheckedCreateWithoutUserInput> | enrolledactivityCreateWithoutUserInput[] | enrolledactivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: enrolledactivityCreateOrConnectWithoutUserInput | enrolledactivityCreateOrConnectWithoutUserInput[]
    createMany?: enrolledactivityCreateManyUserInputEnvelope
    connect?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type attendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<attendanceCreateWithoutUserInput, attendanceUncheckedCreateWithoutUserInput> | attendanceCreateWithoutUserInput[] | attendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutUserInput | attendanceCreateOrConnectWithoutUserInput[]
    upsert?: attendanceUpsertWithWhereUniqueWithoutUserInput | attendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: attendanceCreateManyUserInputEnvelope
    set?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    disconnect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    delete?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    update?: attendanceUpdateWithWhereUniqueWithoutUserInput | attendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: attendanceUpdateManyWithWhereWithoutUserInput | attendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: attendanceScalarWhereInput | attendanceScalarWhereInput[]
  }

  export type enrolledactivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<enrolledactivityCreateWithoutUserInput, enrolledactivityUncheckedCreateWithoutUserInput> | enrolledactivityCreateWithoutUserInput[] | enrolledactivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: enrolledactivityCreateOrConnectWithoutUserInput | enrolledactivityCreateOrConnectWithoutUserInput[]
    upsert?: enrolledactivityUpsertWithWhereUniqueWithoutUserInput | enrolledactivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: enrolledactivityCreateManyUserInputEnvelope
    set?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    disconnect?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    delete?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    connect?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    update?: enrolledactivityUpdateWithWhereUniqueWithoutUserInput | enrolledactivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: enrolledactivityUpdateManyWithWhereWithoutUserInput | enrolledactivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: enrolledactivityScalarWhereInput | enrolledactivityScalarWhereInput[]
  }

  export type attendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<attendanceCreateWithoutUserInput, attendanceUncheckedCreateWithoutUserInput> | attendanceCreateWithoutUserInput[] | attendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutUserInput | attendanceCreateOrConnectWithoutUserInput[]
    upsert?: attendanceUpsertWithWhereUniqueWithoutUserInput | attendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: attendanceCreateManyUserInputEnvelope
    set?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    disconnect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    delete?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    update?: attendanceUpdateWithWhereUniqueWithoutUserInput | attendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: attendanceUpdateManyWithWhereWithoutUserInput | attendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: attendanceScalarWhereInput | attendanceScalarWhereInput[]
  }

  export type enrolledactivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<enrolledactivityCreateWithoutUserInput, enrolledactivityUncheckedCreateWithoutUserInput> | enrolledactivityCreateWithoutUserInput[] | enrolledactivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: enrolledactivityCreateOrConnectWithoutUserInput | enrolledactivityCreateOrConnectWithoutUserInput[]
    upsert?: enrolledactivityUpsertWithWhereUniqueWithoutUserInput | enrolledactivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: enrolledactivityCreateManyUserInputEnvelope
    set?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    disconnect?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    delete?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    connect?: enrolledactivityWhereUniqueInput | enrolledactivityWhereUniqueInput[]
    update?: enrolledactivityUpdateWithWhereUniqueWithoutUserInput | enrolledactivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: enrolledactivityUpdateManyWithWhereWithoutUserInput | enrolledactivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: enrolledactivityScalarWhereInput | enrolledactivityScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type afterschoolactivityCreateWithoutActivitysessionInput = {
    name: string
    description?: string | null
    dayOfWeek: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coachName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    photo?: string | null
    enrolledactivity?: enrolledactivityCreateNestedManyWithoutAfterschoolactivityInput
  }

  export type afterschoolactivityUncheckedCreateWithoutActivitysessionInput = {
    id?: number
    name: string
    description?: string | null
    dayOfWeek: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coachName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    photo?: string | null
    enrolledactivity?: enrolledactivityUncheckedCreateNestedManyWithoutAfterschoolactivityInput
  }

  export type afterschoolactivityCreateOrConnectWithoutActivitysessionInput = {
    where: afterschoolactivityWhereUniqueInput
    create: XOR<afterschoolactivityCreateWithoutActivitysessionInput, afterschoolactivityUncheckedCreateWithoutActivitysessionInput>
  }

  export type attendanceCreateWithoutActivitysessionInput = {
    status: string
    user: userCreateNestedOneWithoutAttendanceInput
  }

  export type attendanceUncheckedCreateWithoutActivitysessionInput = {
    id?: number
    userId: number
    status: string
  }

  export type attendanceCreateOrConnectWithoutActivitysessionInput = {
    where: attendanceWhereUniqueInput
    create: XOR<attendanceCreateWithoutActivitysessionInput, attendanceUncheckedCreateWithoutActivitysessionInput>
  }

  export type attendanceCreateManyActivitysessionInputEnvelope = {
    data: attendanceCreateManyActivitysessionInput | attendanceCreateManyActivitysessionInput[]
    skipDuplicates?: boolean
  }

  export type afterschoolactivityUpsertWithoutActivitysessionInput = {
    update: XOR<afterschoolactivityUpdateWithoutActivitysessionInput, afterschoolactivityUncheckedUpdateWithoutActivitysessionInput>
    create: XOR<afterschoolactivityCreateWithoutActivitysessionInput, afterschoolactivityUncheckedCreateWithoutActivitysessionInput>
    where?: afterschoolactivityWhereInput
  }

  export type afterschoolactivityUpdateToOneWithWhereWithoutActivitysessionInput = {
    where?: afterschoolactivityWhereInput
    data: XOR<afterschoolactivityUpdateWithoutActivitysessionInput, afterschoolactivityUncheckedUpdateWithoutActivitysessionInput>
  }

  export type afterschoolactivityUpdateWithoutActivitysessionInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coachName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledactivity?: enrolledactivityUpdateManyWithoutAfterschoolactivityNestedInput
  }

  export type afterschoolactivityUncheckedUpdateWithoutActivitysessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coachName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledactivity?: enrolledactivityUncheckedUpdateManyWithoutAfterschoolactivityNestedInput
  }

  export type attendanceUpsertWithWhereUniqueWithoutActivitysessionInput = {
    where: attendanceWhereUniqueInput
    update: XOR<attendanceUpdateWithoutActivitysessionInput, attendanceUncheckedUpdateWithoutActivitysessionInput>
    create: XOR<attendanceCreateWithoutActivitysessionInput, attendanceUncheckedCreateWithoutActivitysessionInput>
  }

  export type attendanceUpdateWithWhereUniqueWithoutActivitysessionInput = {
    where: attendanceWhereUniqueInput
    data: XOR<attendanceUpdateWithoutActivitysessionInput, attendanceUncheckedUpdateWithoutActivitysessionInput>
  }

  export type attendanceUpdateManyWithWhereWithoutActivitysessionInput = {
    where: attendanceScalarWhereInput
    data: XOR<attendanceUpdateManyMutationInput, attendanceUncheckedUpdateManyWithoutActivitysessionInput>
  }

  export type attendanceScalarWhereInput = {
    AND?: attendanceScalarWhereInput | attendanceScalarWhereInput[]
    OR?: attendanceScalarWhereInput[]
    NOT?: attendanceScalarWhereInput | attendanceScalarWhereInput[]
    id?: IntFilter<"attendance"> | number
    sessionId?: IntFilter<"attendance"> | number
    userId?: IntFilter<"attendance"> | number
    status?: StringFilter<"attendance"> | string
  }

  export type activitysessionCreateWithoutAfterschoolactivityInput = {
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    attendance?: attendanceCreateNestedManyWithoutActivitysessionInput
  }

  export type activitysessionUncheckedCreateWithoutAfterschoolactivityInput = {
    id?: number
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    attendance?: attendanceUncheckedCreateNestedManyWithoutActivitysessionInput
  }

  export type activitysessionCreateOrConnectWithoutAfterschoolactivityInput = {
    where: activitysessionWhereUniqueInput
    create: XOR<activitysessionCreateWithoutAfterschoolactivityInput, activitysessionUncheckedCreateWithoutAfterschoolactivityInput>
  }

  export type activitysessionCreateManyAfterschoolactivityInputEnvelope = {
    data: activitysessionCreateManyAfterschoolactivityInput | activitysessionCreateManyAfterschoolactivityInput[]
    skipDuplicates?: boolean
  }

  export type enrolledactivityCreateWithoutAfterschoolactivityInput = {
    enrollmentDate?: Date | string
    user: userCreateNestedOneWithoutEnrolledactivityInput
  }

  export type enrolledactivityUncheckedCreateWithoutAfterschoolactivityInput = {
    id?: number
    userId: number
    enrollmentDate?: Date | string
  }

  export type enrolledactivityCreateOrConnectWithoutAfterschoolactivityInput = {
    where: enrolledactivityWhereUniqueInput
    create: XOR<enrolledactivityCreateWithoutAfterschoolactivityInput, enrolledactivityUncheckedCreateWithoutAfterschoolactivityInput>
  }

  export type enrolledactivityCreateManyAfterschoolactivityInputEnvelope = {
    data: enrolledactivityCreateManyAfterschoolactivityInput | enrolledactivityCreateManyAfterschoolactivityInput[]
    skipDuplicates?: boolean
  }

  export type activitysessionUpsertWithWhereUniqueWithoutAfterschoolactivityInput = {
    where: activitysessionWhereUniqueInput
    update: XOR<activitysessionUpdateWithoutAfterschoolactivityInput, activitysessionUncheckedUpdateWithoutAfterschoolactivityInput>
    create: XOR<activitysessionCreateWithoutAfterschoolactivityInput, activitysessionUncheckedCreateWithoutAfterschoolactivityInput>
  }

  export type activitysessionUpdateWithWhereUniqueWithoutAfterschoolactivityInput = {
    where: activitysessionWhereUniqueInput
    data: XOR<activitysessionUpdateWithoutAfterschoolactivityInput, activitysessionUncheckedUpdateWithoutAfterschoolactivityInput>
  }

  export type activitysessionUpdateManyWithWhereWithoutAfterschoolactivityInput = {
    where: activitysessionScalarWhereInput
    data: XOR<activitysessionUpdateManyMutationInput, activitysessionUncheckedUpdateManyWithoutAfterschoolactivityInput>
  }

  export type activitysessionScalarWhereInput = {
    AND?: activitysessionScalarWhereInput | activitysessionScalarWhereInput[]
    OR?: activitysessionScalarWhereInput[]
    NOT?: activitysessionScalarWhereInput | activitysessionScalarWhereInput[]
    id?: IntFilter<"activitysession"> | number
    activityId?: IntFilter<"activitysession"> | number
    date?: DateTimeFilter<"activitysession"> | Date | string
    createdAt?: DateTimeFilter<"activitysession"> | Date | string
    updatedAt?: DateTimeFilter<"activitysession"> | Date | string
  }

  export type enrolledactivityUpsertWithWhereUniqueWithoutAfterschoolactivityInput = {
    where: enrolledactivityWhereUniqueInput
    update: XOR<enrolledactivityUpdateWithoutAfterschoolactivityInput, enrolledactivityUncheckedUpdateWithoutAfterschoolactivityInput>
    create: XOR<enrolledactivityCreateWithoutAfterschoolactivityInput, enrolledactivityUncheckedCreateWithoutAfterschoolactivityInput>
  }

  export type enrolledactivityUpdateWithWhereUniqueWithoutAfterschoolactivityInput = {
    where: enrolledactivityWhereUniqueInput
    data: XOR<enrolledactivityUpdateWithoutAfterschoolactivityInput, enrolledactivityUncheckedUpdateWithoutAfterschoolactivityInput>
  }

  export type enrolledactivityUpdateManyWithWhereWithoutAfterschoolactivityInput = {
    where: enrolledactivityScalarWhereInput
    data: XOR<enrolledactivityUpdateManyMutationInput, enrolledactivityUncheckedUpdateManyWithoutAfterschoolactivityInput>
  }

  export type enrolledactivityScalarWhereInput = {
    AND?: enrolledactivityScalarWhereInput | enrolledactivityScalarWhereInput[]
    OR?: enrolledactivityScalarWhereInput[]
    NOT?: enrolledactivityScalarWhereInput | enrolledactivityScalarWhereInput[]
    id?: IntFilter<"enrolledactivity"> | number
    userId?: IntFilter<"enrolledactivity"> | number
    activityId?: IntFilter<"enrolledactivity"> | number
    enrollmentDate?: DateTimeFilter<"enrolledactivity"> | Date | string
  }

  export type activitysessionCreateWithoutAttendanceInput = {
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    afterschoolactivity: afterschoolactivityCreateNestedOneWithoutActivitysessionInput
  }

  export type activitysessionUncheckedCreateWithoutAttendanceInput = {
    id?: number
    activityId: number
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type activitysessionCreateOrConnectWithoutAttendanceInput = {
    where: activitysessionWhereUniqueInput
    create: XOR<activitysessionCreateWithoutAttendanceInput, activitysessionUncheckedCreateWithoutAttendanceInput>
  }

  export type userCreateWithoutAttendanceInput = {
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    type: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    is_situation: string
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    nationalities: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    religion: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: string
    isESL: number
    house: string
    isofficial: number
    isEnrolledInAfterSchool?: boolean
    enrolledactivity?: enrolledactivityCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAttendanceInput = {
    id?: number
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    type: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    is_situation: string
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    nationalities: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    religion: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: string
    isESL: number
    house: string
    isofficial: number
    isEnrolledInAfterSchool?: boolean
    enrolledactivity?: enrolledactivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAttendanceInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAttendanceInput, userUncheckedCreateWithoutAttendanceInput>
  }

  export type activitysessionUpsertWithoutAttendanceInput = {
    update: XOR<activitysessionUpdateWithoutAttendanceInput, activitysessionUncheckedUpdateWithoutAttendanceInput>
    create: XOR<activitysessionCreateWithoutAttendanceInput, activitysessionUncheckedCreateWithoutAttendanceInput>
    where?: activitysessionWhereInput
  }

  export type activitysessionUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: activitysessionWhereInput
    data: XOR<activitysessionUpdateWithoutAttendanceInput, activitysessionUncheckedUpdateWithoutAttendanceInput>
  }

  export type activitysessionUpdateWithoutAttendanceInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    afterschoolactivity?: afterschoolactivityUpdateOneRequiredWithoutActivitysessionNestedInput
  }

  export type activitysessionUncheckedUpdateWithoutAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpsertWithoutAttendanceInput = {
    update: XOR<userUpdateWithoutAttendanceInput, userUncheckedUpdateWithoutAttendanceInput>
    create: XOR<userCreateWithoutAttendanceInput, userUncheckedCreateWithoutAttendanceInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAttendanceInput, userUncheckedUpdateWithoutAttendanceInput>
  }

  export type userUpdateWithoutAttendanceInput = {
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    is_situation?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    nationalities?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    isESL?: IntFieldUpdateOperationsInput | number
    house?: StringFieldUpdateOperationsInput | string
    isofficial?: IntFieldUpdateOperationsInput | number
    isEnrolledInAfterSchool?: BoolFieldUpdateOperationsInput | boolean
    enrolledactivity?: enrolledactivityUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    is_situation?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    nationalities?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    isESL?: IntFieldUpdateOperationsInput | number
    house?: StringFieldUpdateOperationsInput | string
    isofficial?: IntFieldUpdateOperationsInput | number
    isEnrolledInAfterSchool?: BoolFieldUpdateOperationsInput | boolean
    enrolledactivity?: enrolledactivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type afterschoolactivityCreateWithoutEnrolledactivityInput = {
    name: string
    description?: string | null
    dayOfWeek: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coachName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    photo?: string | null
    activitysession?: activitysessionCreateNestedManyWithoutAfterschoolactivityInput
  }

  export type afterschoolactivityUncheckedCreateWithoutEnrolledactivityInput = {
    id?: number
    name: string
    description?: string | null
    dayOfWeek: string
    startTime: Date | string
    endTime: Date | string
    location?: string | null
    coachName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    photo?: string | null
    activitysession?: activitysessionUncheckedCreateNestedManyWithoutAfterschoolactivityInput
  }

  export type afterschoolactivityCreateOrConnectWithoutEnrolledactivityInput = {
    where: afterschoolactivityWhereUniqueInput
    create: XOR<afterschoolactivityCreateWithoutEnrolledactivityInput, afterschoolactivityUncheckedCreateWithoutEnrolledactivityInput>
  }

  export type userCreateWithoutEnrolledactivityInput = {
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    type: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    is_situation: string
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    nationalities: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    religion: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: string
    isESL: number
    house: string
    isofficial: number
    isEnrolledInAfterSchool?: boolean
    attendance?: attendanceCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutEnrolledactivityInput = {
    id?: number
    rfid: bigint | number
    fname: string
    mname: string
    lname: string
    type: string
    gender: string
    position: string
    grade: string
    section: string
    dob: Date | string
    email: string
    mobile: string
    vacchist: string
    photo: string
    manager: string
    isactive: number
    is_situation: string
    username: string
    password: string
    level: number
    status: number
    prevsch: string
    prevschcountry: string
    lrn: string
    uniqid: string
    tf: string
    country: string
    nationality: string
    nationalities: string
    guardianname: string
    guardianemail: string
    guardianphone: string
    referral: string
    apptype: string
    sy: string
    strand: string
    religion: string
    visa: string
    earlybird: number
    modelrelease: number
    feepolicy: number
    refund: number
    tos: number
    empno: string
    isESL: number
    house: string
    isofficial: number
    isEnrolledInAfterSchool?: boolean
    attendance?: attendanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutEnrolledactivityInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEnrolledactivityInput, userUncheckedCreateWithoutEnrolledactivityInput>
  }

  export type afterschoolactivityUpsertWithoutEnrolledactivityInput = {
    update: XOR<afterschoolactivityUpdateWithoutEnrolledactivityInput, afterschoolactivityUncheckedUpdateWithoutEnrolledactivityInput>
    create: XOR<afterschoolactivityCreateWithoutEnrolledactivityInput, afterschoolactivityUncheckedCreateWithoutEnrolledactivityInput>
    where?: afterschoolactivityWhereInput
  }

  export type afterschoolactivityUpdateToOneWithWhereWithoutEnrolledactivityInput = {
    where?: afterschoolactivityWhereInput
    data: XOR<afterschoolactivityUpdateWithoutEnrolledactivityInput, afterschoolactivityUncheckedUpdateWithoutEnrolledactivityInput>
  }

  export type afterschoolactivityUpdateWithoutEnrolledactivityInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coachName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    activitysession?: activitysessionUpdateManyWithoutAfterschoolactivityNestedInput
  }

  export type afterschoolactivityUncheckedUpdateWithoutEnrolledactivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coachName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    activitysession?: activitysessionUncheckedUpdateManyWithoutAfterschoolactivityNestedInput
  }

  export type userUpsertWithoutEnrolledactivityInput = {
    update: XOR<userUpdateWithoutEnrolledactivityInput, userUncheckedUpdateWithoutEnrolledactivityInput>
    create: XOR<userCreateWithoutEnrolledactivityInput, userUncheckedCreateWithoutEnrolledactivityInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutEnrolledactivityInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutEnrolledactivityInput, userUncheckedUpdateWithoutEnrolledactivityInput>
  }

  export type userUpdateWithoutEnrolledactivityInput = {
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    is_situation?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    nationalities?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    isESL?: IntFieldUpdateOperationsInput | number
    house?: StringFieldUpdateOperationsInput | string
    isofficial?: IntFieldUpdateOperationsInput | number
    isEnrolledInAfterSchool?: BoolFieldUpdateOperationsInput | boolean
    attendance?: attendanceUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutEnrolledactivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    rfid?: BigIntFieldUpdateOperationsInput | bigint | number
    fname?: StringFieldUpdateOperationsInput | string
    mname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    vacchist?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    isactive?: IntFieldUpdateOperationsInput | number
    is_situation?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    prevsch?: StringFieldUpdateOperationsInput | string
    prevschcountry?: StringFieldUpdateOperationsInput | string
    lrn?: StringFieldUpdateOperationsInput | string
    uniqid?: StringFieldUpdateOperationsInput | string
    tf?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    nationality?: StringFieldUpdateOperationsInput | string
    nationalities?: StringFieldUpdateOperationsInput | string
    guardianname?: StringFieldUpdateOperationsInput | string
    guardianemail?: StringFieldUpdateOperationsInput | string
    guardianphone?: StringFieldUpdateOperationsInput | string
    referral?: StringFieldUpdateOperationsInput | string
    apptype?: StringFieldUpdateOperationsInput | string
    sy?: StringFieldUpdateOperationsInput | string
    strand?: StringFieldUpdateOperationsInput | string
    religion?: StringFieldUpdateOperationsInput | string
    visa?: StringFieldUpdateOperationsInput | string
    earlybird?: IntFieldUpdateOperationsInput | number
    modelrelease?: IntFieldUpdateOperationsInput | number
    feepolicy?: IntFieldUpdateOperationsInput | number
    refund?: IntFieldUpdateOperationsInput | number
    tos?: IntFieldUpdateOperationsInput | number
    empno?: StringFieldUpdateOperationsInput | string
    isESL?: IntFieldUpdateOperationsInput | number
    house?: StringFieldUpdateOperationsInput | string
    isofficial?: IntFieldUpdateOperationsInput | number
    isEnrolledInAfterSchool?: BoolFieldUpdateOperationsInput | boolean
    attendance?: attendanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type attendanceCreateWithoutUserInput = {
    status: string
    activitysession: activitysessionCreateNestedOneWithoutAttendanceInput
  }

  export type attendanceUncheckedCreateWithoutUserInput = {
    id?: number
    sessionId: number
    status: string
  }

  export type attendanceCreateOrConnectWithoutUserInput = {
    where: attendanceWhereUniqueInput
    create: XOR<attendanceCreateWithoutUserInput, attendanceUncheckedCreateWithoutUserInput>
  }

  export type attendanceCreateManyUserInputEnvelope = {
    data: attendanceCreateManyUserInput | attendanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type enrolledactivityCreateWithoutUserInput = {
    enrollmentDate?: Date | string
    afterschoolactivity: afterschoolactivityCreateNestedOneWithoutEnrolledactivityInput
  }

  export type enrolledactivityUncheckedCreateWithoutUserInput = {
    id?: number
    activityId: number
    enrollmentDate?: Date | string
  }

  export type enrolledactivityCreateOrConnectWithoutUserInput = {
    where: enrolledactivityWhereUniqueInput
    create: XOR<enrolledactivityCreateWithoutUserInput, enrolledactivityUncheckedCreateWithoutUserInput>
  }

  export type enrolledactivityCreateManyUserInputEnvelope = {
    data: enrolledactivityCreateManyUserInput | enrolledactivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type attendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: attendanceWhereUniqueInput
    update: XOR<attendanceUpdateWithoutUserInput, attendanceUncheckedUpdateWithoutUserInput>
    create: XOR<attendanceCreateWithoutUserInput, attendanceUncheckedCreateWithoutUserInput>
  }

  export type attendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: attendanceWhereUniqueInput
    data: XOR<attendanceUpdateWithoutUserInput, attendanceUncheckedUpdateWithoutUserInput>
  }

  export type attendanceUpdateManyWithWhereWithoutUserInput = {
    where: attendanceScalarWhereInput
    data: XOR<attendanceUpdateManyMutationInput, attendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type enrolledactivityUpsertWithWhereUniqueWithoutUserInput = {
    where: enrolledactivityWhereUniqueInput
    update: XOR<enrolledactivityUpdateWithoutUserInput, enrolledactivityUncheckedUpdateWithoutUserInput>
    create: XOR<enrolledactivityCreateWithoutUserInput, enrolledactivityUncheckedCreateWithoutUserInput>
  }

  export type enrolledactivityUpdateWithWhereUniqueWithoutUserInput = {
    where: enrolledactivityWhereUniqueInput
    data: XOR<enrolledactivityUpdateWithoutUserInput, enrolledactivityUncheckedUpdateWithoutUserInput>
  }

  export type enrolledactivityUpdateManyWithWhereWithoutUserInput = {
    where: enrolledactivityScalarWhereInput
    data: XOR<enrolledactivityUpdateManyMutationInput, enrolledactivityUncheckedUpdateManyWithoutUserInput>
  }

  export type attendanceCreateManyActivitysessionInput = {
    id?: number
    userId: number
    status: string
  }

  export type attendanceUpdateWithoutActivitysessionInput = {
    status?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type attendanceUncheckedUpdateWithoutActivitysessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type attendanceUncheckedUpdateManyWithoutActivitysessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type activitysessionCreateManyAfterschoolactivityInput = {
    id?: number
    date: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type enrolledactivityCreateManyAfterschoolactivityInput = {
    id?: number
    userId: number
    enrollmentDate?: Date | string
  }

  export type activitysessionUpdateWithoutAfterschoolactivityInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: attendanceUpdateManyWithoutActivitysessionNestedInput
  }

  export type activitysessionUncheckedUpdateWithoutAfterschoolactivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: attendanceUncheckedUpdateManyWithoutActivitysessionNestedInput
  }

  export type activitysessionUncheckedUpdateManyWithoutAfterschoolactivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type enrolledactivityUpdateWithoutAfterschoolactivityInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutEnrolledactivityNestedInput
  }

  export type enrolledactivityUncheckedUpdateWithoutAfterschoolactivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type enrolledactivityUncheckedUpdateManyWithoutAfterschoolactivityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendanceCreateManyUserInput = {
    id?: number
    sessionId: number
    status: string
  }

  export type enrolledactivityCreateManyUserInput = {
    id?: number
    activityId: number
    enrollmentDate?: Date | string
  }

  export type attendanceUpdateWithoutUserInput = {
    status?: StringFieldUpdateOperationsInput | string
    activitysession?: activitysessionUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type attendanceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type attendanceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type enrolledactivityUpdateWithoutUserInput = {
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    afterschoolactivity?: afterschoolactivityUpdateOneRequiredWithoutEnrolledactivityNestedInput
  }

  export type enrolledactivityUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type enrolledactivityUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}